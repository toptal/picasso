/******/ ;(() => {
  // webpackBootstrap
  /******/ var __webpack_modules__ = {
    /***/ 7351: /***/ function (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) {
      'use strict'

      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k]
                },
              })
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k
              o[k2] = m[k]
            })
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, 'default', {
                enumerable: true,
                value: v,
              })
            }
          : function (o, v) {
              o['default'] = v
            })
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod
          var result = {}
          if (mod != null)
            for (var k in mod)
              if (k !== 'default' && Object.hasOwnProperty.call(mod, k))
                __createBinding(result, mod, k)
          __setModuleDefault(result, mod)
          return result
        }
      Object.defineProperty(exports, '__esModule', { value: true })
      exports.issue = exports.issueCommand = void 0
      const os = __importStar(__nccwpck_require__(2037))
      const utils_1 = __nccwpck_require__(5278)
      /**
       * Commands
       *
       * Command Format:
       *   ::name key=value,key=value::message
       *
       * Examples:
       *   ::warning::This is the message
       *   ::set-env name=MY_VAR::some value
       */
      function issueCommand(command, properties, message) {
        const cmd = new Command(command, properties, message)
        process.stdout.write(cmd.toString() + os.EOL)
      }
      exports.issueCommand = issueCommand
      function issue(name, message = '') {
        issueCommand(name, {}, message)
      }
      exports.issue = issue
      const CMD_STRING = '::'
      class Command {
        constructor(command, properties, message) {
          if (!command) {
            command = 'missing.command'
          }
          this.command = command
          this.properties = properties
          this.message = message
        }
        toString() {
          let cmdStr = CMD_STRING + this.command
          if (this.properties && Object.keys(this.properties).length > 0) {
            cmdStr += ' '
            let first = true
            for (const key in this.properties) {
              if (this.properties.hasOwnProperty(key)) {
                const val = this.properties[key]
                if (val) {
                  if (first) {
                    first = false
                  } else {
                    cmdStr += ','
                  }
                  cmdStr += `${key}=${escapeProperty(val)}`
                }
              }
            }
          }
          cmdStr += `${CMD_STRING}${escapeData(this.message)}`
          return cmdStr
        }
      }
      function escapeData(s) {
        return utils_1
          .toCommandValue(s)
          .replace(/%/g, '%25')
          .replace(/\r/g, '%0D')
          .replace(/\n/g, '%0A')
      }
      function escapeProperty(s) {
        return utils_1
          .toCommandValue(s)
          .replace(/%/g, '%25')
          .replace(/\r/g, '%0D')
          .replace(/\n/g, '%0A')
          .replace(/:/g, '%3A')
          .replace(/,/g, '%2C')
      }
      //# sourceMappingURL=command.js.map

      /***/
    },

    /***/ 2186: /***/ function (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) {
      'use strict'

      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k]
                },
              })
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k
              o[k2] = m[k]
            })
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, 'default', {
                enumerable: true,
                value: v,
              })
            }
          : function (o, v) {
              o['default'] = v
            })
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod
          var result = {}
          if (mod != null)
            for (var k in mod)
              if (k !== 'default' && Object.hasOwnProperty.call(mod, k))
                __createBinding(result, mod, k)
          __setModuleDefault(result, mod)
          return result
        }
      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value)
                })
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value))
              } catch (e) {
                reject(e)
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value))
              } catch (e) {
                reject(e)
              }
            }
            function step(result) {
              result.done
                ? resolve(result.value)
                : adopt(result.value).then(fulfilled, rejected)
            }
            step(
              (generator = generator.apply(thisArg, _arguments || [])).next()
            )
          })
        }
      Object.defineProperty(exports, '__esModule', { value: true })
      exports.getIDToken =
        exports.getState =
        exports.saveState =
        exports.group =
        exports.endGroup =
        exports.startGroup =
        exports.info =
        exports.notice =
        exports.warning =
        exports.error =
        exports.debug =
        exports.isDebug =
        exports.setFailed =
        exports.setCommandEcho =
        exports.setOutput =
        exports.getBooleanInput =
        exports.getMultilineInput =
        exports.getInput =
        exports.addPath =
        exports.setSecret =
        exports.exportVariable =
        exports.ExitCode =
          void 0
      const command_1 = __nccwpck_require__(7351)
      const file_command_1 = __nccwpck_require__(717)
      const utils_1 = __nccwpck_require__(5278)
      const os = __importStar(__nccwpck_require__(2037))
      const path = __importStar(__nccwpck_require__(1017))
      const oidc_utils_1 = __nccwpck_require__(8041)
      /**
       * The code to exit an action
       */
      var ExitCode
      ;(function (ExitCode) {
        /**
         * A code indicating that the action was successful
         */
        ExitCode[(ExitCode['Success'] = 0)] = 'Success'
        /**
         * A code indicating that the action was a failure
         */
        ExitCode[(ExitCode['Failure'] = 1)] = 'Failure'
      })((ExitCode = exports.ExitCode || (exports.ExitCode = {})))
      //-----------------------------------------------------------------------
      // Variables
      //-----------------------------------------------------------------------
      /**
       * Sets env variable for this action and future actions in the job
       * @param name the name of the variable to set
       * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      function exportVariable(name, val) {
        const convertedVal = utils_1.toCommandValue(val)
        process.env[name] = convertedVal
        const filePath = process.env['GITHUB_ENV'] || ''
        if (filePath) {
          return file_command_1.issueFileCommand(
            'ENV',
            file_command_1.prepareKeyValueMessage(name, val)
          )
        }
        command_1.issueCommand('set-env', { name }, convertedVal)
      }
      exports.exportVariable = exportVariable
      /**
       * Registers a secret which will get masked from logs
       * @param secret value of the secret
       */
      function setSecret(secret) {
        command_1.issueCommand('add-mask', {}, secret)
      }
      exports.setSecret = setSecret
      /**
       * Prepends inputPath to the PATH (for this action and future actions)
       * @param inputPath
       */
      function addPath(inputPath) {
        const filePath = process.env['GITHUB_PATH'] || ''
        if (filePath) {
          file_command_1.issueFileCommand('PATH', inputPath)
        } else {
          command_1.issueCommand('add-path', {}, inputPath)
        }
        process.env[
          'PATH'
        ] = `${inputPath}${path.delimiter}${process.env['PATH']}`
      }
      exports.addPath = addPath
      /**
       * Gets the value of an input.
       * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
       * Returns an empty string if the value is not defined.
       *
       * @param     name     name of the input to get
       * @param     options  optional. See InputOptions.
       * @returns   string
       */
      function getInput(name, options) {
        const val =
          process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || ''
        if (options && options.required && !val) {
          throw new Error(`Input required and not supplied: ${name}`)
        }
        if (options && options.trimWhitespace === false) {
          return val
        }
        return val.trim()
      }
      exports.getInput = getInput
      /**
       * Gets the values of an multiline input.  Each value is also trimmed.
       *
       * @param     name     name of the input to get
       * @param     options  optional. See InputOptions.
       * @returns   string[]
       *
       */
      function getMultilineInput(name, options) {
        const inputs = getInput(name, options)
          .split('\n')
          .filter(x => x !== '')
        if (options && options.trimWhitespace === false) {
          return inputs
        }
        return inputs.map(input => input.trim())
      }
      exports.getMultilineInput = getMultilineInput
      /**
       * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
       * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
       * The return value is also in boolean type.
       * ref: https://yaml.org/spec/1.2/spec.html#id2804923
       *
       * @param     name     name of the input to get
       * @param     options  optional. See InputOptions.
       * @returns   boolean
       */
      function getBooleanInput(name, options) {
        const trueValue = ['true', 'True', 'TRUE']
        const falseValue = ['false', 'False', 'FALSE']
        const val = getInput(name, options)
        if (trueValue.includes(val)) return true
        if (falseValue.includes(val)) return false
        throw new TypeError(
          `Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
            `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``
        )
      }
      exports.getBooleanInput = getBooleanInput
      /**
       * Sets the value of an output.
       *
       * @param     name     name of the output to set
       * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      function setOutput(name, value) {
        const filePath = process.env['GITHUB_OUTPUT'] || ''
        if (filePath) {
          return file_command_1.issueFileCommand(
            'OUTPUT',
            file_command_1.prepareKeyValueMessage(name, value)
          )
        }
        process.stdout.write(os.EOL)
        command_1.issueCommand(
          'set-output',
          { name },
          utils_1.toCommandValue(value)
        )
      }
      exports.setOutput = setOutput
      /**
       * Enables or disables the echoing of commands into stdout for the rest of the step.
       * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
       *
       */
      function setCommandEcho(enabled) {
        command_1.issue('echo', enabled ? 'on' : 'off')
      }
      exports.setCommandEcho = setCommandEcho
      //-----------------------------------------------------------------------
      // Results
      //-----------------------------------------------------------------------
      /**
       * Sets the action status to failed.
       * When the action exits it will be with an exit code of 1
       * @param message add error issue message
       */
      function setFailed(message) {
        process.exitCode = ExitCode.Failure
        error(message)
      }
      exports.setFailed = setFailed
      //-----------------------------------------------------------------------
      // Logging Commands
      //-----------------------------------------------------------------------
      /**
       * Gets whether Actions Step Debug is on or not
       */
      function isDebug() {
        return process.env['RUNNER_DEBUG'] === '1'
      }
      exports.isDebug = isDebug
      /**
       * Writes debug message to user log
       * @param message debug message
       */
      function debug(message) {
        command_1.issueCommand('debug', {}, message)
      }
      exports.debug = debug
      /**
       * Adds an error issue
       * @param message error issue message. Errors will be converted to string via toString()
       * @param properties optional properties to add to the annotation.
       */
      function error(message, properties = {}) {
        command_1.issueCommand(
          'error',
          utils_1.toCommandProperties(properties),
          message instanceof Error ? message.toString() : message
        )
      }
      exports.error = error
      /**
       * Adds a warning issue
       * @param message warning issue message. Errors will be converted to string via toString()
       * @param properties optional properties to add to the annotation.
       */
      function warning(message, properties = {}) {
        command_1.issueCommand(
          'warning',
          utils_1.toCommandProperties(properties),
          message instanceof Error ? message.toString() : message
        )
      }
      exports.warning = warning
      /**
       * Adds a notice issue
       * @param message notice issue message. Errors will be converted to string via toString()
       * @param properties optional properties to add to the annotation.
       */
      function notice(message, properties = {}) {
        command_1.issueCommand(
          'notice',
          utils_1.toCommandProperties(properties),
          message instanceof Error ? message.toString() : message
        )
      }
      exports.notice = notice
      /**
       * Writes info to log with console.log.
       * @param message info message
       */
      function info(message) {
        process.stdout.write(message + os.EOL)
      }
      exports.info = info
      /**
       * Begin an output group.
       *
       * Output until the next `groupEnd` will be foldable in this group
       *
       * @param name The name of the output group
       */
      function startGroup(name) {
        command_1.issue('group', name)
      }
      exports.startGroup = startGroup
      /**
       * End an output group.
       */
      function endGroup() {
        command_1.issue('endgroup')
      }
      exports.endGroup = endGroup
      /**
       * Wrap an asynchronous function call in a group.
       *
       * Returns the same type as the function itself.
       *
       * @param name The name of the group
       * @param fn The function to wrap in the group
       */
      function group(name, fn) {
        return __awaiter(this, void 0, void 0, function* () {
          startGroup(name)
          let result
          try {
            result = yield fn()
          } finally {
            endGroup()
          }
          return result
        })
      }
      exports.group = group
      //-----------------------------------------------------------------------
      // Wrapper action state
      //-----------------------------------------------------------------------
      /**
       * Saves state for current action, the state can only be retrieved by this action's post job execution.
       *
       * @param     name     name of the state to store
       * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      function saveState(name, value) {
        const filePath = process.env['GITHUB_STATE'] || ''
        if (filePath) {
          return file_command_1.issueFileCommand(
            'STATE',
            file_command_1.prepareKeyValueMessage(name, value)
          )
        }
        command_1.issueCommand(
          'save-state',
          { name },
          utils_1.toCommandValue(value)
        )
      }
      exports.saveState = saveState
      /**
       * Gets the value of an state set by this action's main execution.
       *
       * @param     name     name of the state to get
       * @returns   string
       */
      function getState(name) {
        return process.env[`STATE_${name}`] || ''
      }
      exports.getState = getState
      function getIDToken(aud) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield oidc_utils_1.OidcClient.getIDToken(aud)
        })
      }
      exports.getIDToken = getIDToken
      /**
       * Summary exports
       */
      var summary_1 = __nccwpck_require__(1327)
      Object.defineProperty(exports, 'summary', {
        enumerable: true,
        get: function () {
          return summary_1.summary
        },
      })
      /**
       * @deprecated use core.summary
       */
      var summary_2 = __nccwpck_require__(1327)
      Object.defineProperty(exports, 'markdownSummary', {
        enumerable: true,
        get: function () {
          return summary_2.markdownSummary
        },
      })
      /**
       * Path exports
       */
      var path_utils_1 = __nccwpck_require__(2981)
      Object.defineProperty(exports, 'toPosixPath', {
        enumerable: true,
        get: function () {
          return path_utils_1.toPosixPath
        },
      })
      Object.defineProperty(exports, 'toWin32Path', {
        enumerable: true,
        get: function () {
          return path_utils_1.toWin32Path
        },
      })
      Object.defineProperty(exports, 'toPlatformPath', {
        enumerable: true,
        get: function () {
          return path_utils_1.toPlatformPath
        },
      })
      //# sourceMappingURL=core.js.map

      /***/
    },

    /***/ 717: /***/ function (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) {
      'use strict'

      // For internal use, subject to change.
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k]
                },
              })
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k
              o[k2] = m[k]
            })
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, 'default', {
                enumerable: true,
                value: v,
              })
            }
          : function (o, v) {
              o['default'] = v
            })
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod
          var result = {}
          if (mod != null)
            for (var k in mod)
              if (k !== 'default' && Object.hasOwnProperty.call(mod, k))
                __createBinding(result, mod, k)
          __setModuleDefault(result, mod)
          return result
        }
      Object.defineProperty(exports, '__esModule', { value: true })
      exports.prepareKeyValueMessage = exports.issueFileCommand = void 0
      // We use any as a valid input type
      /* eslint-disable @typescript-eslint/no-explicit-any */
      const fs = __importStar(__nccwpck_require__(7147))
      const os = __importStar(__nccwpck_require__(2037))
      const uuid_1 = __nccwpck_require__(5840)
      const utils_1 = __nccwpck_require__(5278)
      function issueFileCommand(command, message) {
        const filePath = process.env[`GITHUB_${command}`]
        if (!filePath) {
          throw new Error(
            `Unable to find environment variable for file command ${command}`
          )
        }
        if (!fs.existsSync(filePath)) {
          throw new Error(`Missing file at path: ${filePath}`)
        }
        fs.appendFileSync(
          filePath,
          `${utils_1.toCommandValue(message)}${os.EOL}`,
          {
            encoding: 'utf8',
          }
        )
      }
      exports.issueFileCommand = issueFileCommand
      function prepareKeyValueMessage(key, value) {
        const delimiter = `ghadelimiter_${uuid_1.v4()}`
        const convertedValue = utils_1.toCommandValue(value)
        // These should realistically never happen, but just in case someone finds a
        // way to exploit uuid generation let's not allow keys or values that contain
        // the delimiter.
        if (key.includes(delimiter)) {
          throw new Error(
            `Unexpected input: name should not contain the delimiter "${delimiter}"`
          )
        }
        if (convertedValue.includes(delimiter)) {
          throw new Error(
            `Unexpected input: value should not contain the delimiter "${delimiter}"`
          )
        }
        return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`
      }
      exports.prepareKeyValueMessage = prepareKeyValueMessage
      //# sourceMappingURL=file-command.js.map

      /***/
    },

    /***/ 8041: /***/ function (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) {
      'use strict'

      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value)
                })
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value))
              } catch (e) {
                reject(e)
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value))
              } catch (e) {
                reject(e)
              }
            }
            function step(result) {
              result.done
                ? resolve(result.value)
                : adopt(result.value).then(fulfilled, rejected)
            }
            step(
              (generator = generator.apply(thisArg, _arguments || [])).next()
            )
          })
        }
      Object.defineProperty(exports, '__esModule', { value: true })
      exports.OidcClient = void 0
      const http_client_1 = __nccwpck_require__(6255)
      const auth_1 = __nccwpck_require__(5526)
      const core_1 = __nccwpck_require__(2186)
      class OidcClient {
        static createHttpClient(allowRetry = true, maxRetry = 10) {
          const requestOptions = {
            allowRetries: allowRetry,
            maxRetries: maxRetry,
          }
          return new http_client_1.HttpClient(
            'actions/oidc-client',
            [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())],
            requestOptions
          )
        }
        static getRequestToken() {
          const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN']
          if (!token) {
            throw new Error(
              'Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable'
            )
          }
          return token
        }
        static getIDTokenUrl() {
          const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL']
          if (!runtimeUrl) {
            throw new Error(
              'Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable'
            )
          }
          return runtimeUrl
        }
        static getCall(id_token_url) {
          var _a
          return __awaiter(this, void 0, void 0, function* () {
            const httpclient = OidcClient.createHttpClient()
            const res = yield httpclient.getJson(id_token_url).catch(error => {
              throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.result.message}`)
            })
            const id_token =
              (_a = res.result) === null || _a === void 0 ? void 0 : _a.value
            if (!id_token) {
              throw new Error('Response json body do not have ID Token field')
            }
            return id_token
          })
        }
        static getIDToken(audience) {
          return __awaiter(this, void 0, void 0, function* () {
            try {
              // New ID Token is requested from action service
              let id_token_url = OidcClient.getIDTokenUrl()
              if (audience) {
                const encodedAudience = encodeURIComponent(audience)
                id_token_url = `${id_token_url}&audience=${encodedAudience}`
              }
              core_1.debug(`ID token url is ${id_token_url}`)
              const id_token = yield OidcClient.getCall(id_token_url)
              core_1.setSecret(id_token)
              return id_token
            } catch (error) {
              throw new Error(`Error message: ${error.message}`)
            }
          })
        }
      }
      exports.OidcClient = OidcClient
      //# sourceMappingURL=oidc-utils.js.map

      /***/
    },

    /***/ 2981: /***/ function (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) {
      'use strict'

      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k]
                },
              })
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k
              o[k2] = m[k]
            })
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, 'default', {
                enumerable: true,
                value: v,
              })
            }
          : function (o, v) {
              o['default'] = v
            })
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod
          var result = {}
          if (mod != null)
            for (var k in mod)
              if (k !== 'default' && Object.hasOwnProperty.call(mod, k))
                __createBinding(result, mod, k)
          __setModuleDefault(result, mod)
          return result
        }
      Object.defineProperty(exports, '__esModule', { value: true })
      exports.toPlatformPath =
        exports.toWin32Path =
        exports.toPosixPath =
          void 0
      const path = __importStar(__nccwpck_require__(1017))
      /**
       * toPosixPath converts the given path to the posix form. On Windows, \\ will be
       * replaced with /.
       *
       * @param pth. Path to transform.
       * @return string Posix path.
       */
      function toPosixPath(pth) {
        return pth.replace(/[\\]/g, '/')
      }
      exports.toPosixPath = toPosixPath
      /**
       * toWin32Path converts the given path to the win32 form. On Linux, / will be
       * replaced with \\.
       *
       * @param pth. Path to transform.
       * @return string Win32 path.
       */
      function toWin32Path(pth) {
        return pth.replace(/[/]/g, '\\')
      }
      exports.toWin32Path = toWin32Path
      /**
       * toPlatformPath converts the given path to a platform-specific path. It does
       * this by replacing instances of / and \ with the platform-specific path
       * separator.
       *
       * @param pth The path to platformize.
       * @return string The platform-specific path.
       */
      function toPlatformPath(pth) {
        return pth.replace(/[/\\]/g, path.sep)
      }
      exports.toPlatformPath = toPlatformPath
      //# sourceMappingURL=path-utils.js.map

      /***/
    },

    /***/ 1327: /***/ function (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) {
      'use strict'

      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value)
                })
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value))
              } catch (e) {
                reject(e)
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value))
              } catch (e) {
                reject(e)
              }
            }
            function step(result) {
              result.done
                ? resolve(result.value)
                : adopt(result.value).then(fulfilled, rejected)
            }
            step(
              (generator = generator.apply(thisArg, _arguments || [])).next()
            )
          })
        }
      Object.defineProperty(exports, '__esModule', { value: true })
      exports.summary =
        exports.markdownSummary =
        exports.SUMMARY_DOCS_URL =
        exports.SUMMARY_ENV_VAR =
          void 0
      const os_1 = __nccwpck_require__(2037)
      const fs_1 = __nccwpck_require__(7147)
      const { access, appendFile, writeFile } = fs_1.promises
      exports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY'
      exports.SUMMARY_DOCS_URL =
        'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary'
      class Summary {
        constructor() {
          this._buffer = ''
        }
        /**
         * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
         * Also checks r/w permissions.
         *
         * @returns step summary file path
         */
        filePath() {
          return __awaiter(this, void 0, void 0, function* () {
            if (this._filePath) {
              return this._filePath
            }
            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR]
            if (!pathFromEnv) {
              throw new Error(
                `Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`
              )
            }
            try {
              yield access(
                pathFromEnv,
                fs_1.constants.R_OK | fs_1.constants.W_OK
              )
            } catch (_a) {
              throw new Error(
                `Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`
              )
            }
            this._filePath = pathFromEnv
            return this._filePath
          })
        }
        /**
         * Wraps content in an HTML tag, adding any HTML attributes
         *
         * @param {string} tag HTML tag to wrap
         * @param {string | null} content content within the tag
         * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
         *
         * @returns {string} content wrapped in HTML element
         */
        wrap(tag, content, attrs = {}) {
          const htmlAttrs = Object.entries(attrs)
            .map(([key, value]) => ` ${key}="${value}"`)
            .join('')
          if (!content) {
            return `<${tag}${htmlAttrs}>`
          }
          return `<${tag}${htmlAttrs}>${content}</${tag}>`
        }
        /**
         * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
         *
         * @param {SummaryWriteOptions} [options] (optional) options for write operation
         *
         * @returns {Promise<Summary>} summary instance
         */
        write(options) {
          return __awaiter(this, void 0, void 0, function* () {
            const overwrite = !!(options === null || options === void 0
              ? void 0
              : options.overwrite)
            const filePath = yield this.filePath()
            const writeFunc = overwrite ? writeFile : appendFile
            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' })
            return this.emptyBuffer()
          })
        }
        /**
         * Clears the summary buffer and wipes the summary file
         *
         * @returns {Summary} summary instance
         */
        clear() {
          return __awaiter(this, void 0, void 0, function* () {
            return this.emptyBuffer().write({ overwrite: true })
          })
        }
        /**
         * Returns the current summary buffer as a string
         *
         * @returns {string} string of summary buffer
         */
        stringify() {
          return this._buffer
        }
        /**
         * If the summary buffer is empty
         *
         * @returns {boolen} true if the buffer is empty
         */
        isEmptyBuffer() {
          return this._buffer.length === 0
        }
        /**
         * Resets the summary buffer without writing to summary file
         *
         * @returns {Summary} summary instance
         */
        emptyBuffer() {
          this._buffer = ''
          return this
        }
        /**
         * Adds raw text to the summary buffer
         *
         * @param {string} text content to add
         * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
         *
         * @returns {Summary} summary instance
         */
        addRaw(text, addEOL = false) {
          this._buffer += text
          return addEOL ? this.addEOL() : this
        }
        /**
         * Adds the operating system-specific end-of-line marker to the buffer
         *
         * @returns {Summary} summary instance
         */
        addEOL() {
          return this.addRaw(os_1.EOL)
        }
        /**
         * Adds an HTML codeblock to the summary buffer
         *
         * @param {string} code content to render within fenced code block
         * @param {string} lang (optional) language to syntax highlight code
         *
         * @returns {Summary} summary instance
         */
        addCodeBlock(code, lang) {
          const attrs = Object.assign({}, lang && { lang })
          const element = this.wrap('pre', this.wrap('code', code), attrs)
          return this.addRaw(element).addEOL()
        }
        /**
         * Adds an HTML list to the summary buffer
         *
         * @param {string[]} items list of items to render
         * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
         *
         * @returns {Summary} summary instance
         */
        addList(items, ordered = false) {
          const tag = ordered ? 'ol' : 'ul'
          const listItems = items.map(item => this.wrap('li', item)).join('')
          const element = this.wrap(tag, listItems)
          return this.addRaw(element).addEOL()
        }
        /**
         * Adds an HTML table to the summary buffer
         *
         * @param {SummaryTableCell[]} rows table rows
         *
         * @returns {Summary} summary instance
         */
        addTable(rows) {
          const tableBody = rows
            .map(row => {
              const cells = row
                .map(cell => {
                  if (typeof cell === 'string') {
                    return this.wrap('td', cell)
                  }
                  const { header, data, colspan, rowspan } = cell
                  const tag = header ? 'th' : 'td'
                  const attrs = Object.assign(
                    Object.assign({}, colspan && { colspan }),
                    rowspan && { rowspan }
                  )
                  return this.wrap(tag, data, attrs)
                })
                .join('')
              return this.wrap('tr', cells)
            })
            .join('')
          const element = this.wrap('table', tableBody)
          return this.addRaw(element).addEOL()
        }
        /**
         * Adds a collapsable HTML details element to the summary buffer
         *
         * @param {string} label text for the closed state
         * @param {string} content collapsable content
         *
         * @returns {Summary} summary instance
         */
        addDetails(label, content) {
          const element = this.wrap(
            'details',
            this.wrap('summary', label) + content
          )
          return this.addRaw(element).addEOL()
        }
        /**
         * Adds an HTML image tag to the summary buffer
         *
         * @param {string} src path to the image you to embed
         * @param {string} alt text description of the image
         * @param {SummaryImageOptions} options (optional) addition image attributes
         *
         * @returns {Summary} summary instance
         */
        addImage(src, alt, options) {
          const { width, height } = options || {}
          const attrs = Object.assign(
            Object.assign({}, width && { width }),
            height && { height }
          )
          const element = this.wrap(
            'img',
            null,
            Object.assign({ src, alt }, attrs)
          )
          return this.addRaw(element).addEOL()
        }
        /**
         * Adds an HTML section heading element
         *
         * @param {string} text heading text
         * @param {number | string} [level=1] (optional) the heading level, default: 1
         *
         * @returns {Summary} summary instance
         */
        addHeading(text, level) {
          const tag = `h${level}`
          const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)
            ? tag
            : 'h1'
          const element = this.wrap(allowedTag, text)
          return this.addRaw(element).addEOL()
        }
        /**
         * Adds an HTML thematic break (<hr>) to the summary buffer
         *
         * @returns {Summary} summary instance
         */
        addSeparator() {
          const element = this.wrap('hr', null)
          return this.addRaw(element).addEOL()
        }
        /**
         * Adds an HTML line break (<br>) to the summary buffer
         *
         * @returns {Summary} summary instance
         */
        addBreak() {
          const element = this.wrap('br', null)
          return this.addRaw(element).addEOL()
        }
        /**
         * Adds an HTML blockquote to the summary buffer
         *
         * @param {string} text quote text
         * @param {string} cite (optional) citation url
         *
         * @returns {Summary} summary instance
         */
        addQuote(text, cite) {
          const attrs = Object.assign({}, cite && { cite })
          const element = this.wrap('blockquote', text, attrs)
          return this.addRaw(element).addEOL()
        }
        /**
         * Adds an HTML anchor tag to the summary buffer
         *
         * @param {string} text link text/content
         * @param {string} href hyperlink
         *
         * @returns {Summary} summary instance
         */
        addLink(text, href) {
          const element = this.wrap('a', text, { href })
          return this.addRaw(element).addEOL()
        }
      }
      const _summary = new Summary()
      /**
       * @deprecated use `core.summary`
       */
      exports.markdownSummary = _summary
      exports.summary = _summary
      //# sourceMappingURL=summary.js.map

      /***/
    },

    /***/ 5278: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      // We use any as a valid input type
      /* eslint-disable @typescript-eslint/no-explicit-any */
      Object.defineProperty(exports, '__esModule', { value: true })
      exports.toCommandProperties = exports.toCommandValue = void 0
      /**
       * Sanitizes an input into a string so it can be passed into issueCommand safely
       * @param input input to sanitize into a string
       */
      function toCommandValue(input) {
        if (input === null || input === undefined) {
          return ''
        } else if (typeof input === 'string' || input instanceof String) {
          return input
        }
        return JSON.stringify(input)
      }
      exports.toCommandValue = toCommandValue
      /**
       *
       * @param annotationProperties
       * @returns The command properties to send with the actual annotation command
       * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
       */
      function toCommandProperties(annotationProperties) {
        if (!Object.keys(annotationProperties).length) {
          return {}
        }
        return {
          title: annotationProperties.title,
          file: annotationProperties.file,
          line: annotationProperties.startLine,
          endLine: annotationProperties.endLine,
          col: annotationProperties.startColumn,
          endColumn: annotationProperties.endColumn,
        }
      }
      exports.toCommandProperties = toCommandProperties
      //# sourceMappingURL=utils.js.map

      /***/
    },

    /***/ 5526: /***/ function (__unused_webpack_module, exports) {
      'use strict'

      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value)
                })
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value))
              } catch (e) {
                reject(e)
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value))
              } catch (e) {
                reject(e)
              }
            }
            function step(result) {
              result.done
                ? resolve(result.value)
                : adopt(result.value).then(fulfilled, rejected)
            }
            step(
              (generator = generator.apply(thisArg, _arguments || [])).next()
            )
          })
        }
      Object.defineProperty(exports, '__esModule', { value: true })
      exports.PersonalAccessTokenCredentialHandler =
        exports.BearerCredentialHandler =
        exports.BasicCredentialHandler =
          void 0
      class BasicCredentialHandler {
        constructor(username, password) {
          this.username = username
          this.password = password
        }
        prepareRequest(options) {
          if (!options.headers) {
            throw Error('The request has no headers')
          }
          options.headers['Authorization'] = `Basic ${Buffer.from(
            `${this.username}:${this.password}`
          ).toString('base64')}`
        }
        // This handler cannot handle 401
        canHandleAuthentication() {
          return false
        }
        handleAuthentication() {
          return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented')
          })
        }
      }
      exports.BasicCredentialHandler = BasicCredentialHandler
      class BearerCredentialHandler {
        constructor(token) {
          this.token = token
        }
        // currently implements pre-authorization
        // TODO: support preAuth = false where it hooks on 401
        prepareRequest(options) {
          if (!options.headers) {
            throw Error('The request has no headers')
          }
          options.headers['Authorization'] = `Bearer ${this.token}`
        }
        // This handler cannot handle 401
        canHandleAuthentication() {
          return false
        }
        handleAuthentication() {
          return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented')
          })
        }
      }
      exports.BearerCredentialHandler = BearerCredentialHandler
      class PersonalAccessTokenCredentialHandler {
        constructor(token) {
          this.token = token
        }
        // currently implements pre-authorization
        // TODO: support preAuth = false where it hooks on 401
        prepareRequest(options) {
          if (!options.headers) {
            throw Error('The request has no headers')
          }
          options.headers['Authorization'] = `Basic ${Buffer.from(
            `PAT:${this.token}`
          ).toString('base64')}`
        }
        // This handler cannot handle 401
        canHandleAuthentication() {
          return false
        }
        handleAuthentication() {
          return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented')
          })
        }
      }
      exports.PersonalAccessTokenCredentialHandler =
        PersonalAccessTokenCredentialHandler
      //# sourceMappingURL=auth.js.map

      /***/
    },

    /***/ 6255: /***/ function (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) {
      'use strict'

      /* eslint-disable @typescript-eslint/no-explicit-any */
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k]
                },
              })
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k
              o[k2] = m[k]
            })
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, 'default', {
                enumerable: true,
                value: v,
              })
            }
          : function (o, v) {
              o['default'] = v
            })
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod
          var result = {}
          if (mod != null)
            for (var k in mod)
              if (k !== 'default' && Object.hasOwnProperty.call(mod, k))
                __createBinding(result, mod, k)
          __setModuleDefault(result, mod)
          return result
        }
      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value)
                })
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value))
              } catch (e) {
                reject(e)
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value))
              } catch (e) {
                reject(e)
              }
            }
            function step(result) {
              result.done
                ? resolve(result.value)
                : adopt(result.value).then(fulfilled, rejected)
            }
            step(
              (generator = generator.apply(thisArg, _arguments || [])).next()
            )
          })
        }
      Object.defineProperty(exports, '__esModule', { value: true })
      exports.HttpClient =
        exports.isHttps =
        exports.HttpClientResponse =
        exports.HttpClientError =
        exports.getProxyUrl =
        exports.MediaTypes =
        exports.Headers =
        exports.HttpCodes =
          void 0
      const http = __importStar(__nccwpck_require__(3685))
      const https = __importStar(__nccwpck_require__(5687))
      const pm = __importStar(__nccwpck_require__(9835))
      const tunnel = __importStar(__nccwpck_require__(4294))
      var HttpCodes
      ;(function (HttpCodes) {
        HttpCodes[(HttpCodes['OK'] = 200)] = 'OK'
        HttpCodes[(HttpCodes['MultipleChoices'] = 300)] = 'MultipleChoices'
        HttpCodes[(HttpCodes['MovedPermanently'] = 301)] = 'MovedPermanently'
        HttpCodes[(HttpCodes['ResourceMoved'] = 302)] = 'ResourceMoved'
        HttpCodes[(HttpCodes['SeeOther'] = 303)] = 'SeeOther'
        HttpCodes[(HttpCodes['NotModified'] = 304)] = 'NotModified'
        HttpCodes[(HttpCodes['UseProxy'] = 305)] = 'UseProxy'
        HttpCodes[(HttpCodes['SwitchProxy'] = 306)] = 'SwitchProxy'
        HttpCodes[(HttpCodes['TemporaryRedirect'] = 307)] = 'TemporaryRedirect'
        HttpCodes[(HttpCodes['PermanentRedirect'] = 308)] = 'PermanentRedirect'
        HttpCodes[(HttpCodes['BadRequest'] = 400)] = 'BadRequest'
        HttpCodes[(HttpCodes['Unauthorized'] = 401)] = 'Unauthorized'
        HttpCodes[(HttpCodes['PaymentRequired'] = 402)] = 'PaymentRequired'
        HttpCodes[(HttpCodes['Forbidden'] = 403)] = 'Forbidden'
        HttpCodes[(HttpCodes['NotFound'] = 404)] = 'NotFound'
        HttpCodes[(HttpCodes['MethodNotAllowed'] = 405)] = 'MethodNotAllowed'
        HttpCodes[(HttpCodes['NotAcceptable'] = 406)] = 'NotAcceptable'
        HttpCodes[(HttpCodes['ProxyAuthenticationRequired'] = 407)] =
          'ProxyAuthenticationRequired'
        HttpCodes[(HttpCodes['RequestTimeout'] = 408)] = 'RequestTimeout'
        HttpCodes[(HttpCodes['Conflict'] = 409)] = 'Conflict'
        HttpCodes[(HttpCodes['Gone'] = 410)] = 'Gone'
        HttpCodes[(HttpCodes['TooManyRequests'] = 429)] = 'TooManyRequests'
        HttpCodes[(HttpCodes['InternalServerError'] = 500)] =
          'InternalServerError'
        HttpCodes[(HttpCodes['NotImplemented'] = 501)] = 'NotImplemented'
        HttpCodes[(HttpCodes['BadGateway'] = 502)] = 'BadGateway'
        HttpCodes[(HttpCodes['ServiceUnavailable'] = 503)] =
          'ServiceUnavailable'
        HttpCodes[(HttpCodes['GatewayTimeout'] = 504)] = 'GatewayTimeout'
      })((HttpCodes = exports.HttpCodes || (exports.HttpCodes = {})))
      var Headers
      ;(function (Headers) {
        Headers['Accept'] = 'accept'
        Headers['ContentType'] = 'content-type'
      })((Headers = exports.Headers || (exports.Headers = {})))
      var MediaTypes
      ;(function (MediaTypes) {
        MediaTypes['ApplicationJson'] = 'application/json'
      })((MediaTypes = exports.MediaTypes || (exports.MediaTypes = {})))
      /**
       * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
       * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
       */
      function getProxyUrl(serverUrl) {
        const proxyUrl = pm.getProxyUrl(new URL(serverUrl))
        return proxyUrl ? proxyUrl.href : ''
      }
      exports.getProxyUrl = getProxyUrl
      const HttpRedirectCodes = [
        HttpCodes.MovedPermanently,
        HttpCodes.ResourceMoved,
        HttpCodes.SeeOther,
        HttpCodes.TemporaryRedirect,
        HttpCodes.PermanentRedirect,
      ]
      const HttpResponseRetryCodes = [
        HttpCodes.BadGateway,
        HttpCodes.ServiceUnavailable,
        HttpCodes.GatewayTimeout,
      ]
      const RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD']
      const ExponentialBackoffCeiling = 10
      const ExponentialBackoffTimeSlice = 5
      class HttpClientError extends Error {
        constructor(message, statusCode) {
          super(message)
          this.name = 'HttpClientError'
          this.statusCode = statusCode
          Object.setPrototypeOf(this, HttpClientError.prototype)
        }
      }
      exports.HttpClientError = HttpClientError
      class HttpClientResponse {
        constructor(message) {
          this.message = message
        }
        readBody() {
          return __awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve =>
              __awaiter(this, void 0, void 0, function* () {
                let output = Buffer.alloc(0)
                this.message.on('data', chunk => {
                  output = Buffer.concat([output, chunk])
                })
                this.message.on('end', () => {
                  resolve(output.toString())
                })
              })
            )
          })
        }
      }
      exports.HttpClientResponse = HttpClientResponse
      function isHttps(requestUrl) {
        const parsedUrl = new URL(requestUrl)
        return parsedUrl.protocol === 'https:'
      }
      exports.isHttps = isHttps
      class HttpClient {
        constructor(userAgent, handlers, requestOptions) {
          this._ignoreSslError = false
          this._allowRedirects = true
          this._allowRedirectDowngrade = false
          this._maxRedirects = 50
          this._allowRetries = false
          this._maxRetries = 1
          this._keepAlive = false
          this._disposed = false
          this.userAgent = userAgent
          this.handlers = handlers || []
          this.requestOptions = requestOptions
          if (requestOptions) {
            if (requestOptions.ignoreSslError != null) {
              this._ignoreSslError = requestOptions.ignoreSslError
            }
            this._socketTimeout = requestOptions.socketTimeout
            if (requestOptions.allowRedirects != null) {
              this._allowRedirects = requestOptions.allowRedirects
            }
            if (requestOptions.allowRedirectDowngrade != null) {
              this._allowRedirectDowngrade =
                requestOptions.allowRedirectDowngrade
            }
            if (requestOptions.maxRedirects != null) {
              this._maxRedirects = Math.max(requestOptions.maxRedirects, 0)
            }
            if (requestOptions.keepAlive != null) {
              this._keepAlive = requestOptions.keepAlive
            }
            if (requestOptions.allowRetries != null) {
              this._allowRetries = requestOptions.allowRetries
            }
            if (requestOptions.maxRetries != null) {
              this._maxRetries = requestOptions.maxRetries
            }
          }
        }
        options(requestUrl, additionalHeaders) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.request(
              'OPTIONS',
              requestUrl,
              null,
              additionalHeaders || {}
            )
          })
        }
        get(requestUrl, additionalHeaders) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.request(
              'GET',
              requestUrl,
              null,
              additionalHeaders || {}
            )
          })
        }
        del(requestUrl, additionalHeaders) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.request(
              'DELETE',
              requestUrl,
              null,
              additionalHeaders || {}
            )
          })
        }
        post(requestUrl, data, additionalHeaders) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.request(
              'POST',
              requestUrl,
              data,
              additionalHeaders || {}
            )
          })
        }
        patch(requestUrl, data, additionalHeaders) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.request(
              'PATCH',
              requestUrl,
              data,
              additionalHeaders || {}
            )
          })
        }
        put(requestUrl, data, additionalHeaders) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.request(
              'PUT',
              requestUrl,
              data,
              additionalHeaders || {}
            )
          })
        }
        head(requestUrl, additionalHeaders) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.request(
              'HEAD',
              requestUrl,
              null,
              additionalHeaders || {}
            )
          })
        }
        sendStream(verb, requestUrl, stream, additionalHeaders) {
          return __awaiter(this, void 0, void 0, function* () {
            return this.request(verb, requestUrl, stream, additionalHeaders)
          })
        }
        /**
         * Gets a typed object from an endpoint
         * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
         */
        getJson(requestUrl, additionalHeaders = {}) {
          return __awaiter(this, void 0, void 0, function* () {
            additionalHeaders[Headers.Accept] =
              this._getExistingOrDefaultHeader(
                additionalHeaders,
                Headers.Accept,
                MediaTypes.ApplicationJson
              )
            const res = yield this.get(requestUrl, additionalHeaders)
            return this._processResponse(res, this.requestOptions)
          })
        }
        postJson(requestUrl, obj, additionalHeaders = {}) {
          return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2)
            additionalHeaders[Headers.Accept] =
              this._getExistingOrDefaultHeader(
                additionalHeaders,
                Headers.Accept,
                MediaTypes.ApplicationJson
              )
            additionalHeaders[Headers.ContentType] =
              this._getExistingOrDefaultHeader(
                additionalHeaders,
                Headers.ContentType,
                MediaTypes.ApplicationJson
              )
            const res = yield this.post(requestUrl, data, additionalHeaders)
            return this._processResponse(res, this.requestOptions)
          })
        }
        putJson(requestUrl, obj, additionalHeaders = {}) {
          return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2)
            additionalHeaders[Headers.Accept] =
              this._getExistingOrDefaultHeader(
                additionalHeaders,
                Headers.Accept,
                MediaTypes.ApplicationJson
              )
            additionalHeaders[Headers.ContentType] =
              this._getExistingOrDefaultHeader(
                additionalHeaders,
                Headers.ContentType,
                MediaTypes.ApplicationJson
              )
            const res = yield this.put(requestUrl, data, additionalHeaders)
            return this._processResponse(res, this.requestOptions)
          })
        }
        patchJson(requestUrl, obj, additionalHeaders = {}) {
          return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2)
            additionalHeaders[Headers.Accept] =
              this._getExistingOrDefaultHeader(
                additionalHeaders,
                Headers.Accept,
                MediaTypes.ApplicationJson
              )
            additionalHeaders[Headers.ContentType] =
              this._getExistingOrDefaultHeader(
                additionalHeaders,
                Headers.ContentType,
                MediaTypes.ApplicationJson
              )
            const res = yield this.patch(requestUrl, data, additionalHeaders)
            return this._processResponse(res, this.requestOptions)
          })
        }
        /**
         * Makes a raw http request.
         * All other methods such as get, post, patch, and request ultimately call this.
         * Prefer get, del, post and patch
         */
        request(verb, requestUrl, data, headers) {
          return __awaiter(this, void 0, void 0, function* () {
            if (this._disposed) {
              throw new Error('Client has already been disposed.')
            }
            const parsedUrl = new URL(requestUrl)
            let info = this._prepareRequest(verb, parsedUrl, headers)
            // Only perform retries on reads since writes may not be idempotent.
            const maxTries =
              this._allowRetries && RetryableHttpVerbs.includes(verb)
                ? this._maxRetries + 1
                : 1
            let numTries = 0
            let response
            do {
              response = yield this.requestRaw(info, data)
              // Check if it's an authentication challenge
              if (
                response &&
                response.message &&
                response.message.statusCode === HttpCodes.Unauthorized
              ) {
                let authenticationHandler
                for (const handler of this.handlers) {
                  if (handler.canHandleAuthentication(response)) {
                    authenticationHandler = handler
                    break
                  }
                }
                if (authenticationHandler) {
                  return authenticationHandler.handleAuthentication(
                    this,
                    info,
                    data
                  )
                } else {
                  // We have received an unauthorized response but have no handlers to handle it.
                  // Let the response return to the caller.
                  return response
                }
              }
              let redirectsRemaining = this._maxRedirects
              while (
                response.message.statusCode &&
                HttpRedirectCodes.includes(response.message.statusCode) &&
                this._allowRedirects &&
                redirectsRemaining > 0
              ) {
                const redirectUrl = response.message.headers['location']
                if (!redirectUrl) {
                  // if there's no location to redirect to, we won't
                  break
                }
                const parsedRedirectUrl = new URL(redirectUrl)
                if (
                  parsedUrl.protocol === 'https:' &&
                  parsedUrl.protocol !== parsedRedirectUrl.protocol &&
                  !this._allowRedirectDowngrade
                ) {
                  throw new Error(
                    'Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.'
                  )
                }
                // we need to finish reading the response before reassigning response
                // which will leak the open socket.
                yield response.readBody()
                // strip authorization header if redirected to a different hostname
                if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                  for (const header in headers) {
                    // header names are case insensitive
                    if (header.toLowerCase() === 'authorization') {
                      delete headers[header]
                    }
                  }
                }
                // let's make the request with the new redirectUrl
                info = this._prepareRequest(verb, parsedRedirectUrl, headers)
                response = yield this.requestRaw(info, data)
                redirectsRemaining--
              }
              if (
                !response.message.statusCode ||
                !HttpResponseRetryCodes.includes(response.message.statusCode)
              ) {
                // If not a retry code, return immediately instead of retrying
                return response
              }
              numTries += 1
              if (numTries < maxTries) {
                yield response.readBody()
                yield this._performExponentialBackoff(numTries)
              }
            } while (numTries < maxTries)
            return response
          })
        }
        /**
         * Needs to be called if keepAlive is set to true in request options.
         */
        dispose() {
          if (this._agent) {
            this._agent.destroy()
          }
          this._disposed = true
        }
        /**
         * Raw request.
         * @param info
         * @param data
         */
        requestRaw(info, data) {
          return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
              function callbackForResult(err, res) {
                if (err) {
                  reject(err)
                } else if (!res) {
                  // If `err` is not passed, then `res` must be passed.
                  reject(new Error('Unknown error'))
                } else {
                  resolve(res)
                }
              }
              this.requestRawWithCallback(info, data, callbackForResult)
            })
          })
        }
        /**
         * Raw request with callback.
         * @param info
         * @param data
         * @param onResult
         */
        requestRawWithCallback(info, data, onResult) {
          if (typeof data === 'string') {
            if (!info.options.headers) {
              info.options.headers = {}
            }
            info.options.headers['Content-Length'] = Buffer.byteLength(
              data,
              'utf8'
            )
          }
          let callbackCalled = false
          function handleResult(err, res) {
            if (!callbackCalled) {
              callbackCalled = true
              onResult(err, res)
            }
          }
          const req = info.httpModule.request(info.options, msg => {
            const res = new HttpClientResponse(msg)
            handleResult(undefined, res)
          })
          let socket
          req.on('socket', sock => {
            socket = sock
          })
          // If we ever get disconnected, we want the socket to timeout eventually
          req.setTimeout(this._socketTimeout || 3 * 60000, () => {
            if (socket) {
              socket.end()
            }
            handleResult(new Error(`Request timeout: ${info.options.path}`))
          })
          req.on('error', function (err) {
            // err has statusCode property
            // res should have headers
            handleResult(err)
          })
          if (data && typeof data === 'string') {
            req.write(data, 'utf8')
          }
          if (data && typeof data !== 'string') {
            data.on('close', function () {
              req.end()
            })
            data.pipe(req)
          } else {
            req.end()
          }
        }
        /**
         * Gets an http agent. This function is useful when you need an http agent that handles
         * routing through a proxy server - depending upon the url and proxy environment variables.
         * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
         */
        getAgent(serverUrl) {
          const parsedUrl = new URL(serverUrl)
          return this._getAgent(parsedUrl)
        }
        _prepareRequest(method, requestUrl, headers) {
          const info = {}
          info.parsedUrl = requestUrl
          const usingSsl = info.parsedUrl.protocol === 'https:'
          info.httpModule = usingSsl ? https : http
          const defaultPort = usingSsl ? 443 : 80
          info.options = {}
          info.options.host = info.parsedUrl.hostname
          info.options.port = info.parsedUrl.port
            ? parseInt(info.parsedUrl.port)
            : defaultPort
          info.options.path =
            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '')
          info.options.method = method
          info.options.headers = this._mergeHeaders(headers)
          if (this.userAgent != null) {
            info.options.headers['user-agent'] = this.userAgent
          }
          info.options.agent = this._getAgent(info.parsedUrl)
          // gives handlers an opportunity to participate
          if (this.handlers) {
            for (const handler of this.handlers) {
              handler.prepareRequest(info.options)
            }
          }
          return info
        }
        _mergeHeaders(headers) {
          if (this.requestOptions && this.requestOptions.headers) {
            return Object.assign(
              {},
              lowercaseKeys(this.requestOptions.headers),
              lowercaseKeys(headers || {})
            )
          }
          return lowercaseKeys(headers || {})
        }
        _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
          let clientHeader
          if (this.requestOptions && this.requestOptions.headers) {
            clientHeader = lowercaseKeys(this.requestOptions.headers)[header]
          }
          return additionalHeaders[header] || clientHeader || _default
        }
        _getAgent(parsedUrl) {
          let agent
          const proxyUrl = pm.getProxyUrl(parsedUrl)
          const useProxy = proxyUrl && proxyUrl.hostname
          if (this._keepAlive && useProxy) {
            agent = this._proxyAgent
          }
          if (this._keepAlive && !useProxy) {
            agent = this._agent
          }
          // if agent is already assigned use that agent.
          if (agent) {
            return agent
          }
          const usingSsl = parsedUrl.protocol === 'https:'
          let maxSockets = 100
          if (this.requestOptions) {
            maxSockets =
              this.requestOptions.maxSockets || http.globalAgent.maxSockets
          }
          // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.
          if (proxyUrl && proxyUrl.hostname) {
            const agentOptions = {
              maxSockets,
              keepAlive: this._keepAlive,
              proxy: Object.assign(
                Object.assign(
                  {},
                  (proxyUrl.username || proxyUrl.password) && {
                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`,
                  }
                ),
                { host: proxyUrl.hostname, port: proxyUrl.port }
              ),
            }
            let tunnelAgent
            const overHttps = proxyUrl.protocol === 'https:'
            if (usingSsl) {
              tunnelAgent = overHttps
                ? tunnel.httpsOverHttps
                : tunnel.httpsOverHttp
            } else {
              tunnelAgent = overHttps
                ? tunnel.httpOverHttps
                : tunnel.httpOverHttp
            }
            agent = tunnelAgent(agentOptions)
            this._proxyAgent = agent
          }
          // if reusing agent across request and tunneling agent isn't assigned create a new agent
          if (this._keepAlive && !agent) {
            const options = { keepAlive: this._keepAlive, maxSockets }
            agent = usingSsl
              ? new https.Agent(options)
              : new http.Agent(options)
            this._agent = agent
          }
          // if not using private agent and tunnel agent isn't setup then use global agent
          if (!agent) {
            agent = usingSsl ? https.globalAgent : http.globalAgent
          }
          if (usingSsl && this._ignoreSslError) {
            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
            // we have to cast it to any and change it directly
            agent.options = Object.assign(agent.options || {}, {
              rejectUnauthorized: false,
            })
          }
          return agent
        }
        _performExponentialBackoff(retryNumber) {
          return __awaiter(this, void 0, void 0, function* () {
            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber)
            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber)
            return new Promise(resolve => setTimeout(() => resolve(), ms))
          })
        }
        _processResponse(res, options) {
          return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) =>
              __awaiter(this, void 0, void 0, function* () {
                const statusCode = res.message.statusCode || 0
                const response = {
                  statusCode,
                  result: null,
                  headers: {},
                }
                // not found leads to null obj returned
                if (statusCode === HttpCodes.NotFound) {
                  resolve(response)
                }
                // get the result from the body
                function dateTimeDeserializer(key, value) {
                  if (typeof value === 'string') {
                    const a = new Date(value)
                    if (!isNaN(a.valueOf())) {
                      return a
                    }
                  }
                  return value
                }
                let obj
                let contents
                try {
                  contents = yield res.readBody()
                  if (contents && contents.length > 0) {
                    if (options && options.deserializeDates) {
                      obj = JSON.parse(contents, dateTimeDeserializer)
                    } else {
                      obj = JSON.parse(contents)
                    }
                    response.result = obj
                  }
                  response.headers = res.message.headers
                } catch (err) {
                  // Invalid resource (contents not json);  leaving result obj null
                }
                // note that 3xx redirects are handled by the http layer.
                if (statusCode > 299) {
                  let msg
                  // if exception/error in body, attempt to get better error
                  if (obj && obj.message) {
                    msg = obj.message
                  } else if (contents && contents.length > 0) {
                    // it may be the case that the exception is in the body message as string
                    msg = contents
                  } else {
                    msg = `Failed request: (${statusCode})`
                  }
                  const err = new HttpClientError(msg, statusCode)
                  err.result = response.result
                  reject(err)
                } else {
                  resolve(response)
                }
              })
            )
          })
        }
      }
      exports.HttpClient = HttpClient
      const lowercaseKeys = obj =>
        Object.keys(obj).reduce(
          (c, k) => ((c[k.toLowerCase()] = obj[k]), c),
          {}
        )
      //# sourceMappingURL=index.js.map

      /***/
    },

    /***/ 9835: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.checkBypass = exports.getProxyUrl = void 0
      function getProxyUrl(reqUrl) {
        const usingSsl = reqUrl.protocol === 'https:'
        if (checkBypass(reqUrl)) {
          return undefined
        }
        const proxyVar = (() => {
          if (usingSsl) {
            return process.env['https_proxy'] || process.env['HTTPS_PROXY']
          } else {
            return process.env['http_proxy'] || process.env['HTTP_PROXY']
          }
        })()
        if (proxyVar) {
          return new URL(proxyVar)
        } else {
          return undefined
        }
      }
      exports.getProxyUrl = getProxyUrl
      function checkBypass(reqUrl) {
        if (!reqUrl.hostname) {
          return false
        }
        const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || ''
        if (!noProxy) {
          return false
        }
        // Determine the request port
        let reqPort
        if (reqUrl.port) {
          reqPort = Number(reqUrl.port)
        } else if (reqUrl.protocol === 'http:') {
          reqPort = 80
        } else if (reqUrl.protocol === 'https:') {
          reqPort = 443
        }
        // Format the request hostname and hostname with port
        const upperReqHosts = [reqUrl.hostname.toUpperCase()]
        if (typeof reqPort === 'number') {
          upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`)
        }
        // Compare request host against noproxy
        for (const upperNoProxyItem of noProxy
          .split(',')
          .map(x => x.trim().toUpperCase())
          .filter(x => x)) {
          if (upperReqHosts.some(x => x === upperNoProxyItem)) {
            return true
          }
        }
        return false
      }
      exports.checkBypass = checkBypass
      //# sourceMappingURL=proxy.js.map

      /***/
    },

    /***/ 8618: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })

      var semver = __nccwpck_require__(7183)
      var errors = __nccwpck_require__(6740)
      var getDependentsGraph = __nccwpck_require__(935)

      function _interopDefault(e) {
        return e && e.__esModule ? e : { default: e }
      }

      var semver__default = /*#__PURE__*/ _interopDefault(semver)

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true,
          })
        } else {
          obj[key] = value
        }

        return obj
      }

      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object)

        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object)
          if (enumerableOnly)
            symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable
            })
          keys.push.apply(keys, symbols)
        }

        return keys
      }

      function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {}

          if (i % 2) {
            ownKeys(Object(source), true).forEach(function (key) {
              _defineProperty(target, key, source[key])
            })
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(
              target,
              Object.getOwnPropertyDescriptors(source)
            )
          } else {
            ownKeys(Object(source)).forEach(function (key) {
              Object.defineProperty(
                target,
                key,
                Object.getOwnPropertyDescriptor(source, key)
              )
            })
          }
        }

        return target
      }

      function incrementVersion(release, preInfo) {
        if (release.type === 'none') {
          return release.oldVersion
        }

        let version = semver.inc(release.oldVersion, release.type)

        if (preInfo !== undefined && preInfo.state.mode !== 'exit') {
          let preVersion = preInfo.preVersions.get(release.name)

          if (preVersion === undefined) {
            throw new errors.InternalError(
              `preVersion for ${release.name} does not exist when preState is defined`
            )
          } // why are we adding this ourselves rather than passing 'pre' + versionType to semver.inc?
          // because semver.inc with prereleases is confusing and this seems easier

          version += `-${preInfo.state.tag}.${preVersion}`
        }

        return version
      }

      /*
  WARNING:
  Important note for understanding how this package works:

  We are doing some kind of wacky things with manipulating the objects within the
  releases array, despite the fact that this was passed to us as an argument. We are
  aware that this is generally bad practice, but have decided to to this here as
  we control the entire flow of releases.

  We could solve this by inlining this function, or by returning a deep-cloned then
  modified array, but we decided both of those are worse than this solution.
*/

      function determineDependents({
        releases,
        packagesByName,
        dependencyGraph,
        preInfo,
        config,
      }) {
        let updated = false // NOTE this is intended to be called recursively

        let pkgsToSearch = [...releases.values()]

        while (pkgsToSearch.length > 0) {
          // nextRelease is our dependency, think of it as "avatar"
          const nextRelease = pkgsToSearch.shift()
          if (!nextRelease) continue // pkgDependents will be a list of packages that depend on nextRelease ie. ['avatar-group', 'comment']

          const pkgDependents = dependencyGraph.get(nextRelease.name)

          if (!pkgDependents) {
            throw new Error(
              `Error in determining dependents - could not find package in repository: ${nextRelease.name}`
            )
          }

          pkgDependents
            .map(dependent => {
              let type
              const dependentPackage = packagesByName.get(dependent)
              if (!dependentPackage)
                throw new Error('Dependency map is incorrect')

              if (config.ignore.includes(dependent)) {
                type = 'none'
              } else {
                const dependencyVersionRanges = getDependencyVersionRanges(
                  dependentPackage.packageJson,
                  nextRelease
                )

                for (const {
                  depType,
                  versionRange,
                } of dependencyVersionRanges) {
                  if (nextRelease.type === 'none') {
                    continue
                  } else if (
                    shouldBumpMajor({
                      dependent,
                      depType,
                      versionRange,
                      releases,
                      nextRelease,
                      preInfo,
                      onlyUpdatePeerDependentsWhenOutOfRange:
                        config.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH
                          .onlyUpdatePeerDependentsWhenOutOfRange,
                    })
                  ) {
                    type = 'major'
                  } else if (
                    (!releases.has(dependent) ||
                      releases.get(dependent).type === 'none') &&
                    (config.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH
                      .updateInternalDependents === 'always' ||
                      !semver__default['default'].satisfies(
                        incrementVersion(nextRelease, preInfo),
                        versionRange
                      ))
                  ) {
                    switch (depType) {
                      case 'dependencies':
                      case 'optionalDependencies':
                      case 'peerDependencies':
                        if (type !== 'major' && type !== 'minor') {
                          type = 'patch'
                        }

                        break

                      case 'devDependencies': {
                        // We don't need a version bump if the package is only in the devDependencies of the dependent package
                        if (
                          type !== 'major' &&
                          type !== 'minor' &&
                          type !== 'patch'
                        ) {
                          type = 'none'
                        }
                      }
                    }
                  }
                }
              }

              if (
                releases.has(dependent) &&
                releases.get(dependent).type === type
              ) {
                type = undefined
              }

              return {
                name: dependent,
                type,
                pkgJSON: dependentPackage.packageJson,
              }
            })
            .filter(dependentItem => !!dependentItem.type)
            .forEach(({ name, type, pkgJSON }) => {
              // At this point, we know if we are making a change
              updated = true
              const existing = releases.get(name) // For things that are being given a major bump, we check if we have already
              // added them here. If we have, we update the existing item instead of pushing it on to search.
              // It is safe to not add it to pkgsToSearch because it should have already been searched at the
              // largest possible bump type.

              if (existing && type === 'major' && existing.type !== 'major') {
                existing.type = 'major'
                pkgsToSearch.push(existing)
              } else {
                let newDependent = {
                  name,
                  type,
                  oldVersion: pkgJSON.version,
                  changesets: [],
                }
                pkgsToSearch.push(newDependent)
                releases.set(name, newDependent)
              }
            })
        }

        return updated
      }
      /*
  Returns an array of objects in the shape { depType: DependencyType, versionRange: string }
  The array can contain more than one elements in case a dependency appears in multiple
  dependency lists. For example, a package that is both a peerDepenency and a devDependency.
*/

      function getDependencyVersionRanges(dependentPkgJSON, dependencyRelease) {
        const DEPENDENCY_TYPES = [
          'dependencies',
          'devDependencies',
          'peerDependencies',
          'optionalDependencies',
        ]
        const dependencyVersionRanges = []

        for (const type of DEPENDENCY_TYPES) {
          var _dependentPkgJSON$typ

          const versionRange =
            (_dependentPkgJSON$typ = dependentPkgJSON[type]) === null ||
            _dependentPkgJSON$typ === void 0
              ? void 0
              : _dependentPkgJSON$typ[dependencyRelease.name]
          if (!versionRange) continue

          if (versionRange.startsWith('workspace:')) {
            dependencyVersionRanges.push({
              depType: type,
              // intentionally keep other workspace ranges untouched
              versionRange:
                // this has to be fixed but this should only be done when adding appropriate tests
                versionRange === 'workspace:*' // workspace:* actually means the current exact version, and not a wildcard similar to a reguler * range
                  ? dependencyRelease.oldVersion
                  : versionRange.replace(/^workspace:/, ''),
            })
          } else {
            dependencyVersionRanges.push({
              depType: type,
              versionRange,
            })
          }
        }

        return dependencyVersionRanges
      }

      function shouldBumpMajor({
        dependent,
        depType,
        versionRange,
        releases,
        nextRelease,
        preInfo,
        onlyUpdatePeerDependentsWhenOutOfRange,
      }) {
        // we check if it is a peerDependency because if it is, our dependent bump type might need to be major.
        return (
          depType === 'peerDependencies' &&
          nextRelease.type !== 'none' &&
          nextRelease.type !== 'patch' && // 1. If onlyUpdatePeerDependentsWhenOutOfRange set to true, bump major if the version is leaving the range.
          // 2. If onlyUpdatePeerDependentsWhenOutOfRange set to false, bump major regardless whether or not the version is leaving the range.
          (!onlyUpdatePeerDependentsWhenOutOfRange ||
            !semver__default['default'].satisfies(
              incrementVersion(nextRelease, preInfo),
              versionRange
            )) && // bump major only if the dependent doesn't already has a major release.
          (!releases.has(dependent) ||
            (releases.has(dependent) &&
              releases.get(dependent).type !== 'major'))
        )
      }

      // This function takes in changesets and returns one release per
      // package listed in the changesets
      function flattenReleases(changesets, packagesByName, ignoredPackages) {
        let releases = new Map()
        changesets.forEach(changeset => {
          changeset.releases // Filter out ignored packages because they should not trigger a release
            // If their dependencies need updates, they will be added to releases by `determineDependents()` with release type `none`
            .filter(({ name }) => !ignoredPackages.includes(name))
            .forEach(({ name, type }) => {
              let release = releases.get(name)
              let pkg = packagesByName.get(name)

              if (!pkg) {
                throw new Error(
                  `"${changeset.id}" changeset mentions a release for a package "${name}" but such a package could not be found.`
                )
              }

              if (!release) {
                release = {
                  name,
                  type,
                  oldVersion: pkg.packageJson.version,
                  changesets: [changeset.id],
                }
              } else {
                if (
                  type === 'major' ||
                  ((release.type === 'patch' || release.type === 'none') &&
                    (type === 'minor' || type === 'patch'))
                ) {
                  release.type = type
                } // Check whether the bumpType will change
                // If the bumpType has changed recalc newVersion
                // push new changeset to releases

                release.changesets.push(changeset.id)
              }

              releases.set(name, release)
            })
        })
        return releases
      }

      function getHighestReleaseType(releases) {
        if (releases.length === 0) {
          throw new Error(
            `Large internal Changesets error when calculating highest release type in the set of releases. Please contact the maintainers`
          )
        }

        let highestReleaseType = 'none'

        for (let release of releases) {
          switch (release.type) {
            case 'major':
              return 'major'

            case 'minor':
              highestReleaseType = 'minor'
              break

            case 'patch':
              if (highestReleaseType === 'none') {
                highestReleaseType = 'patch'
              }

              break
          }
        }

        return highestReleaseType
      }
      function getCurrentHighestVersion(packageGroup, packagesByName) {
        let highestVersion

        for (let pkgName of packageGroup) {
          let pkg = packagesByName.get(pkgName)

          if (!pkg) {
            console.error(
              `FATAL ERROR IN CHANGESETS! We were unable to version for package group: ${pkgName} in package group: ${packageGroup.toString()}`
            )
            throw new Error(`fatal: could not resolve linked packages`)
          }

          if (
            highestVersion === undefined ||
            semver__default['default'].gt(
              pkg.packageJson.version,
              highestVersion
            )
          ) {
            highestVersion = pkg.packageJson.version
          }
        }

        return highestVersion
      }

      function matchFixedConstraint(releases, packagesByName, config) {
        let updated = false

        for (let fixedPackages of config.fixed) {
          let releasingFixedPackages = [...releases.values()].filter(
            release =>
              fixedPackages.includes(release.name) && release.type !== 'none'
          )
          if (releasingFixedPackages.length === 0) continue
          let highestReleaseType = getHighestReleaseType(releasingFixedPackages)
          let highestVersion = getCurrentHighestVersion(
            fixedPackages,
            packagesByName
          ) // Finally, we update the packages so all of them are on the highest version

          for (let pkgName of fixedPackages) {
            if (config.ignore.includes(pkgName)) {
              continue
            }

            let release = releases.get(pkgName)

            if (!release) {
              updated = true
              releases.set(pkgName, {
                name: pkgName,
                type: highestReleaseType,
                oldVersion: highestVersion,
                changesets: [],
              })
              continue
            }

            if (release.type !== highestReleaseType) {
              updated = true
              release.type = highestReleaseType
            }

            if (release.oldVersion !== highestVersion) {
              updated = true
              release.oldVersion = highestVersion
            }
          }
        }

        return updated
      }

      /*
  WARNING:
  Important note for understanding how this package works:

  We are doing some kind of wacky things with manipulating the objects within the
  releases array, despite the fact that this was passed to us as an argument. We are
  aware that this is generally bad practice, but have decided to to this here as
  we control the entire flow of releases.

  We could solve this by inlining this function, or by returning a deep-cloned then
  modified array, but we decided both of those are worse than this solution.
*/

      function applyLinks(releases, packagesByName, linked) {
        let updated = false // We do this for each set of linked packages

        for (let linkedPackages of linked) {
          // First we filter down to all the relevant releases for one set of linked packages
          let releasingLinkedPackages = [...releases.values()].filter(
            release =>
              linkedPackages.includes(release.name) && release.type !== 'none'
          ) // If we proceed any further we do extra work with calculating highestVersion for things that might
          // not need one, as they only have workspace based packages

          if (releasingLinkedPackages.length === 0) continue
          let highestReleaseType = getHighestReleaseType(
            releasingLinkedPackages
          )
          let highestVersion = getCurrentHighestVersion(
            linkedPackages,
            packagesByName
          ) // Finally, we update the packages so all of them are on the highest version

          for (let linkedPackage of releasingLinkedPackages) {
            if (linkedPackage.type !== highestReleaseType) {
              updated = true
              linkedPackage.type = highestReleaseType
            }

            if (linkedPackage.oldVersion !== highestVersion) {
              updated = true
              linkedPackage.oldVersion = highestVersion
            }
          }
        }

        return updated
      }

      function getPreVersion(version) {
        let parsed = semver.parse(version)
        let preVersion =
          parsed.prerelease[1] === undefined ? -1 : parsed.prerelease[1]

        if (typeof preVersion !== 'number') {
          throw new errors.InternalError('preVersion is not a number')
        }

        preVersion++
        return preVersion
      }

      function getSnapshotSuffix(template, snapshotParameters) {
        let snapshotRefDate = new Date()
        const placeholderValues = {
          commit: snapshotParameters.commit,
          tag: snapshotParameters.tag,
          timestamp: snapshotRefDate.getTime().toString(),
          datetime: snapshotRefDate
            .toISOString()
            .replace(/\.\d{3}Z$/, '')
            .replace(/[^\d]/g, ''),
        } // We need a special handling because we need to handle a case where `--snapshot` is used without any template,
        // and the resulting version needs to be composed without a tag.

        if (!template) {
          return [placeholderValues.tag, placeholderValues.datetime]
            .filter(Boolean)
            .join('-')
        }

        const placeholders = Object.keys(placeholderValues)

        if (
          !template.includes(`{tag}`) &&
          placeholderValues.tag !== undefined
        ) {
          throw new Error(
            `Failed to compose snapshot version: "{tag}" placeholder is missing, but the snapshot parameter is defined (value: '${placeholderValues.tag}')`
          )
        }

        return placeholders.reduce((prev, key) => {
          return prev.replace(new RegExp(`\\{${key}\\}`, 'g'), () => {
            const value = placeholderValues[key]

            if (value === undefined) {
              throw new Error(
                `Failed to compose snapshot version: "{${key}}" placeholder is used without having a value defined!`
              )
            }

            return value
          })
        }, template)
      }

      function getSnapshotVersion(
        release,
        preInfo,
        useCalculatedVersion,
        snapshotSuffix
      ) {
        if (release.type === 'none') {
          return release.oldVersion
        }
        /**
         * Using version as 0.0.0 so that it does not hinder with other version release
         * For example;
         * if user has a regular pre-release at 1.0.0-beta.0 and then you had a snapshot pre-release at 1.0.0-canary-git-hash
         * and a consumer is using the range ^1.0.0-beta, most people would expect that range to resolve to 1.0.0-beta.0
         * but it'll actually resolve to 1.0.0-canary-hash. Using 0.0.0 solves this problem because it won't conflict with other versions.
         *
         * You can set `snapshot.useCalculatedVersion` flag to true to use calculated versions if you don't care about the above problem.
         */

        const baseVersion = useCalculatedVersion
          ? incrementVersion(release, preInfo)
          : `0.0.0`
        return `${baseVersion}-${snapshotSuffix}`
      }

      function getNewVersion(release, preInfo) {
        if (release.type === 'none') {
          return release.oldVersion
        }

        return incrementVersion(release, preInfo)
      }

      function assembleReleasePlan(
        changesets,
        packages,
        config, // intentionally not using an optional parameter here so the result of `readPreState` has to be passed in here
        preState, // snapshot: undefined            ->  not using snaphot
        // snapshot: { tag: undefined }   ->  --snapshot (empty tag)
        // snapshot: { tag: "canary" }    ->  --snapshot canary
        snapshot
      ) {
        // TODO: remove `refined*` in the next major version of this package
        // just use `config` and `snapshot` parameters directly, typed as: `config: Config, snapshot?: SnapshotReleaseParameters`
        const refinedConfig = config.snapshot
          ? config
          : _objectSpread2(
              _objectSpread2({}, config),
              {},
              {
                snapshot: {
                  prereleaseTemplate: null,
                  useCalculatedVersion:
                    config.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH
                      .useCalculatedVersionForSnapshots,
                },
              }
            )
        const refinedSnapshot =
          typeof snapshot === 'string'
            ? {
                tag: snapshot,
              }
            : typeof snapshot === 'boolean'
            ? {
                tag: undefined,
              }
            : snapshot
        let packagesByName = new Map(
          packages.packages.map(x => [x.packageJson.name, x])
        )
        const relevantChangesets = getRelevantChangesets(
          changesets,
          refinedConfig.ignore,
          preState
        )
        const preInfo = getPreInfo(
          changesets,
          packagesByName,
          refinedConfig,
          preState
        ) // releases is, at this point a list of all packages we are going to releases,
        // flattened down to one release per package, having a reference back to their
        // changesets, and with a calculated new versions

        let releases = flattenReleases(
          relevantChangesets,
          packagesByName,
          refinedConfig.ignore
        )
        let dependencyGraph = getDependentsGraph.getDependentsGraph(packages, {
          bumpVersionsWithWorkspaceProtocolOnly:
            refinedConfig.bumpVersionsWithWorkspaceProtocolOnly,
        })
        let releasesValidated = false

        while (releasesValidated === false) {
          // The map passed in to determineDependents will be mutated
          let dependentAdded = determineDependents({
            releases,
            packagesByName,
            dependencyGraph,
            preInfo,
            config: refinedConfig,
          }) // `releases` might get mutated here

          let fixedConstraintUpdated = matchFixedConstraint(
            releases,
            packagesByName,
            refinedConfig
          )
          let linksUpdated = applyLinks(
            releases,
            packagesByName,
            refinedConfig.linked
          )
          releasesValidated =
            !linksUpdated && !dependentAdded && !fixedConstraintUpdated
        }

        if (
          (preInfo === null || preInfo === void 0
            ? void 0
            : preInfo.state.mode) === 'exit'
        ) {
          for (let pkg of packages.packages) {
            // If a package had a prerelease, but didn't trigger a version bump in the regular release,
            // we want to give it a patch release.
            // Detailed explanation at https://github.com/changesets/changesets/pull/382#discussion_r434434182
            if (preInfo.preVersions.get(pkg.packageJson.name) !== 0) {
              const existingRelease = releases.get(pkg.packageJson.name)

              if (!existingRelease) {
                releases.set(pkg.packageJson.name, {
                  name: pkg.packageJson.name,
                  type: 'patch',
                  oldVersion: pkg.packageJson.version,
                  changesets: [],
                })
              } else if (
                existingRelease.type === 'none' &&
                !refinedConfig.ignore.includes(pkg.packageJson.name)
              ) {
                existingRelease.type = 'patch'
              }
            }
          }
        } // Caching the snapshot version here and use this if it is snapshot release

        const snapshotSuffix =
          refinedSnapshot &&
          getSnapshotSuffix(
            refinedConfig.snapshot.prereleaseTemplate,
            refinedSnapshot
          )
        return {
          changesets: relevantChangesets,
          releases: [...releases.values()].map(incompleteRelease => {
            return _objectSpread2(
              _objectSpread2({}, incompleteRelease),
              {},
              {
                newVersion: snapshotSuffix
                  ? getSnapshotVersion(
                      incompleteRelease,
                      preInfo,
                      refinedConfig.snapshot.useCalculatedVersion,
                      snapshotSuffix
                    )
                  : getNewVersion(incompleteRelease, preInfo),
              }
            )
          }),
          preState:
            preInfo === null || preInfo === void 0 ? void 0 : preInfo.state,
        }
      }

      function getRelevantChangesets(changesets, ignored, preState) {
        for (const changeset of changesets) {
          // Using the following 2 arrays to decide whether a changeset
          // contains both ignored and not ignored packages
          const ignoredPackages = []
          const notIgnoredPackages = []

          for (const release of changeset.releases) {
            if (
              ignored.find(
                ignoredPackageName => ignoredPackageName === release.name
              )
            ) {
              ignoredPackages.push(release.name)
            } else {
              notIgnoredPackages.push(release.name)
            }
          }

          if (ignoredPackages.length > 0 && notIgnoredPackages.length > 0) {
            throw new Error(
              `Found mixed changeset ${changeset.id}\n` +
                `Found ignored packages: ${ignoredPackages.join(' ')}\n` +
                `Found not ignored packages: ${notIgnoredPackages.join(
                  ' '
                )}\n` +
                'Mixed changesets that contain both ignored and not ignored packages are not allowed'
            )
          }
        }

        if (preState && preState.mode !== 'exit') {
          let usedChangesetIds = new Set(preState.changesets)
          return changesets.filter(
            changeset => !usedChangesetIds.has(changeset.id)
          )
        }

        return changesets
      }

      function getHighestPreVersion(packageGroup, packagesByName) {
        let highestPreVersion = 0

        for (let pkg of packageGroup) {
          highestPreVersion = Math.max(
            getPreVersion(packagesByName.get(pkg).packageJson.version),
            highestPreVersion
          )
        }

        return highestPreVersion
      }

      function getPreInfo(changesets, packagesByName, config, preState) {
        if (preState === undefined) {
          return
        }

        let updatedPreState = _objectSpread2(
          _objectSpread2({}, preState),
          {},
          {
            changesets: changesets.map(changeset => changeset.id),
            initialVersions: _objectSpread2({}, preState.initialVersions),
          }
        )

        for (const [, pkg] of packagesByName) {
          if (
            updatedPreState.initialVersions[pkg.packageJson.name] === undefined
          ) {
            updatedPreState.initialVersions[pkg.packageJson.name] =
              pkg.packageJson.version
          }
        } // Populate preVersion
        // preVersion is the map between package name and its next pre version number.

        let preVersions = new Map()

        for (const [, pkg] of packagesByName) {
          preVersions.set(
            pkg.packageJson.name,
            getPreVersion(pkg.packageJson.version)
          )
        }

        for (let fixedGroup of config.fixed) {
          let highestPreVersion = getHighestPreVersion(
            fixedGroup,
            packagesByName
          )

          for (let fixedPackage of fixedGroup) {
            preVersions.set(fixedPackage, highestPreVersion)
          }
        }

        for (let linkedGroup of config.linked) {
          let highestPreVersion = getHighestPreVersion(
            linkedGroup,
            packagesByName
          )

          for (let linkedPackage of linkedGroup) {
            preVersions.set(linkedPackage, highestPreVersion)
          }
        }

        return {
          state: updatedPreState,
          preVersions,
        }
      }

      exports['default'] = assembleReleasePlan

      /***/
    },

    /***/ 4633: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      if (process.env.NODE_ENV === 'production') {
        module.exports = __nccwpck_require__(1305)
      } else {
        module.exports = __nccwpck_require__(8618)
      }

      /***/
    },

    /***/ 1305: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: !0,
      })

      var semver = __nccwpck_require__(7183),
        errors = __nccwpck_require__(6740),
        getDependentsGraph = __nccwpck_require__(935)

      function _interopDefault(e) {
        return e && e.__esModule
          ? e
          : {
              default: e,
            }
      }

      var semver__default = _interopDefault(semver)

      function _defineProperty(obj, key, value) {
        return (
          key in obj
            ? Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (obj[key] = value),
          obj
        )
      }

      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object)
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object)
          enumerableOnly &&
            (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable
            })),
            keys.push.apply(keys, symbols)
        }
        return keys
      }

      function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = null != arguments[i] ? arguments[i] : {}
          i % 2
            ? ownKeys(Object(source), !0).forEach(function (key) {
                _defineProperty(target, key, source[key])
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(
                target,
                Object.getOwnPropertyDescriptors(source)
              )
            : ownKeys(Object(source)).forEach(function (key) {
                Object.defineProperty(
                  target,
                  key,
                  Object.getOwnPropertyDescriptor(source, key)
                )
              })
        }
        return target
      }

      function incrementVersion(release, preInfo) {
        if ('none' === release.type) return release.oldVersion
        let version = semver.inc(release.oldVersion, release.type)
        if (void 0 !== preInfo && 'exit' !== preInfo.state.mode) {
          let preVersion = preInfo.preVersions.get(release.name)
          if (void 0 === preVersion)
            throw new errors.InternalError(
              `preVersion for ${release.name} does not exist when preState is defined`
            )
          version += `-${preInfo.state.tag}.${preVersion}`
        }
        return version
      }

      function determineDependents({
        releases: releases,
        packagesByName: packagesByName,
        dependencyGraph: dependencyGraph,
        preInfo: preInfo,
        config: config,
      }) {
        let updated = !1,
          pkgsToSearch = [...releases.values()]
        for (; pkgsToSearch.length > 0; ) {
          const nextRelease = pkgsToSearch.shift()
          if (!nextRelease) continue
          const pkgDependents = dependencyGraph.get(nextRelease.name)
          if (!pkgDependents)
            throw new Error(
              'Error in determining dependents - could not find package in repository: ' +
                nextRelease.name
            )
          pkgDependents
            .map(dependent => {
              let type
              const dependentPackage = packagesByName.get(dependent)
              if (!dependentPackage)
                throw new Error('Dependency map is incorrect')
              if (config.ignore.includes(dependent)) type = 'none'
              else {
                const dependencyVersionRanges = getDependencyVersionRanges(
                  dependentPackage.packageJson,
                  nextRelease
                )
                for (const {
                  depType: depType,
                  versionRange: versionRange,
                } of dependencyVersionRanges)
                  if ('none' !== nextRelease.type)
                    if (
                      shouldBumpMajor({
                        dependent: dependent,
                        depType: depType,
                        versionRange: versionRange,
                        releases: releases,
                        nextRelease: nextRelease,
                        preInfo: preInfo,
                        onlyUpdatePeerDependentsWhenOutOfRange:
                          config
                            .___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH
                            .onlyUpdatePeerDependentsWhenOutOfRange,
                      })
                    )
                      type = 'major'
                    else if (
                      !(
                        (releases.has(dependent) &&
                          'none' !== releases.get(dependent).type) ||
                        ('always' !==
                          config
                            .___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH
                            .updateInternalDependents &&
                          semver__default.default.satisfies(
                            incrementVersion(nextRelease, preInfo),
                            versionRange
                          ))
                      )
                    )
                      switch (depType) {
                        case 'dependencies':
                        case 'optionalDependencies':
                        case 'peerDependencies':
                          'major' !== type &&
                            'minor' !== type &&
                            (type = 'patch')
                          break

                        case 'devDependencies':
                          'major' !== type &&
                            'minor' !== type &&
                            'patch' !== type &&
                            (type = 'none')
                      }
              }
              return (
                releases.has(dependent) &&
                  releases.get(dependent).type === type &&
                  (type = void 0),
                {
                  name: dependent,
                  type: type,
                  pkgJSON: dependentPackage.packageJson,
                }
              )
            })
            .filter(dependentItem => !!dependentItem.type)
            .forEach(({ name: name, type: type, pkgJSON: pkgJSON }) => {
              updated = !0
              const existing = releases.get(name)
              if (existing && 'major' === type && 'major' !== existing.type)
                (existing.type = 'major'), pkgsToSearch.push(existing)
              else {
                let newDependent = {
                  name: name,
                  type: type,
                  oldVersion: pkgJSON.version,
                  changesets: [],
                }
                pkgsToSearch.push(newDependent),
                  releases.set(name, newDependent)
              }
            })
        }
        return updated
      }

      function getDependencyVersionRanges(dependentPkgJSON, dependencyRelease) {
        const DEPENDENCY_TYPES = [
            'dependencies',
            'devDependencies',
            'peerDependencies',
            'optionalDependencies',
          ],
          dependencyVersionRanges = []
        for (const type of DEPENDENCY_TYPES) {
          var _dependentPkgJSON$typ
          const versionRange =
            null === (_dependentPkgJSON$typ = dependentPkgJSON[type]) ||
            void 0 === _dependentPkgJSON$typ
              ? void 0
              : _dependentPkgJSON$typ[dependencyRelease.name]
          versionRange &&
            (versionRange.startsWith('workspace:')
              ? dependencyVersionRanges.push({
                  depType: type,
                  versionRange:
                    'workspace:*' === versionRange
                      ? dependencyRelease.oldVersion
                      : versionRange.replace(/^workspace:/, ''),
                })
              : dependencyVersionRanges.push({
                  depType: type,
                  versionRange: versionRange,
                }))
        }
        return dependencyVersionRanges
      }

      function shouldBumpMajor({
        dependent: dependent,
        depType: depType,
        versionRange: versionRange,
        releases: releases,
        nextRelease: nextRelease,
        preInfo: preInfo,
        onlyUpdatePeerDependentsWhenOutOfRange:
          onlyUpdatePeerDependentsWhenOutOfRange,
      }) {
        return (
          'peerDependencies' === depType &&
          'none' !== nextRelease.type &&
          'patch' !== nextRelease.type &&
          (!onlyUpdatePeerDependentsWhenOutOfRange ||
            !semver__default.default.satisfies(
              incrementVersion(nextRelease, preInfo),
              versionRange
            )) &&
          (!releases.has(dependent) ||
            (releases.has(dependent) &&
              'major' !== releases.get(dependent).type))
        )
      }

      function flattenReleases(changesets, packagesByName, ignoredPackages) {
        let releases = new Map()
        return (
          changesets.forEach(changeset => {
            changeset.releases
              .filter(({ name: name }) => !ignoredPackages.includes(name))
              .forEach(({ name: name, type: type }) => {
                let release = releases.get(name),
                  pkg = packagesByName.get(name)
                if (!pkg)
                  throw new Error(
                    `"${changeset.id}" changeset mentions a release for a package "${name}" but such a package could not be found.`
                  )
                release
                  ? (('major' !== type &&
                      (('patch' !== release.type && 'none' !== release.type) ||
                        ('minor' !== type && 'patch' !== type))) ||
                      (release.type = type),
                    release.changesets.push(changeset.id))
                  : (release = {
                      name: name,
                      type: type,
                      oldVersion: pkg.packageJson.version,
                      changesets: [changeset.id],
                    }),
                  releases.set(name, release)
              })
          }),
          releases
        )
      }

      function getHighestReleaseType(releases) {
        if (0 === releases.length)
          throw new Error(
            'Large internal Changesets error when calculating highest release type in the set of releases. Please contact the maintainers'
          )
        let highestReleaseType = 'none'
        for (let release of releases)
          switch (release.type) {
            case 'major':
              return 'major'

            case 'minor':
              highestReleaseType = 'minor'
              break

            case 'patch':
              'none' === highestReleaseType && (highestReleaseType = 'patch')
          }
        return highestReleaseType
      }

      function getCurrentHighestVersion(packageGroup, packagesByName) {
        let highestVersion
        for (let pkgName of packageGroup) {
          let pkg = packagesByName.get(pkgName)
          if (!pkg)
            throw (
              (console.error(
                `FATAL ERROR IN CHANGESETS! We were unable to version for package group: ${pkgName} in package group: ${packageGroup.toString()}`
              ),
              new Error('fatal: could not resolve linked packages'))
            )
          ;(void 0 === highestVersion ||
            semver__default.default.gt(
              pkg.packageJson.version,
              highestVersion
            )) &&
            (highestVersion = pkg.packageJson.version)
        }
        return highestVersion
      }

      function matchFixedConstraint(releases, packagesByName, config) {
        let updated = !1
        for (let fixedPackages of config.fixed) {
          let releasingFixedPackages = [...releases.values()].filter(
            release =>
              fixedPackages.includes(release.name) && 'none' !== release.type
          )
          if (0 === releasingFixedPackages.length) continue
          let highestReleaseType = getHighestReleaseType(
              releasingFixedPackages
            ),
            highestVersion = getCurrentHighestVersion(
              fixedPackages,
              packagesByName
            )
          for (let pkgName of fixedPackages) {
            if (config.ignore.includes(pkgName)) continue
            let release = releases.get(pkgName)
            release
              ? (release.type !== highestReleaseType &&
                  ((updated = !0), (release.type = highestReleaseType)),
                release.oldVersion !== highestVersion &&
                  ((updated = !0), (release.oldVersion = highestVersion)))
              : ((updated = !0),
                releases.set(pkgName, {
                  name: pkgName,
                  type: highestReleaseType,
                  oldVersion: highestVersion,
                  changesets: [],
                }))
          }
        }
        return updated
      }

      function applyLinks(releases, packagesByName, linked) {
        let updated = !1
        for (let linkedPackages of linked) {
          let releasingLinkedPackages = [...releases.values()].filter(
            release =>
              linkedPackages.includes(release.name) && 'none' !== release.type
          )
          if (0 === releasingLinkedPackages.length) continue
          let highestReleaseType = getHighestReleaseType(
              releasingLinkedPackages
            ),
            highestVersion = getCurrentHighestVersion(
              linkedPackages,
              packagesByName
            )
          for (let linkedPackage of releasingLinkedPackages)
            linkedPackage.type !== highestReleaseType &&
              ((updated = !0), (linkedPackage.type = highestReleaseType)),
              linkedPackage.oldVersion !== highestVersion &&
                ((updated = !0), (linkedPackage.oldVersion = highestVersion))
        }
        return updated
      }

      function getPreVersion(version) {
        let parsed = semver.parse(version),
          preVersion =
            void 0 === parsed.prerelease[1] ? -1 : parsed.prerelease[1]
        if ('number' != typeof preVersion)
          throw new errors.InternalError('preVersion is not a number')
        return preVersion++, preVersion
      }

      function getSnapshotSuffix(template, snapshotParameters) {
        let snapshotRefDate = new Date()
        const placeholderValues = {
          commit: snapshotParameters.commit,
          tag: snapshotParameters.tag,
          timestamp: snapshotRefDate.getTime().toString(),
          datetime: snapshotRefDate
            .toISOString()
            .replace(/\.\d{3}Z$/, '')
            .replace(/[^\d]/g, ''),
        }
        if (!template)
          return [placeholderValues.tag, placeholderValues.datetime]
            .filter(Boolean)
            .join('-')
        const placeholders = Object.keys(placeholderValues)
        if (!template.includes('{tag}') && void 0 !== placeholderValues.tag)
          throw new Error(
            `Failed to compose snapshot version: "{tag}" placeholder is missing, but the snapshot parameter is defined (value: '${placeholderValues.tag}')`
          )
        return placeholders.reduce(
          (prev, key) =>
            prev.replace(new RegExp(`\\{${key}\\}`, 'g'), () => {
              const value = placeholderValues[key]
              if (void 0 === value)
                throw new Error(
                  `Failed to compose snapshot version: "{${key}}" placeholder is used without having a value defined!`
                )
              return value
            }),
          template
        )
      }

      function getSnapshotVersion(
        release,
        preInfo,
        useCalculatedVersion,
        snapshotSuffix
      ) {
        if ('none' === release.type) return release.oldVersion
        return `${
          useCalculatedVersion ? incrementVersion(release, preInfo) : '0.0.0'
        }-${snapshotSuffix}`
      }

      function getNewVersion(release, preInfo) {
        return 'none' === release.type
          ? release.oldVersion
          : incrementVersion(release, preInfo)
      }

      function assembleReleasePlan(
        changesets,
        packages,
        config,
        preState,
        snapshot
      ) {
        const refinedConfig = config.snapshot
            ? config
            : _objectSpread2(
                _objectSpread2({}, config),
                {},
                {
                  snapshot: {
                    prereleaseTemplate: null,
                    useCalculatedVersion:
                      config.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH
                        .useCalculatedVersionForSnapshots,
                  },
                }
              ),
          refinedSnapshot =
            'string' == typeof snapshot
              ? {
                  tag: snapshot,
                }
              : 'boolean' == typeof snapshot
              ? {
                  tag: void 0,
                }
              : snapshot
        let packagesByName = new Map(
          packages.packages.map(x => [x.packageJson.name, x])
        )
        const relevantChangesets = getRelevantChangesets(
            changesets,
            refinedConfig.ignore,
            preState
          ),
          preInfo = getPreInfo(
            changesets,
            packagesByName,
            refinedConfig,
            preState
          )
        let releases = flattenReleases(
            relevantChangesets,
            packagesByName,
            refinedConfig.ignore
          ),
          dependencyGraph = getDependentsGraph.getDependentsGraph(packages, {
            bumpVersionsWithWorkspaceProtocolOnly:
              refinedConfig.bumpVersionsWithWorkspaceProtocolOnly,
          }),
          releasesValidated = !1
        for (; !1 === releasesValidated; ) {
          let dependentAdded = determineDependents({
              releases: releases,
              packagesByName: packagesByName,
              dependencyGraph: dependencyGraph,
              preInfo: preInfo,
              config: refinedConfig,
            }),
            fixedConstraintUpdated = matchFixedConstraint(
              releases,
              packagesByName,
              refinedConfig
            )
          releasesValidated =
            !applyLinks(releases, packagesByName, refinedConfig.linked) &&
            !dependentAdded &&
            !fixedConstraintUpdated
        }
        if ('exit' === (null == preInfo ? void 0 : preInfo.state.mode))
          for (let pkg of packages.packages)
            if (0 !== preInfo.preVersions.get(pkg.packageJson.name)) {
              const existingRelease = releases.get(pkg.packageJson.name)
              existingRelease
                ? 'none' !== existingRelease.type ||
                  refinedConfig.ignore.includes(pkg.packageJson.name) ||
                  (existingRelease.type = 'patch')
                : releases.set(pkg.packageJson.name, {
                    name: pkg.packageJson.name,
                    type: 'patch',
                    oldVersion: pkg.packageJson.version,
                    changesets: [],
                  })
            }
        const snapshotSuffix =
          refinedSnapshot &&
          getSnapshotSuffix(
            refinedConfig.snapshot.prereleaseTemplate,
            refinedSnapshot
          )
        return {
          changesets: relevantChangesets,
          releases: [...releases.values()].map(incompleteRelease =>
            _objectSpread2(
              _objectSpread2({}, incompleteRelease),
              {},
              {
                newVersion: snapshotSuffix
                  ? getSnapshotVersion(
                      incompleteRelease,
                      preInfo,
                      refinedConfig.snapshot.useCalculatedVersion,
                      snapshotSuffix
                    )
                  : getNewVersion(incompleteRelease, preInfo),
              }
            )
          ),
          preState: null == preInfo ? void 0 : preInfo.state,
        }
      }

      function getRelevantChangesets(changesets, ignored, preState) {
        for (const changeset of changesets) {
          const ignoredPackages = [],
            notIgnoredPackages = []
          for (const release of changeset.releases)
            ignored.find(
              ignoredPackageName => ignoredPackageName === release.name
            )
              ? ignoredPackages.push(release.name)
              : notIgnoredPackages.push(release.name)
          if (ignoredPackages.length > 0 && notIgnoredPackages.length > 0)
            throw new Error(
              `Found mixed changeset ${
                changeset.id
              }\nFound ignored packages: ${ignoredPackages.join(
                ' '
              )}\nFound not ignored packages: ${notIgnoredPackages.join(
                ' '
              )}\nMixed changesets that contain both ignored and not ignored packages are not allowed`
            )
        }
        if (preState && 'exit' !== preState.mode) {
          let usedChangesetIds = new Set(preState.changesets)
          return changesets.filter(
            changeset => !usedChangesetIds.has(changeset.id)
          )
        }
        return changesets
      }

      function getHighestPreVersion(packageGroup, packagesByName) {
        let highestPreVersion = 0
        for (let pkg of packageGroup)
          highestPreVersion = Math.max(
            getPreVersion(packagesByName.get(pkg).packageJson.version),
            highestPreVersion
          )
        return highestPreVersion
      }

      function getPreInfo(changesets, packagesByName, config, preState) {
        if (void 0 === preState) return
        let updatedPreState = _objectSpread2(
          _objectSpread2({}, preState),
          {},
          {
            changesets: changesets.map(changeset => changeset.id),
            initialVersions: _objectSpread2({}, preState.initialVersions),
          }
        )
        for (const [, pkg] of packagesByName)
          void 0 === updatedPreState.initialVersions[pkg.packageJson.name] &&
            (updatedPreState.initialVersions[pkg.packageJson.name] =
              pkg.packageJson.version)
        let preVersions = new Map()
        for (const [, pkg] of packagesByName)
          preVersions.set(
            pkg.packageJson.name,
            getPreVersion(pkg.packageJson.version)
          )
        for (let fixedGroup of config.fixed) {
          let highestPreVersion = getHighestPreVersion(
            fixedGroup,
            packagesByName
          )
          for (let fixedPackage of fixedGroup)
            preVersions.set(fixedPackage, highestPreVersion)
        }
        for (let linkedGroup of config.linked) {
          let highestPreVersion = getHighestPreVersion(
            linkedGroup,
            packagesByName
          )
          for (let linkedPackage of linkedGroup)
            preVersions.set(linkedPackage, highestPreVersion)
        }
        return {
          state: updatedPreState,
          preVersions: preVersions,
        }
      }

      exports['default'] = assembleReleasePlan

      /***/
    },

    /***/ 7183: /***/ (module, exports) => {
      exports = module.exports = SemVer

      var debug
      /* istanbul ignore next */
      if (
        typeof process === 'object' &&
        process.env &&
        process.env.NODE_DEBUG &&
        /\bsemver\b/i.test(process.env.NODE_DEBUG)
      ) {
        debug = function () {
          var args = Array.prototype.slice.call(arguments, 0)
          args.unshift('SEMVER')
          console.log.apply(console, args)
        }
      } else {
        debug = function () {}
      }

      // Note: this is the semver.org version of the spec that it implements
      // Not necessarily the package version of this code.
      exports.SEMVER_SPEC_VERSION = '2.0.0'

      var MAX_LENGTH = 256
      var MAX_SAFE_INTEGER =
        Number.MAX_SAFE_INTEGER || /* istanbul ignore next */ 9007199254740991

      // Max safe segment length for coercion.
      var MAX_SAFE_COMPONENT_LENGTH = 16

      var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6

      // The actual regexps go on exports.re
      var re = (exports.re = [])
      var safeRe = (exports.safeRe = [])
      var src = (exports.src = [])
      var R = 0

      var LETTERDASHNUMBER = '[a-zA-Z0-9-]'

      // Replace some greedy regex tokens to prevent regex dos issues. These regex are
      // used internally via the safeRe object since all inputs in this library get
      // normalized first to trim and collapse all extra whitespace. The original
      // regexes are exported for userland consumption and lower level usage. A
      // future breaking change could export the safer regex only with a note that
      // all input should have extra whitespace removed.
      var safeRegexReplacements = [
        ['\\s', 1],
        ['\\d', MAX_LENGTH],
        [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
      ]

      function makeSafeRe(value) {
        for (var i = 0; i < safeRegexReplacements.length; i++) {
          var token = safeRegexReplacements[i][0]
          var max = safeRegexReplacements[i][1]
          value = value
            .split(token + '*')
            .join(token + '{0,' + max + '}')
            .split(token + '+')
            .join(token + '{1,' + max + '}')
        }
        return value
      }

      // The following Regular Expressions can be used for tokenizing,
      // validating, and parsing SemVer version strings.

      // ## Numeric Identifier
      // A single `0`, or a non-zero digit followed by zero or more digits.

      var NUMERICIDENTIFIER = R++
      src[NUMERICIDENTIFIER] = '0|[1-9]\\d*'
      var NUMERICIDENTIFIERLOOSE = R++
      src[NUMERICIDENTIFIERLOOSE] = '\\d+'

      // ## Non-numeric Identifier
      // Zero or more digits, followed by a letter or hyphen, and then zero or
      // more letters, digits, or hyphens.

      var NONNUMERICIDENTIFIER = R++
      src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-]' + LETTERDASHNUMBER + '*'

      // ## Main Version
      // Three dot-separated numeric identifiers.

      var MAINVERSION = R++
      src[MAINVERSION] =
        '(' +
        src[NUMERICIDENTIFIER] +
        ')\\.' +
        '(' +
        src[NUMERICIDENTIFIER] +
        ')\\.' +
        '(' +
        src[NUMERICIDENTIFIER] +
        ')'

      var MAINVERSIONLOOSE = R++
      src[MAINVERSIONLOOSE] =
        '(' +
        src[NUMERICIDENTIFIERLOOSE] +
        ')\\.' +
        '(' +
        src[NUMERICIDENTIFIERLOOSE] +
        ')\\.' +
        '(' +
        src[NUMERICIDENTIFIERLOOSE] +
        ')'

      // ## Pre-release Version Identifier
      // A numeric identifier, or a non-numeric identifier.

      var PRERELEASEIDENTIFIER = R++
      src[PRERELEASEIDENTIFIER] =
        '(?:' + src[NUMERICIDENTIFIER] + '|' + src[NONNUMERICIDENTIFIER] + ')'

      var PRERELEASEIDENTIFIERLOOSE = R++
      src[PRERELEASEIDENTIFIERLOOSE] =
        '(?:' +
        src[NUMERICIDENTIFIERLOOSE] +
        '|' +
        src[NONNUMERICIDENTIFIER] +
        ')'

      // ## Pre-release Version
      // Hyphen, followed by one or more dot-separated pre-release version
      // identifiers.

      var PRERELEASE = R++
      src[PRERELEASE] =
        '(?:-(' +
        src[PRERELEASEIDENTIFIER] +
        '(?:\\.' +
        src[PRERELEASEIDENTIFIER] +
        ')*))'

      var PRERELEASELOOSE = R++
      src[PRERELEASELOOSE] =
        '(?:-?(' +
        src[PRERELEASEIDENTIFIERLOOSE] +
        '(?:\\.' +
        src[PRERELEASEIDENTIFIERLOOSE] +
        ')*))'

      // ## Build Metadata Identifier
      // Any combination of digits, letters, or hyphens.

      var BUILDIDENTIFIER = R++
      src[BUILDIDENTIFIER] = LETTERDASHNUMBER + '+'

      // ## Build Metadata
      // Plus sign, followed by one or more period-separated build metadata
      // identifiers.

      var BUILD = R++
      src[BUILD] =
        '(?:\\+(' +
        src[BUILDIDENTIFIER] +
        '(?:\\.' +
        src[BUILDIDENTIFIER] +
        ')*))'

      // ## Full Version String
      // A main version, followed optionally by a pre-release version and
      // build metadata.

      // Note that the only major, minor, patch, and pre-release sections of
      // the version string are capturing groups.  The build metadata is not a
      // capturing group, because it should not ever be used in version
      // comparison.

      var FULL = R++
      var FULLPLAIN =
        'v?' + src[MAINVERSION] + src[PRERELEASE] + '?' + src[BUILD] + '?'

      src[FULL] = '^' + FULLPLAIN + '$'

      // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
      // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
      // common in the npm registry.
      var LOOSEPLAIN =
        '[v=\\s]*' +
        src[MAINVERSIONLOOSE] +
        src[PRERELEASELOOSE] +
        '?' +
        src[BUILD] +
        '?'

      var LOOSE = R++
      src[LOOSE] = '^' + LOOSEPLAIN + '$'

      var GTLT = R++
      src[GTLT] = '((?:<|>)?=?)'

      // Something like "2.*" or "1.2.x".
      // Note that "x.x" is a valid xRange identifer, meaning "any version"
      // Only the first item is strictly required.
      var XRANGEIDENTIFIERLOOSE = R++
      src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
      var XRANGEIDENTIFIER = R++
      src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*'

      var XRANGEPLAIN = R++
      src[XRANGEPLAIN] =
        '[v=\\s]*(' +
        src[XRANGEIDENTIFIER] +
        ')' +
        '(?:\\.(' +
        src[XRANGEIDENTIFIER] +
        ')' +
        '(?:\\.(' +
        src[XRANGEIDENTIFIER] +
        ')' +
        '(?:' +
        src[PRERELEASE] +
        ')?' +
        src[BUILD] +
        '?' +
        ')?)?'

      var XRANGEPLAINLOOSE = R++
      src[XRANGEPLAINLOOSE] =
        '[v=\\s]*(' +
        src[XRANGEIDENTIFIERLOOSE] +
        ')' +
        '(?:\\.(' +
        src[XRANGEIDENTIFIERLOOSE] +
        ')' +
        '(?:\\.(' +
        src[XRANGEIDENTIFIERLOOSE] +
        ')' +
        '(?:' +
        src[PRERELEASELOOSE] +
        ')?' +
        src[BUILD] +
        '?' +
        ')?)?'

      var XRANGE = R++
      src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$'
      var XRANGELOOSE = R++
      src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'

      // Coercion.
      // Extract anything that could conceivably be a part of a valid semver
      var COERCE = R++
      src[COERCE] =
        '(?:^|[^\\d])' +
        '(\\d{1,' +
        MAX_SAFE_COMPONENT_LENGTH +
        '})' +
        '(?:\\.(\\d{1,' +
        MAX_SAFE_COMPONENT_LENGTH +
        '}))?' +
        '(?:\\.(\\d{1,' +
        MAX_SAFE_COMPONENT_LENGTH +
        '}))?' +
        '(?:$|[^\\d])'

      // Tilde ranges.
      // Meaning is "reasonably at or greater than"
      var LONETILDE = R++
      src[LONETILDE] = '(?:~>?)'

      var TILDETRIM = R++
      src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+'
      re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')
      safeRe[TILDETRIM] = new RegExp(makeSafeRe(src[TILDETRIM]), 'g')
      var tildeTrimReplace = '$1~'

      var TILDE = R++
      src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'
      var TILDELOOSE = R++
      src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'

      // Caret ranges.
      // Meaning is "at least and backwards compatible with"
      var LONECARET = R++
      src[LONECARET] = '(?:\\^)'

      var CARETTRIM = R++
      src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+'
      re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')
      safeRe[CARETTRIM] = new RegExp(makeSafeRe(src[CARETTRIM]), 'g')
      var caretTrimReplace = '$1^'

      var CARET = R++
      src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'
      var CARETLOOSE = R++
      src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'

      // A simple gt/lt/eq thing, or just "" to indicate "any version"
      var COMPARATORLOOSE = R++
      src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$'
      var COMPARATOR = R++
      src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'

      // An expression to strip any whitespace between the gtlt and the thing
      // it modifies, so that `> 1.2.3` ==> `>1.2.3`
      var COMPARATORTRIM = R++
      src[COMPARATORTRIM] =
        '(\\s*)' +
        src[GTLT] +
        '\\s*(' +
        LOOSEPLAIN +
        '|' +
        src[XRANGEPLAIN] +
        ')'

      // this one has to use the /g flag
      re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')
      safeRe[COMPARATORTRIM] = new RegExp(makeSafeRe(src[COMPARATORTRIM]), 'g')
      var comparatorTrimReplace = '$1$2$3'

      // Something like `1.2.3 - 1.2.4`
      // Note that these all use the loose form, because they'll be
      // checked against either the strict or loose comparator form
      // later.
      var HYPHENRANGE = R++
      src[HYPHENRANGE] =
        '^\\s*(' +
        src[XRANGEPLAIN] +
        ')' +
        '\\s+-\\s+' +
        '(' +
        src[XRANGEPLAIN] +
        ')' +
        '\\s*$'

      var HYPHENRANGELOOSE = R++
      src[HYPHENRANGELOOSE] =
        '^\\s*(' +
        src[XRANGEPLAINLOOSE] +
        ')' +
        '\\s+-\\s+' +
        '(' +
        src[XRANGEPLAINLOOSE] +
        ')' +
        '\\s*$'

      // Star ranges basically just allow anything at all.
      var STAR = R++
      src[STAR] = '(<|>)?=?\\s*\\*'

      // Compile to actual regexp objects.
      // All are flag-free, unless they were created above with a flag.
      for (var i = 0; i < R; i++) {
        debug(i, src[i])
        if (!re[i]) {
          re[i] = new RegExp(src[i])

          // Replace all greedy whitespace to prevent regex dos issues. These regex are
          // used internally via the safeRe object since all inputs in this library get
          // normalized first to trim and collapse all extra whitespace. The original
          // regexes are exported for userland consumption and lower level usage. A
          // future breaking change could export the safer regex only with a note that
          // all input should have extra whitespace removed.
          safeRe[i] = new RegExp(makeSafeRe(src[i]))
        }
      }

      exports.parse = parse
      function parse(version, options) {
        if (!options || typeof options !== 'object') {
          options = {
            loose: !!options,
            includePrerelease: false,
          }
        }

        if (version instanceof SemVer) {
          return version
        }

        if (typeof version !== 'string') {
          return null
        }

        if (version.length > MAX_LENGTH) {
          return null
        }

        var r = options.loose ? safeRe[LOOSE] : safeRe[FULL]
        if (!r.test(version)) {
          return null
        }

        try {
          return new SemVer(version, options)
        } catch (er) {
          return null
        }
      }

      exports.valid = valid
      function valid(version, options) {
        var v = parse(version, options)
        return v ? v.version : null
      }

      exports.clean = clean
      function clean(version, options) {
        var s = parse(version.trim().replace(/^[=v]+/, ''), options)
        return s ? s.version : null
      }

      exports.SemVer = SemVer

      function SemVer(version, options) {
        if (!options || typeof options !== 'object') {
          options = {
            loose: !!options,
            includePrerelease: false,
          }
        }
        if (version instanceof SemVer) {
          if (version.loose === options.loose) {
            return version
          } else {
            version = version.version
          }
        } else if (typeof version !== 'string') {
          throw new TypeError('Invalid Version: ' + version)
        }

        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            'version is longer than ' + MAX_LENGTH + ' characters'
          )
        }

        if (!(this instanceof SemVer)) {
          return new SemVer(version, options)
        }

        debug('SemVer', version, options)
        this.options = options
        this.loose = !!options.loose

        var m = version
          .trim()
          .match(options.loose ? safeRe[LOOSE] : safeRe[FULL])

        if (!m) {
          throw new TypeError('Invalid Version: ' + version)
        }

        this.raw = version

        // these are actually numbers
        this.major = +m[1]
        this.minor = +m[2]
        this.patch = +m[3]

        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError('Invalid major version')
        }

        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError('Invalid minor version')
        }

        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError('Invalid patch version')
        }

        // numberify any prerelease numeric ids
        if (!m[4]) {
          this.prerelease = []
        } else {
          this.prerelease = m[4].split('.').map(function (id) {
            if (/^[0-9]+$/.test(id)) {
              var num = +id
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num
              }
            }
            return id
          })
        }

        this.build = m[5] ? m[5].split('.') : []
        this.format()
      }

      SemVer.prototype.format = function () {
        this.version = this.major + '.' + this.minor + '.' + this.patch
        if (this.prerelease.length) {
          this.version += '-' + this.prerelease.join('.')
        }
        return this.version
      }

      SemVer.prototype.toString = function () {
        return this.version
      }

      SemVer.prototype.compare = function (other) {
        debug('SemVer.compare', this.version, this.options, other)
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options)
        }

        return this.compareMain(other) || this.comparePre(other)
      }

      SemVer.prototype.compareMain = function (other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options)
        }

        return (
          compareIdentifiers(this.major, other.major) ||
          compareIdentifiers(this.minor, other.minor) ||
          compareIdentifiers(this.patch, other.patch)
        )
      }

      SemVer.prototype.comparePre = function (other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options)
        }

        // NOT having a prerelease is > having one
        if (this.prerelease.length && !other.prerelease.length) {
          return -1
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0
        }

        var i = 0
        do {
          var a = this.prerelease[i]
          var b = other.prerelease[i]
          debug('prerelease compare', i, a, b)
          if (a === undefined && b === undefined) {
            return 0
          } else if (b === undefined) {
            return 1
          } else if (a === undefined) {
            return -1
          } else if (a === b) {
            continue
          } else {
            return compareIdentifiers(a, b)
          }
        } while (++i)
      }

      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      SemVer.prototype.inc = function (release, identifier) {
        switch (release) {
          case 'premajor':
            this.prerelease.length = 0
            this.patch = 0
            this.minor = 0
            this.major++
            this.inc('pre', identifier)
            break
          case 'preminor':
            this.prerelease.length = 0
            this.patch = 0
            this.minor++
            this.inc('pre', identifier)
            break
          case 'prepatch':
            // If this is already a prerelease, it will bump to the next version
            // drop any prereleases that might already exist, since they are not
            // relevant at this point.
            this.prerelease.length = 0
            this.inc('patch', identifier)
            this.inc('pre', identifier)
            break
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case 'prerelease':
            if (this.prerelease.length === 0) {
              this.inc('patch', identifier)
            }
            this.inc('pre', identifier)
            break

          case 'major':
            // If this is a pre-major version, bump up to the same major version.
            // Otherwise increment major.
            // 1.0.0-5 bumps to 1.0.0
            // 1.1.0 bumps to 2.0.0
            if (
              this.minor !== 0 ||
              this.patch !== 0 ||
              this.prerelease.length === 0
            ) {
              this.major++
            }
            this.minor = 0
            this.patch = 0
            this.prerelease = []
            break
          case 'minor':
            // If this is a pre-minor version, bump up to the same minor version.
            // Otherwise increment minor.
            // 1.2.0-5 bumps to 1.2.0
            // 1.2.1 bumps to 1.3.0
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++
            }
            this.patch = 0
            this.prerelease = []
            break
          case 'patch':
            // If this is not a pre-release version, it will increment the patch.
            // If it is a pre-release it will bump up to the same patch version.
            // 1.2.0-5 patches to 1.2.0
            // 1.2.0 patches to 1.2.1
            if (this.prerelease.length === 0) {
              this.patch++
            }
            this.prerelease = []
            break
          // This probably shouldn't be used publicly.
          // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
          case 'pre':
            if (this.prerelease.length === 0) {
              this.prerelease = [0]
            } else {
              var i = this.prerelease.length
              while (--i >= 0) {
                if (typeof this.prerelease[i] === 'number') {
                  this.prerelease[i]++
                  i = -2
                }
              }
              if (i === -1) {
                // didn't increment anything
                this.prerelease.push(0)
              }
            }
            if (identifier) {
              // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
              // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
              if (this.prerelease[0] === identifier) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0]
                }
              } else {
                this.prerelease = [identifier, 0]
              }
            }
            break

          default:
            throw new Error('invalid increment argument: ' + release)
        }
        this.format()
        this.raw = this.version
        return this
      }

      exports.inc = inc
      function inc(version, release, loose, identifier) {
        if (typeof loose === 'string') {
          identifier = loose
          loose = undefined
        }

        try {
          return new SemVer(version, loose).inc(release, identifier).version
        } catch (er) {
          return null
        }
      }

      exports.diff = diff
      function diff(version1, version2) {
        if (eq(version1, version2)) {
          return null
        } else {
          var v1 = parse(version1)
          var v2 = parse(version2)
          var prefix = ''
          if (v1.prerelease.length || v2.prerelease.length) {
            prefix = 'pre'
            var defaultResult = 'prerelease'
          }
          for (var key in v1) {
            if (key === 'major' || key === 'minor' || key === 'patch') {
              if (v1[key] !== v2[key]) {
                return prefix + key
              }
            }
          }
          return defaultResult // may be undefined
        }
      }

      exports.compareIdentifiers = compareIdentifiers

      var numeric = /^[0-9]+$/
      function compareIdentifiers(a, b) {
        var anum = numeric.test(a)
        var bnum = numeric.test(b)

        if (anum && bnum) {
          a = +a
          b = +b
        }

        return a === b
          ? 0
          : anum && !bnum
          ? -1
          : bnum && !anum
          ? 1
          : a < b
          ? -1
          : 1
      }

      exports.rcompareIdentifiers = rcompareIdentifiers
      function rcompareIdentifiers(a, b) {
        return compareIdentifiers(b, a)
      }

      exports.major = major
      function major(a, loose) {
        return new SemVer(a, loose).major
      }

      exports.minor = minor
      function minor(a, loose) {
        return new SemVer(a, loose).minor
      }

      exports.patch = patch
      function patch(a, loose) {
        return new SemVer(a, loose).patch
      }

      exports.compare = compare
      function compare(a, b, loose) {
        return new SemVer(a, loose).compare(new SemVer(b, loose))
      }

      exports.compareLoose = compareLoose
      function compareLoose(a, b) {
        return compare(a, b, true)
      }

      exports.rcompare = rcompare
      function rcompare(a, b, loose) {
        return compare(b, a, loose)
      }

      exports.sort = sort
      function sort(list, loose) {
        return list.sort(function (a, b) {
          return exports.compare(a, b, loose)
        })
      }

      exports.rsort = rsort
      function rsort(list, loose) {
        return list.sort(function (a, b) {
          return exports.rcompare(a, b, loose)
        })
      }

      exports.gt = gt
      function gt(a, b, loose) {
        return compare(a, b, loose) > 0
      }

      exports.lt = lt
      function lt(a, b, loose) {
        return compare(a, b, loose) < 0
      }

      exports.eq = eq
      function eq(a, b, loose) {
        return compare(a, b, loose) === 0
      }

      exports.neq = neq
      function neq(a, b, loose) {
        return compare(a, b, loose) !== 0
      }

      exports.gte = gte
      function gte(a, b, loose) {
        return compare(a, b, loose) >= 0
      }

      exports.lte = lte
      function lte(a, b, loose) {
        return compare(a, b, loose) <= 0
      }

      exports.cmp = cmp
      function cmp(a, op, b, loose) {
        switch (op) {
          case '===':
            if (typeof a === 'object') a = a.version
            if (typeof b === 'object') b = b.version
            return a === b

          case '!==':
            if (typeof a === 'object') a = a.version
            if (typeof b === 'object') b = b.version
            return a !== b

          case '':
          case '=':
          case '==':
            return eq(a, b, loose)

          case '!=':
            return neq(a, b, loose)

          case '>':
            return gt(a, b, loose)

          case '>=':
            return gte(a, b, loose)

          case '<':
            return lt(a, b, loose)

          case '<=':
            return lte(a, b, loose)

          default:
            throw new TypeError('Invalid operator: ' + op)
        }
      }

      exports.Comparator = Comparator
      function Comparator(comp, options) {
        if (!options || typeof options !== 'object') {
          options = {
            loose: !!options,
            includePrerelease: false,
          }
        }

        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp
          } else {
            comp = comp.value
          }
        }

        if (!(this instanceof Comparator)) {
          return new Comparator(comp, options)
        }

        comp = comp.trim().split(/\s+/).join(' ')
        debug('comparator', comp, options)
        this.options = options
        this.loose = !!options.loose
        this.parse(comp)

        if (this.semver === ANY) {
          this.value = ''
        } else {
          this.value = this.operator + this.semver.version
        }

        debug('comp', this)
      }

      var ANY = {}
      Comparator.prototype.parse = function (comp) {
        var r = this.options.loose
          ? safeRe[COMPARATORLOOSE]
          : safeRe[COMPARATOR]
        var m = comp.match(r)

        if (!m) {
          throw new TypeError('Invalid comparator: ' + comp)
        }

        this.operator = m[1]
        if (this.operator === '=') {
          this.operator = ''
        }

        // if it literally is just '>' or '' then allow anything.
        if (!m[2]) {
          this.semver = ANY
        } else {
          this.semver = new SemVer(m[2], this.options.loose)
        }
      }

      Comparator.prototype.toString = function () {
        return this.value
      }

      Comparator.prototype.test = function (version) {
        debug('Comparator.test', version, this.options.loose)

        if (this.semver === ANY) {
          return true
        }

        if (typeof version === 'string') {
          version = new SemVer(version, this.options)
        }

        return cmp(version, this.operator, this.semver, this.options)
      }

      Comparator.prototype.intersects = function (comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError('a Comparator is required')
        }

        if (!options || typeof options !== 'object') {
          options = {
            loose: !!options,
            includePrerelease: false,
          }
        }

        var rangeTmp

        if (this.operator === '') {
          rangeTmp = new Range(comp.value, options)
          return satisfies(this.value, rangeTmp, options)
        } else if (comp.operator === '') {
          rangeTmp = new Range(this.value, options)
          return satisfies(comp.semver, rangeTmp, options)
        }

        var sameDirectionIncreasing =
          (this.operator === '>=' || this.operator === '>') &&
          (comp.operator === '>=' || comp.operator === '>')
        var sameDirectionDecreasing =
          (this.operator === '<=' || this.operator === '<') &&
          (comp.operator === '<=' || comp.operator === '<')
        var sameSemVer = this.semver.version === comp.semver.version
        var differentDirectionsInclusive =
          (this.operator === '>=' || this.operator === '<=') &&
          (comp.operator === '>=' || comp.operator === '<=')
        var oppositeDirectionsLessThan =
          cmp(this.semver, '<', comp.semver, options) &&
          (this.operator === '>=' || this.operator === '>') &&
          (comp.operator === '<=' || comp.operator === '<')
        var oppositeDirectionsGreaterThan =
          cmp(this.semver, '>', comp.semver, options) &&
          (this.operator === '<=' || this.operator === '<') &&
          (comp.operator === '>=' || comp.operator === '>')

        return (
          sameDirectionIncreasing ||
          sameDirectionDecreasing ||
          (sameSemVer && differentDirectionsInclusive) ||
          oppositeDirectionsLessThan ||
          oppositeDirectionsGreaterThan
        )
      }

      exports.Range = Range
      function Range(range, options) {
        if (!options || typeof options !== 'object') {
          options = {
            loose: !!options,
            includePrerelease: false,
          }
        }

        if (range instanceof Range) {
          if (
            range.loose === !!options.loose &&
            range.includePrerelease === !!options.includePrerelease
          ) {
            return range
          } else {
            return new Range(range.raw, options)
          }
        }

        if (range instanceof Comparator) {
          return new Range(range.value, options)
        }

        if (!(this instanceof Range)) {
          return new Range(range, options)
        }

        this.options = options
        this.loose = !!options.loose
        this.includePrerelease = !!options.includePrerelease

        // First reduce all whitespace as much as possible so we do not have to rely
        // on potentially slow regexes like \s*. This is then stored and used for
        // future error messages as well.
        this.raw = range.trim().split(/\s+/).join(' ')

        // First, split based on boolean or ||
        this.set = this.raw
          .split('||')
          .map(function (range) {
            return this.parseRange(range.trim())
          }, this)
          .filter(function (c) {
            // throw out any that are not relevant for whatever reason
            return c.length
          })

        if (!this.set.length) {
          throw new TypeError('Invalid SemVer Range: ' + this.raw)
        }

        this.format()
      }

      Range.prototype.format = function () {
        this.range = this.set
          .map(function (comps) {
            return comps.join(' ').trim()
          })
          .join('||')
          .trim()
        return this.range
      }

      Range.prototype.toString = function () {
        return this.range
      }

      Range.prototype.parseRange = function (range) {
        var loose = this.options.loose
        // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
        var hr = loose ? safeRe[HYPHENRANGELOOSE] : safeRe[HYPHENRANGE]
        range = range.replace(hr, hyphenReplace)
        debug('hyphen replace', range)
        // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
        range = range.replace(safeRe[COMPARATORTRIM], comparatorTrimReplace)
        debug('comparator trim', range, safeRe[COMPARATORTRIM])

        // `~ 1.2.3` => `~1.2.3`
        range = range.replace(safeRe[TILDETRIM], tildeTrimReplace)

        // `^ 1.2.3` => `^1.2.3`
        range = range.replace(safeRe[CARETTRIM], caretTrimReplace)

        // At this point, the range is completely trimmed and
        // ready to be split into comparators.
        var compRe = loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR]
        var set = range
          .split(' ')
          .map(function (comp) {
            return parseComparator(comp, this.options)
          }, this)
          .join(' ')
          .split(/\s+/)
        if (this.options.loose) {
          // in loose mode, throw out any that are not valid comparators
          set = set.filter(function (comp) {
            return !!comp.match(compRe)
          })
        }
        set = set.map(function (comp) {
          return new Comparator(comp, this.options)
        }, this)

        return set
      }

      Range.prototype.intersects = function (range, options) {
        if (!(range instanceof Range)) {
          throw new TypeError('a Range is required')
        }

        return this.set.some(function (thisComparators) {
          return thisComparators.every(function (thisComparator) {
            return range.set.some(function (rangeComparators) {
              return rangeComparators.every(function (rangeComparator) {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          })
        })
      }

      // Mostly just for testing and legacy API reasons
      exports.toComparators = toComparators
      function toComparators(range, options) {
        return new Range(range, options).set.map(function (comp) {
          return comp
            .map(function (c) {
              return c.value
            })
            .join(' ')
            .trim()
            .split(' ')
        })
      }

      // comprised of xranges, tildes, stars, and gtlt's at this point.
      // already replaced the hyphen ranges
      // turn into a set of JUST comparators.
      function parseComparator(comp, options) {
        debug('comp', comp, options)
        comp = replaceCarets(comp, options)
        debug('caret', comp)
        comp = replaceTildes(comp, options)
        debug('tildes', comp)
        comp = replaceXRanges(comp, options)
        debug('xrange', comp)
        comp = replaceStars(comp, options)
        debug('stars', comp)
        return comp
      }

      function isX(id) {
        return !id || id.toLowerCase() === 'x' || id === '*'
      }

      // ~, ~> --> * (any, kinda silly)
      // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
      // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
      // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
      // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
      // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
      function replaceTildes(comp, options) {
        return comp
          .trim()
          .split(/\s+/)
          .map(function (comp) {
            return replaceTilde(comp, options)
          })
          .join(' ')
      }

      function replaceTilde(comp, options) {
        var r = options.loose ? safeRe[TILDELOOSE] : safeRe[TILDE]
        return comp.replace(r, function (_, M, m, p, pr) {
          debug('tilde', comp, _, M, m, p, pr)
          var ret

          if (isX(M)) {
            ret = ''
          } else if (isX(m)) {
            ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
          } else if (isX(p)) {
            // ~1.2 == >=1.2.0 <1.3.0
            ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
          } else if (pr) {
            debug('replaceTilde pr', pr)
            ret =
              '>=' +
              M +
              '.' +
              m +
              '.' +
              p +
              '-' +
              pr +
              ' <' +
              M +
              '.' +
              (+m + 1) +
              '.0'
          } else {
            // ~1.2.3 == >=1.2.3 <1.3.0
            ret =
              '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0'
          }

          debug('tilde return', ret)
          return ret
        })
      }

      // ^ --> * (any, kinda silly)
      // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
      // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
      // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
      // ^1.2.3 --> >=1.2.3 <2.0.0
      // ^1.2.0 --> >=1.2.0 <2.0.0
      function replaceCarets(comp, options) {
        return comp
          .trim()
          .split(/\s+/)
          .map(function (comp) {
            return replaceCaret(comp, options)
          })
          .join(' ')
      }

      function replaceCaret(comp, options) {
        debug('caret', comp, options)
        var r = options.loose ? safeRe[CARETLOOSE] : safeRe[CARET]
        return comp.replace(r, function (_, M, m, p, pr) {
          debug('caret', comp, _, M, m, p, pr)
          var ret

          if (isX(M)) {
            ret = ''
          } else if (isX(m)) {
            ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
          } else if (isX(p)) {
            if (M === '0') {
              ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
            } else {
              ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
            }
          } else if (pr) {
            debug('replaceCaret pr', pr)
            if (M === '0') {
              if (m === '0') {
                ret =
                  '>=' +
                  M +
                  '.' +
                  m +
                  '.' +
                  p +
                  '-' +
                  pr +
                  ' <' +
                  M +
                  '.' +
                  m +
                  '.' +
                  (+p + 1)
              } else {
                ret =
                  '>=' +
                  M +
                  '.' +
                  m +
                  '.' +
                  p +
                  '-' +
                  pr +
                  ' <' +
                  M +
                  '.' +
                  (+m + 1) +
                  '.0'
              }
            } else {
              ret =
                '>=' +
                M +
                '.' +
                m +
                '.' +
                p +
                '-' +
                pr +
                ' <' +
                (+M + 1) +
                '.0.0'
            }
          } else {
            debug('no pr')
            if (M === '0') {
              if (m === '0') {
                ret =
                  '>=' +
                  M +
                  '.' +
                  m +
                  '.' +
                  p +
                  ' <' +
                  M +
                  '.' +
                  m +
                  '.' +
                  (+p + 1)
              } else {
                ret =
                  '>=' +
                  M +
                  '.' +
                  m +
                  '.' +
                  p +
                  ' <' +
                  M +
                  '.' +
                  (+m + 1) +
                  '.0'
              }
            } else {
              ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0'
            }
          }

          debug('caret return', ret)
          return ret
        })
      }

      function replaceXRanges(comp, options) {
        debug('replaceXRanges', comp, options)
        return comp
          .split(/\s+/)
          .map(function (comp) {
            return replaceXRange(comp, options)
          })
          .join(' ')
      }

      function replaceXRange(comp, options) {
        comp = comp.trim()
        var r = options.loose ? safeRe[XRANGELOOSE] : safeRe[XRANGE]
        return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
          debug('xRange', comp, ret, gtlt, M, m, p, pr)
          var xM = isX(M)
          var xm = xM || isX(m)
          var xp = xm || isX(p)
          var anyX = xp

          if (gtlt === '=' && anyX) {
            gtlt = ''
          }

          if (xM) {
            if (gtlt === '>' || gtlt === '<') {
              // nothing is allowed
              ret = '<0.0.0'
            } else {
              // nothing is forbidden
              ret = '*'
            }
          } else if (gtlt && anyX) {
            // we know patch is an x, because we have any x at all.
            // replace X with 0
            if (xm) {
              m = 0
            }
            p = 0

            if (gtlt === '>') {
              // >1 => >=2.0.0
              // >1.2 => >=1.3.0
              // >1.2.3 => >= 1.2.4
              gtlt = '>='
              if (xm) {
                M = +M + 1
                m = 0
                p = 0
              } else {
                m = +m + 1
                p = 0
              }
            } else if (gtlt === '<=') {
              // <=0.7.x is actually <0.8.0, since any 0.7.x should
              // pass.  Similarly, <=7.x is actually <8.0.0, etc.
              gtlt = '<'
              if (xm) {
                M = +M + 1
              } else {
                m = +m + 1
              }
            }

            ret = gtlt + M + '.' + m + '.' + p
          } else if (xm) {
            ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
          } else if (xp) {
            ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
          }

          debug('xRange return', ret)

          return ret
        })
      }

      // Because * is AND-ed with everything else in the comparator,
      // and '' means "any version", just remove the *s entirely.
      function replaceStars(comp, options) {
        debug('replaceStars', comp, options)
        // Looseness is ignored here.  star is always as loose as it gets!
        return comp.trim().replace(safeRe[STAR], '')
      }

      // This function is passed to string.replace(safeRe[HYPHENRANGE])
      // M, m, patch, prerelease, build
      // 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
      // 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
      // 1.2 - 3.4 => >=1.2.0 <3.5.0
      function hyphenReplace(
        $0,
        from,
        fM,
        fm,
        fp,
        fpr,
        fb,
        to,
        tM,
        tm,
        tp,
        tpr,
        tb
      ) {
        if (isX(fM)) {
          from = ''
        } else if (isX(fm)) {
          from = '>=' + fM + '.0.0'
        } else if (isX(fp)) {
          from = '>=' + fM + '.' + fm + '.0'
        } else {
          from = '>=' + from
        }

        if (isX(tM)) {
          to = ''
        } else if (isX(tm)) {
          to = '<' + (+tM + 1) + '.0.0'
        } else if (isX(tp)) {
          to = '<' + tM + '.' + (+tm + 1) + '.0'
        } else if (tpr) {
          to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
        } else {
          to = '<=' + to
        }

        return (from + ' ' + to).trim()
      }

      // if ANY of the sets match ALL of its comparators, then pass
      Range.prototype.test = function (version) {
        if (!version) {
          return false
        }

        if (typeof version === 'string') {
          version = new SemVer(version, this.options)
        }

        for (var i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true
          }
        }
        return false
      }

      function testSet(set, version, options) {
        for (var i = 0; i < set.length; i++) {
          if (!set[i].test(version)) {
            return false
          }
        }

        if (version.prerelease.length && !options.includePrerelease) {
          // Find the set of versions that are allowed to have prereleases
          // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
          // That should allow `1.2.3-pr.2` to pass.
          // However, `1.2.4-alpha.notready` should NOT be allowed,
          // even though it's within the range set by the comparators.
          for (i = 0; i < set.length; i++) {
            debug(set[i].semver)
            if (set[i].semver === ANY) {
              continue
            }

            if (set[i].semver.prerelease.length > 0) {
              var allowed = set[i].semver
              if (
                allowed.major === version.major &&
                allowed.minor === version.minor &&
                allowed.patch === version.patch
              ) {
                return true
              }
            }
          }

          // Version has a -pre, but it's not one of the ones we like.
          return false
        }

        return true
      }

      exports.satisfies = satisfies
      function satisfies(version, range, options) {
        try {
          range = new Range(range, options)
        } catch (er) {
          return false
        }
        return range.test(version)
      }

      exports.maxSatisfying = maxSatisfying
      function maxSatisfying(versions, range, options) {
        var max = null
        var maxSV = null
        try {
          var rangeObj = new Range(range, options)
        } catch (er) {
          return null
        }
        versions.forEach(function (v) {
          if (rangeObj.test(v)) {
            // satisfies(v, range, options)
            if (!max || maxSV.compare(v) === -1) {
              // compare(max, v, true)
              max = v
              maxSV = new SemVer(max, options)
            }
          }
        })
        return max
      }

      exports.minSatisfying = minSatisfying
      function minSatisfying(versions, range, options) {
        var min = null
        var minSV = null
        try {
          var rangeObj = new Range(range, options)
        } catch (er) {
          return null
        }
        versions.forEach(function (v) {
          if (rangeObj.test(v)) {
            // satisfies(v, range, options)
            if (!min || minSV.compare(v) === 1) {
              // compare(min, v, true)
              min = v
              minSV = new SemVer(min, options)
            }
          }
        })
        return min
      }

      exports.minVersion = minVersion
      function minVersion(range, loose) {
        range = new Range(range, loose)

        var minver = new SemVer('0.0.0')
        if (range.test(minver)) {
          return minver
        }

        minver = new SemVer('0.0.0-0')
        if (range.test(minver)) {
          return minver
        }

        minver = null
        for (var i = 0; i < range.set.length; ++i) {
          var comparators = range.set[i]

          comparators.forEach(function (comparator) {
            // Clone to avoid manipulating the comparator's semver object.
            var compver = new SemVer(comparator.semver.version)
            switch (comparator.operator) {
              case '>':
                if (compver.prerelease.length === 0) {
                  compver.patch++
                } else {
                  compver.prerelease.push(0)
                }
                compver.raw = compver.format()
              /* fallthrough */
              case '':
              case '>=':
                if (!minver || gt(minver, compver)) {
                  minver = compver
                }
                break
              case '<':
              case '<=':
                /* Ignore maximum versions */
                break
              /* istanbul ignore next */
              default:
                throw new Error('Unexpected operation: ' + comparator.operator)
            }
          })
        }

        if (minver && range.test(minver)) {
          return minver
        }

        return null
      }

      exports.validRange = validRange
      function validRange(range, options) {
        try {
          // Return '*' instead of '' so that truthiness works.
          // This will throw if it's invalid anyway
          return new Range(range, options).range || '*'
        } catch (er) {
          return null
        }
      }

      // Determine if version is less than all the versions possible in the range
      exports.ltr = ltr
      function ltr(version, range, options) {
        return outside(version, range, '<', options)
      }

      // Determine if version is greater than all the versions possible in the range.
      exports.gtr = gtr
      function gtr(version, range, options) {
        return outside(version, range, '>', options)
      }

      exports.outside = outside
      function outside(version, range, hilo, options) {
        version = new SemVer(version, options)
        range = new Range(range, options)

        var gtfn, ltefn, ltfn, comp, ecomp
        switch (hilo) {
          case '>':
            gtfn = gt
            ltefn = lte
            ltfn = lt
            comp = '>'
            ecomp = '>='
            break
          case '<':
            gtfn = lt
            ltefn = gte
            ltfn = gt
            comp = '<'
            ecomp = '<='
            break
          default:
            throw new TypeError('Must provide a hilo val of "<" or ">"')
        }

        // If it satisifes the range it is not outside
        if (satisfies(version, range, options)) {
          return false
        }

        // From now on, variable terms are as if we're in "gtr" mode.
        // but note that everything is flipped for the "ltr" function.

        for (var i = 0; i < range.set.length; ++i) {
          var comparators = range.set[i]

          var high = null
          var low = null

          comparators.forEach(function (comparator) {
            if (comparator.semver === ANY) {
              comparator = new Comparator('>=0.0.0')
            }
            high = high || comparator
            low = low || comparator
            if (gtfn(comparator.semver, high.semver, options)) {
              high = comparator
            } else if (ltfn(comparator.semver, low.semver, options)) {
              low = comparator
            }
          })

          // If the edge version comparator has a operator then our version
          // isn't outside it
          if (high.operator === comp || high.operator === ecomp) {
            return false
          }

          // If the lowest version comparator has an operator and our version
          // is less than it then it isn't higher than the range
          if (
            (!low.operator || low.operator === comp) &&
            ltefn(version, low.semver)
          ) {
            return false
          } else if (low.operator === ecomp && ltfn(version, low.semver)) {
            return false
          }
        }
        return true
      }

      exports.prerelease = prerelease
      function prerelease(version, options) {
        var parsed = parse(version, options)
        return parsed && parsed.prerelease.length ? parsed.prerelease : null
      }

      exports.intersects = intersects
      function intersects(r1, r2, options) {
        r1 = new Range(r1, options)
        r2 = new Range(r2, options)
        return r1.intersects(r2)
      }

      exports.coerce = coerce
      function coerce(version) {
        if (version instanceof SemVer) {
          return version
        }

        if (typeof version !== 'string') {
          return null
        }

        var match = version.match(safeRe[COERCE])

        if (match == null) {
          return null
        }

        return parse(
          match[1] + '.' + (match[2] || '0') + '.' + (match[3] || '0')
        )
      }

      /***/
    },

    /***/ 7684: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })

      var fs = __nccwpck_require__(5630)
      var path = __nccwpck_require__(1017)
      var micromatch = __nccwpck_require__(6228)
      var errors = __nccwpck_require__(6740)
      var logger = __nccwpck_require__(6010)
      var getDependentsGraph = __nccwpck_require__(935)

      function _interopDefault(e) {
        return e && e.__esModule ? e : { default: e }
      }

      var path__default = /*#__PURE__*/ _interopDefault(path)
      var micromatch__default = /*#__PURE__*/ _interopDefault(micromatch)

      var packageJson = {
        name: '@changesets/config',
        version: '2.3.0',
        description: "Utilities for reading and parsing Changeset's config",
        main: 'dist/config.cjs.js',
        module: 'dist/config.esm.js',
        license: 'MIT',
        repository:
          'https://github.com/changesets/changesets/tree/main/packages/config',
        files: ['dist', 'schema.json'],
        dependencies: {
          '@changesets/errors': '^0.1.4',
          '@changesets/get-dependents-graph': '^1.3.5',
          '@changesets/logger': '^0.0.5',
          '@changesets/types': '^5.2.1',
          '@manypkg/get-packages': '^1.1.3',
          'fs-extra': '^7.0.1',
          micromatch: '^4.0.2',
        },
        devDependencies: {
          '@changesets/test-utils': '*',
          '@types/micromatch': '^4.0.1',
          'jest-in-case': '^1.0.2',
        },
      }

      let defaultWrittenConfig = {
        $schema: `https://unpkg.com/@changesets/config@${packageJson.version}/schema.json`,
        changelog: '@changesets/cli/changelog',
        commit: false,
        fixed: [],
        linked: [],
        access: 'restricted',
        baseBranch: 'master',
        updateInternalDependencies: 'patch',
        ignore: [],
      }

      function flatten(arr) {
        return [].concat(...arr)
      }

      function getNormalizedChangelogOption(thing) {
        if (thing === false) {
          return false
        }

        if (typeof thing === 'string') {
          return [thing, null]
        }

        return thing
      }

      function getNormalizedCommitOption(thing) {
        if (thing === false) {
          return false
        }

        if (thing === true) {
          return [
            '@changesets/cli/commit',
            {
              skipCI: 'version',
            },
          ]
        }

        if (typeof thing === 'string') {
          return [thing, null]
        }

        return thing
      }

      function getUnmatchedPatterns(listOfPackageNamesOrGlob, pkgNames) {
        return listOfPackageNamesOrGlob.filter(
          pkgNameOrGlob =>
            !pkgNames.some(pkgName =>
              micromatch__default['default'].isMatch(pkgName, pkgNameOrGlob)
            )
        )
      }

      const havePackageGroupsCorrectShape = pkgGroups => {
        return (
          isArray(pkgGroups) &&
          pkgGroups.every(
            arr =>
              isArray(arr) && arr.every(pkgName => typeof pkgName === 'string')
          )
        )
      } // TODO: it might be possible to remove this if improvements to `Array.isArray` ever land
      // related thread: github.com/microsoft/TypeScript/issues/36554

      function isArray(arg) {
        return Array.isArray(arg)
      }

      let read = async (cwd, packages) => {
        let json = await fs.readJSON(
          path__default['default'].join(cwd, '.changeset', 'config.json')
        )
        return parse(json, packages)
      }
      let parse = (json, packages) => {
        var _json$changedFilePatt,
          _json$snapshot$prerel,
          _json$snapshot,
          _json$snapshot2,
          _json$___experimental,
          _json$___experimental2,
          _json$___experimental3,
          _json$___experimental4,
          _json$privatePackages,
          _json$privatePackages2

        let messages = []
        let pkgNames = packages.packages.map(
          ({ packageJson }) => packageJson.name
        )

        if (
          json.changelog !== undefined &&
          json.changelog !== false &&
          typeof json.changelog !== 'string' &&
          !(
            isArray(json.changelog) &&
            json.changelog.length === 2 &&
            typeof json.changelog[0] === 'string'
          )
        ) {
          messages.push(
            `The \`changelog\` option is set as ${JSON.stringify(
              json.changelog,
              null,
              2
            )} when the only valid values are undefined, false, a module path(e.g. "@changesets/cli/changelog" or "./some-module") or a tuple with a module path and config for the changelog generator(e.g. ["@changesets/cli/changelog", { someOption: true }])`
          )
        }

        let normalizedAccess = json.access

        if (json.access === 'private') {
          normalizedAccess = 'restricted'
          logger.warn(
            'The `access` option is set as "private", but this is actually not a valid value - the correct form is "restricted".'
          )
        }

        if (
          normalizedAccess !== undefined &&
          normalizedAccess !== 'restricted' &&
          normalizedAccess !== 'public'
        ) {
          messages.push(
            `The \`access\` option is set as ${JSON.stringify(
              normalizedAccess,
              null,
              2
            )} when the only valid values are undefined, "public" or "restricted"`
          )
        }

        if (
          json.commit !== undefined &&
          typeof json.commit !== 'boolean' &&
          typeof json.commit !== 'string' &&
          !(
            isArray(json.commit) &&
            json.commit.length === 2 &&
            typeof json.commit[0] === 'string'
          )
        ) {
          messages.push(
            `The \`commit\` option is set as ${JSON.stringify(
              json.commit,
              null,
              2
            )} when the only valid values are undefined or a boolean or a module path (e.g. "@changesets/cli/commit" or "./some-module") or a tuple with a module path and config for the commit message generator (e.g. ["@changesets/cli/commit", { "skipCI": "version" }])`
          )
        }

        if (
          json.baseBranch !== undefined &&
          typeof json.baseBranch !== 'string'
        ) {
          messages.push(
            `The \`baseBranch\` option is set as ${JSON.stringify(
              json.baseBranch,
              null,
              2
            )} but the \`baseBranch\` option can only be set as a string`
          )
        }

        if (
          json.changedFilePatterns !== undefined &&
          (!isArray(json.changedFilePatterns) ||
            !json.changedFilePatterns.every(
              pattern => typeof pattern === 'string'
            ))
        ) {
          messages.push(
            `The \`changedFilePatterns\` option is set as ${JSON.stringify(
              json.changedFilePatterns,
              null,
              2
            )} but the \`changedFilePatterns\` option can only be set as an array of strings`
          )
        }

        let fixed = []

        if (json.fixed !== undefined) {
          if (!havePackageGroupsCorrectShape(json.fixed)) {
            messages.push(
              `The \`fixed\` option is set as ${JSON.stringify(
                json.fixed,
                null,
                2
              )} when the only valid values are undefined or an array of arrays of package names`
            )
          } else {
            let foundPkgNames = new Set()
            let duplicatedPkgNames = new Set()

            for (let fixedGroup of json.fixed) {
              messages.push(
                ...getUnmatchedPatterns(fixedGroup, pkgNames).map(
                  pkgOrGlob =>
                    `The package or glob expression "${pkgOrGlob}" specified in the \`fixed\` option does not match any package in the project. You may have misspelled the package name or provided an invalid glob expression. Note that glob expressions must be defined according to https://www.npmjs.com/package/micromatch.`
                )
              )
              let expandedFixedGroup = micromatch__default['default'](
                pkgNames,
                fixedGroup
              )
              fixed.push(expandedFixedGroup)

              for (let fixedPkgName of expandedFixedGroup) {
                if (foundPkgNames.has(fixedPkgName)) {
                  duplicatedPkgNames.add(fixedPkgName)
                }

                foundPkgNames.add(fixedPkgName)
              }
            }

            if (duplicatedPkgNames.size) {
              duplicatedPkgNames.forEach(pkgName => {
                messages.push(
                  `The package "${pkgName}" is defined in multiple sets of fixed packages. Packages can only be defined in a single set of fixed packages. If you are using glob expressions, make sure that they are valid according to https://www.npmjs.com/package/micromatch.`
                )
              })
            }
          }
        }

        let linked = []

        if (json.linked !== undefined) {
          if (!havePackageGroupsCorrectShape(json.linked)) {
            messages.push(
              `The \`linked\` option is set as ${JSON.stringify(
                json.linked,
                null,
                2
              )} when the only valid values are undefined or an array of arrays of package names`
            )
          } else {
            let foundPkgNames = new Set()
            let duplicatedPkgNames = new Set()

            for (let linkedGroup of json.linked) {
              messages.push(
                ...getUnmatchedPatterns(linkedGroup, pkgNames).map(
                  pkgOrGlob =>
                    `The package or glob expression "${pkgOrGlob}" specified in the \`linked\` option does not match any package in the project. You may have misspelled the package name or provided an invalid glob expression. Note that glob expressions must be defined according to https://www.npmjs.com/package/micromatch.`
                )
              )
              let expandedLinkedGroup = micromatch__default['default'](
                pkgNames,
                linkedGroup
              )
              linked.push(expandedLinkedGroup)

              for (let linkedPkgName of expandedLinkedGroup) {
                if (foundPkgNames.has(linkedPkgName)) {
                  duplicatedPkgNames.add(linkedPkgName)
                }

                foundPkgNames.add(linkedPkgName)
              }
            }

            if (duplicatedPkgNames.size) {
              duplicatedPkgNames.forEach(pkgName => {
                messages.push(
                  `The package "${pkgName}" is defined in multiple sets of linked packages. Packages can only be defined in a single set of linked packages. If you are using glob expressions, make sure that they are valid according to https://www.npmjs.com/package/micromatch.`
                )
              })
            }
          }
        }

        const allFixedPackages = new Set(flatten(fixed))
        const allLinkedPackages = new Set(flatten(linked))
        allFixedPackages.forEach(pkgName => {
          if (allLinkedPackages.has(pkgName)) {
            messages.push(
              `The package "${pkgName}" can be found in both fixed and linked groups. A package can only be either fixed or linked.`
            )
          }
        })

        if (
          json.updateInternalDependencies !== undefined &&
          !['patch', 'minor'].includes(json.updateInternalDependencies)
        ) {
          messages.push(
            `The \`updateInternalDependencies\` option is set as ${JSON.stringify(
              json.updateInternalDependencies,
              null,
              2
            )} but can only be 'patch' or 'minor'`
          )
        }

        if (json.ignore) {
          if (
            !(
              isArray(json.ignore) &&
              json.ignore.every(pkgName => typeof pkgName === 'string')
            )
          ) {
            messages.push(
              `The \`ignore\` option is set as ${JSON.stringify(
                json.ignore,
                null,
                2
              )} when the only valid values are undefined or an array of package names`
            )
          } else {
            messages.push(
              ...getUnmatchedPatterns(json.ignore, pkgNames).map(
                pkgOrGlob =>
                  `The package or glob expression "${pkgOrGlob}" is specified in the \`ignore\` option but it is not found in the project. You may have misspelled the package name or provided an invalid glob expression. Note that glob expressions must be defined according to https://www.npmjs.com/package/micromatch.`
              )
            ) // Validate that all dependents of ignored packages are listed in the ignore list

            const dependentsGraph =
              getDependentsGraph.getDependentsGraph(packages)

            for (const ignoredPackage of json.ignore) {
              const dependents = dependentsGraph.get(ignoredPackage) || []

              for (const dependent of dependents) {
                if (!json.ignore.includes(dependent)) {
                  messages.push(
                    `The package "${dependent}" depends on the ignored package "${ignoredPackage}", but "${dependent}" is not being ignored. Please add "${dependent}" to the \`ignore\` option.`
                  )
                }
              }
            }
          }
        }

        const { snapshot } = json

        if (snapshot !== undefined) {
          if (
            snapshot.useCalculatedVersion !== undefined &&
            typeof snapshot.useCalculatedVersion !== 'boolean'
          ) {
            messages.push(
              `The \`snapshot.useCalculatedVersion\` option is set as ${JSON.stringify(
                snapshot.useCalculatedVersion,
                null,
                2
              )} when the only valid values are undefined or a boolean`
            )
          }

          if (
            snapshot.prereleaseTemplate !== undefined &&
            typeof snapshot.prereleaseTemplate !== 'string'
          ) {
            messages.push(
              `The \`snapshot.prereleaseTemplate\` option is set as ${JSON.stringify(
                snapshot.prereleaseTemplate,
                null,
                2
              )} when the only valid values are undefined, or a template string.`
            )
          }
        }

        if (
          json.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH !== undefined
        ) {
          const {
            onlyUpdatePeerDependentsWhenOutOfRange,
            updateInternalDependents,
            useCalculatedVersionForSnapshots,
          } = json.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH

          if (
            onlyUpdatePeerDependentsWhenOutOfRange !== undefined &&
            typeof onlyUpdatePeerDependentsWhenOutOfRange !== 'boolean'
          ) {
            messages.push(
              `The \`onlyUpdatePeerDependentsWhenOutOfRange\` option is set as ${JSON.stringify(
                onlyUpdatePeerDependentsWhenOutOfRange,
                null,
                2
              )} when the only valid values are undefined or a boolean`
            )
          }

          if (
            updateInternalDependents !== undefined &&
            !['always', 'out-of-range'].includes(updateInternalDependents)
          ) {
            messages.push(
              `The \`updateInternalDependents\` option is set as ${JSON.stringify(
                updateInternalDependents,
                null,
                2
              )} but can only be 'always' or 'out-of-range'`
            )
          }

          if (
            useCalculatedVersionForSnapshots &&
            useCalculatedVersionForSnapshots !== undefined
          ) {
            console.warn(
              `Experimental flag "useCalculatedVersionForSnapshots" is deprecated since snapshot feature became stable. Please use "snapshot.useCalculatedVersion" instead.`
            )

            if (typeof useCalculatedVersionForSnapshots !== 'boolean') {
              messages.push(
                `The \`useCalculatedVersionForSnapshots\` option is set as ${JSON.stringify(
                  useCalculatedVersionForSnapshots,
                  null,
                  2
                )} when the only valid values are undefined or a boolean`
              )
            }
          }
        }

        if (messages.length) {
          throw new errors.ValidationError(
            `Some errors occurred when validating the changesets config:\n` +
              messages.join('\n')
          )
        }

        let config = {
          changelog: getNormalizedChangelogOption(
            json.changelog === undefined
              ? defaultWrittenConfig.changelog
              : json.changelog
          ),
          access:
            normalizedAccess === undefined
              ? defaultWrittenConfig.access
              : normalizedAccess,
          commit: getNormalizedCommitOption(
            json.commit === undefined
              ? defaultWrittenConfig.commit
              : json.commit
          ),
          fixed,
          linked,
          baseBranch:
            json.baseBranch === undefined
              ? defaultWrittenConfig.baseBranch
              : json.baseBranch,
          changedFilePatterns:
            (_json$changedFilePatt = json.changedFilePatterns) !== null &&
            _json$changedFilePatt !== void 0
              ? _json$changedFilePatt
              : ['**'],
          updateInternalDependencies:
            json.updateInternalDependencies === undefined
              ? defaultWrittenConfig.updateInternalDependencies
              : json.updateInternalDependencies,
          ignore:
            json.ignore === undefined
              ? defaultWrittenConfig.ignore
              : micromatch__default['default'](pkgNames, json.ignore),
          bumpVersionsWithWorkspaceProtocolOnly:
            json.bumpVersionsWithWorkspaceProtocolOnly === true,
          snapshot: {
            prereleaseTemplate:
              (_json$snapshot$prerel =
                (_json$snapshot = json.snapshot) === null ||
                _json$snapshot === void 0
                  ? void 0
                  : _json$snapshot.prereleaseTemplate) !== null &&
              _json$snapshot$prerel !== void 0
                ? _json$snapshot$prerel
                : null,
            useCalculatedVersion:
              ((_json$snapshot2 = json.snapshot) === null ||
              _json$snapshot2 === void 0
                ? void 0
                : _json$snapshot2.useCalculatedVersion) !== undefined
                ? json.snapshot.useCalculatedVersion
                : ((_json$___experimental =
                    json.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH) ===
                    null || _json$___experimental === void 0
                    ? void 0
                    : _json$___experimental.useCalculatedVersionForSnapshots) !==
                  undefined
                ? (_json$___experimental2 =
                    json.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH) ===
                    null || _json$___experimental2 === void 0
                  ? void 0
                  : _json$___experimental2.useCalculatedVersionForSnapshots
                : false,
          },
          ___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH: {
            onlyUpdatePeerDependentsWhenOutOfRange:
              json.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH ===
                undefined ||
              json.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH
                .onlyUpdatePeerDependentsWhenOutOfRange === undefined
                ? false
                : json.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH
                    .onlyUpdatePeerDependentsWhenOutOfRange,
            updateInternalDependents:
              (_json$___experimental3 =
                (_json$___experimental4 =
                  json.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH) ===
                  null || _json$___experimental4 === void 0
                  ? void 0
                  : _json$___experimental4.updateInternalDependents) !== null &&
              _json$___experimental3 !== void 0
                ? _json$___experimental3
                : 'out-of-range',
          },
          // TODO consider enabling this by default in the next major version
          privatePackages:
            json.privatePackages === false
              ? {
                  tag: false,
                  version: false,
                }
              : json.privatePackages
              ? {
                  version:
                    (_json$privatePackages = json.privatePackages.version) !==
                      null && _json$privatePackages !== void 0
                      ? _json$privatePackages
                      : true,
                  tag:
                    (_json$privatePackages2 = json.privatePackages.tag) !==
                      null && _json$privatePackages2 !== void 0
                      ? _json$privatePackages2
                      : false,
                }
              : {
                  version: true,
                  tag: false,
                },
        }

        if (
          config.privatePackages.version === false &&
          config.privatePackages.tag === true
        ) {
          throw new errors.ValidationError(
            `The \`privatePackages.tag\` option is set to \`true\` but \`privatePackages.version\` is set to \`false\`. This is not allowed.`
          )
        }

        return config
      }
      let fakePackage = {
        dir: '',
        packageJson: {
          name: '',
          version: '',
        },
      }
      let defaultConfig = parse(defaultWrittenConfig, {
        root: fakePackage,
        tool: 'root',
        packages: [fakePackage],
      })

      exports.defaultConfig = defaultConfig
      exports.defaultWrittenConfig = defaultWrittenConfig
      exports.parse = parse
      exports.read = read

      /***/
    },

    /***/ 3355: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      if (process.env.NODE_ENV === 'production') {
        module.exports = __nccwpck_require__(1751)
      } else {
        module.exports = __nccwpck_require__(7684)
      }

      /***/
    },

    /***/ 1751: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: !0,
      })

      var fs = __nccwpck_require__(5630),
        path = __nccwpck_require__(1017),
        micromatch = __nccwpck_require__(6228),
        errors = __nccwpck_require__(6740),
        logger = __nccwpck_require__(6010),
        getDependentsGraph = __nccwpck_require__(935)

      function _interopDefault(e) {
        return e && e.__esModule
          ? e
          : {
              default: e,
            }
      }

      var path__default = _interopDefault(path),
        micromatch__default = _interopDefault(micromatch),
        packageJson = {
          name: '@changesets/config',
          version: '2.3.0',
          description: "Utilities for reading and parsing Changeset's config",
          main: 'dist/config.cjs.js',
          module: 'dist/config.esm.js',
          license: 'MIT',
          repository:
            'https://github.com/changesets/changesets/tree/main/packages/config',
          files: ['dist', 'schema.json'],
          dependencies: {
            '@changesets/errors': '^0.1.4',
            '@changesets/get-dependents-graph': '^1.3.5',
            '@changesets/logger': '^0.0.5',
            '@changesets/types': '^5.2.1',
            '@manypkg/get-packages': '^1.1.3',
            'fs-extra': '^7.0.1',
            micromatch: '^4.0.2',
          },
          devDependencies: {
            '@changesets/test-utils': '*',
            '@types/micromatch': '^4.0.1',
            'jest-in-case': '^1.0.2',
          },
        }

      let defaultWrittenConfig = {
        $schema: `https://unpkg.com/@changesets/config@${packageJson.version}/schema.json`,
        changelog: '@changesets/cli/changelog',
        commit: !1,
        fixed: [],
        linked: [],
        access: 'restricted',
        baseBranch: 'master',
        updateInternalDependencies: 'patch',
        ignore: [],
      }

      function flatten(arr) {
        return [].concat(...arr)
      }

      function getNormalizedChangelogOption(thing) {
        return (
          !1 !== thing && ('string' == typeof thing ? [thing, null] : thing)
        )
      }

      function getNormalizedCommitOption(thing) {
        return (
          !1 !== thing &&
          (!0 === thing
            ? [
                '@changesets/cli/commit',
                {
                  skipCI: 'version',
                },
              ]
            : 'string' == typeof thing
            ? [thing, null]
            : thing)
        )
      }

      function getUnmatchedPatterns(listOfPackageNamesOrGlob, pkgNames) {
        return listOfPackageNamesOrGlob.filter(
          pkgNameOrGlob =>
            !pkgNames.some(pkgName =>
              micromatch__default.default.isMatch(pkgName, pkgNameOrGlob)
            )
        )
      }

      const havePackageGroupsCorrectShape = pkgGroups =>
        isArray(pkgGroups) &&
        pkgGroups.every(
          arr =>
            isArray(arr) && arr.every(pkgName => 'string' == typeof pkgName)
        )

      function isArray(arg) {
        return Array.isArray(arg)
      }

      let read = async (cwd, packages) => {
          let json = await fs.readJSON(
            path__default.default.join(cwd, '.changeset', 'config.json')
          )
          return parse(json, packages)
        },
        parse = (json, packages) => {
          var _json$changedFilePatt,
            _json$snapshot$prerel,
            _json$snapshot,
            _json$snapshot2,
            _json$___experimental,
            _json$___experimental2,
            _json$___experimental3,
            _json$___experimental4,
            _json$privatePackages,
            _json$privatePackages2
          let messages = [],
            pkgNames = packages.packages.map(
              ({ packageJson: packageJson }) => packageJson.name
            )
          void 0 === json.changelog ||
            !1 === json.changelog ||
            'string' == typeof json.changelog ||
            (isArray(json.changelog) &&
              2 === json.changelog.length &&
              'string' == typeof json.changelog[0]) ||
            messages.push(
              `The \`changelog\` option is set as ${JSON.stringify(
                json.changelog,
                null,
                2
              )} when the only valid values are undefined, false, a module path(e.g. "@changesets/cli/changelog" or "./some-module") or a tuple with a module path and config for the changelog generator(e.g. ["@changesets/cli/changelog", { someOption: true }])`
            )
          let normalizedAccess = json.access
          'private' === json.access &&
            ((normalizedAccess = 'restricted'),
            logger.warn(
              'The `access` option is set as "private", but this is actually not a valid value - the correct form is "restricted".'
            )),
            void 0 !== normalizedAccess &&
              'restricted' !== normalizedAccess &&
              'public' !== normalizedAccess &&
              messages.push(
                `The \`access\` option is set as ${JSON.stringify(
                  normalizedAccess,
                  null,
                  2
                )} when the only valid values are undefined, "public" or "restricted"`
              ),
            void 0 === json.commit ||
              'boolean' == typeof json.commit ||
              'string' == typeof json.commit ||
              (isArray(json.commit) &&
                2 === json.commit.length &&
                'string' == typeof json.commit[0]) ||
              messages.push(
                `The \`commit\` option is set as ${JSON.stringify(
                  json.commit,
                  null,
                  2
                )} when the only valid values are undefined or a boolean or a module path (e.g. "@changesets/cli/commit" or "./some-module") or a tuple with a module path and config for the commit message generator (e.g. ["@changesets/cli/commit", { "skipCI": "version" }])`
              ),
            void 0 !== json.baseBranch &&
              'string' != typeof json.baseBranch &&
              messages.push(
                `The \`baseBranch\` option is set as ${JSON.stringify(
                  json.baseBranch,
                  null,
                  2
                )} but the \`baseBranch\` option can only be set as a string`
              ),
            void 0 === json.changedFilePatterns ||
              (isArray(json.changedFilePatterns) &&
                json.changedFilePatterns.every(
                  pattern => 'string' == typeof pattern
                )) ||
              messages.push(
                `The \`changedFilePatterns\` option is set as ${JSON.stringify(
                  json.changedFilePatterns,
                  null,
                  2
                )} but the \`changedFilePatterns\` option can only be set as an array of strings`
              )
          let fixed = []
          if (void 0 !== json.fixed)
            if (havePackageGroupsCorrectShape(json.fixed)) {
              let foundPkgNames = new Set(),
                duplicatedPkgNames = new Set()
              for (let fixedGroup of json.fixed) {
                messages.push(
                  ...getUnmatchedPatterns(fixedGroup, pkgNames).map(
                    pkgOrGlob =>
                      `The package or glob expression "${pkgOrGlob}" specified in the \`fixed\` option does not match any package in the project. You may have misspelled the package name or provided an invalid glob expression. Note that glob expressions must be defined according to https://www.npmjs.com/package/micromatch.`
                  )
                )
                let expandedFixedGroup = micromatch__default.default(
                  pkgNames,
                  fixedGroup
                )
                fixed.push(expandedFixedGroup)
                for (let fixedPkgName of expandedFixedGroup)
                  foundPkgNames.has(fixedPkgName) &&
                    duplicatedPkgNames.add(fixedPkgName),
                    foundPkgNames.add(fixedPkgName)
              }
              duplicatedPkgNames.size &&
                duplicatedPkgNames.forEach(pkgName => {
                  messages.push(
                    `The package "${pkgName}" is defined in multiple sets of fixed packages. Packages can only be defined in a single set of fixed packages. If you are using glob expressions, make sure that they are valid according to https://www.npmjs.com/package/micromatch.`
                  )
                })
            } else
              messages.push(
                `The \`fixed\` option is set as ${JSON.stringify(
                  json.fixed,
                  null,
                  2
                )} when the only valid values are undefined or an array of arrays of package names`
              )
          let linked = []
          if (void 0 !== json.linked)
            if (havePackageGroupsCorrectShape(json.linked)) {
              let foundPkgNames = new Set(),
                duplicatedPkgNames = new Set()
              for (let linkedGroup of json.linked) {
                messages.push(
                  ...getUnmatchedPatterns(linkedGroup, pkgNames).map(
                    pkgOrGlob =>
                      `The package or glob expression "${pkgOrGlob}" specified in the \`linked\` option does not match any package in the project. You may have misspelled the package name or provided an invalid glob expression. Note that glob expressions must be defined according to https://www.npmjs.com/package/micromatch.`
                  )
                )
                let expandedLinkedGroup = micromatch__default.default(
                  pkgNames,
                  linkedGroup
                )
                linked.push(expandedLinkedGroup)
                for (let linkedPkgName of expandedLinkedGroup)
                  foundPkgNames.has(linkedPkgName) &&
                    duplicatedPkgNames.add(linkedPkgName),
                    foundPkgNames.add(linkedPkgName)
              }
              duplicatedPkgNames.size &&
                duplicatedPkgNames.forEach(pkgName => {
                  messages.push(
                    `The package "${pkgName}" is defined in multiple sets of linked packages. Packages can only be defined in a single set of linked packages. If you are using glob expressions, make sure that they are valid according to https://www.npmjs.com/package/micromatch.`
                  )
                })
            } else
              messages.push(
                `The \`linked\` option is set as ${JSON.stringify(
                  json.linked,
                  null,
                  2
                )} when the only valid values are undefined or an array of arrays of package names`
              )
          const allFixedPackages = new Set(flatten(fixed)),
            allLinkedPackages = new Set(flatten(linked))
          if (
            (allFixedPackages.forEach(pkgName => {
              allLinkedPackages.has(pkgName) &&
                messages.push(
                  `The package "${pkgName}" can be found in both fixed and linked groups. A package can only be either fixed or linked.`
                )
            }),
            void 0 === json.updateInternalDependencies ||
              ['patch', 'minor'].includes(json.updateInternalDependencies) ||
              messages.push(
                `The \`updateInternalDependencies\` option is set as ${JSON.stringify(
                  json.updateInternalDependencies,
                  null,
                  2
                )} but can only be 'patch' or 'minor'`
              ),
            json.ignore)
          )
            if (
              isArray(json.ignore) &&
              json.ignore.every(pkgName => 'string' == typeof pkgName)
            ) {
              messages.push(
                ...getUnmatchedPatterns(json.ignore, pkgNames).map(
                  pkgOrGlob =>
                    `The package or glob expression "${pkgOrGlob}" is specified in the \`ignore\` option but it is not found in the project. You may have misspelled the package name or provided an invalid glob expression. Note that glob expressions must be defined according to https://www.npmjs.com/package/micromatch.`
                )
              )
              const dependentsGraph =
                getDependentsGraph.getDependentsGraph(packages)
              for (const ignoredPackage of json.ignore) {
                const dependents = dependentsGraph.get(ignoredPackage) || []
                for (const dependent of dependents)
                  json.ignore.includes(dependent) ||
                    messages.push(
                      `The package "${dependent}" depends on the ignored package "${ignoredPackage}", but "${dependent}" is not being ignored. Please add "${dependent}" to the \`ignore\` option.`
                    )
              }
            } else
              messages.push(
                `The \`ignore\` option is set as ${JSON.stringify(
                  json.ignore,
                  null,
                  2
                )} when the only valid values are undefined or an array of package names`
              )
          const { snapshot: snapshot } = json
          if (
            (void 0 !== snapshot &&
              (void 0 !== snapshot.useCalculatedVersion &&
                'boolean' != typeof snapshot.useCalculatedVersion &&
                messages.push(
                  `The \`snapshot.useCalculatedVersion\` option is set as ${JSON.stringify(
                    snapshot.useCalculatedVersion,
                    null,
                    2
                  )} when the only valid values are undefined or a boolean`
                ),
              void 0 !== snapshot.prereleaseTemplate &&
                'string' != typeof snapshot.prereleaseTemplate &&
                messages.push(
                  `The \`snapshot.prereleaseTemplate\` option is set as ${JSON.stringify(
                    snapshot.prereleaseTemplate,
                    null,
                    2
                  )} when the only valid values are undefined, or a template string.`
                )),
            void 0 !== json.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH)
          ) {
            const {
              onlyUpdatePeerDependentsWhenOutOfRange:
                onlyUpdatePeerDependentsWhenOutOfRange,
              updateInternalDependents: updateInternalDependents,
              useCalculatedVersionForSnapshots:
                useCalculatedVersionForSnapshots,
            } = json.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH
            void 0 !== onlyUpdatePeerDependentsWhenOutOfRange &&
              'boolean' != typeof onlyUpdatePeerDependentsWhenOutOfRange &&
              messages.push(
                `The \`onlyUpdatePeerDependentsWhenOutOfRange\` option is set as ${JSON.stringify(
                  onlyUpdatePeerDependentsWhenOutOfRange,
                  null,
                  2
                )} when the only valid values are undefined or a boolean`
              ),
              void 0 === updateInternalDependents ||
                ['always', 'out-of-range'].includes(updateInternalDependents) ||
                messages.push(
                  `The \`updateInternalDependents\` option is set as ${JSON.stringify(
                    updateInternalDependents,
                    null,
                    2
                  )} but can only be 'always' or 'out-of-range'`
                ),
              useCalculatedVersionForSnapshots &&
                void 0 !== useCalculatedVersionForSnapshots &&
                (console.warn(
                  'Experimental flag "useCalculatedVersionForSnapshots" is deprecated since snapshot feature became stable. Please use "snapshot.useCalculatedVersion" instead.'
                ),
                'boolean' != typeof useCalculatedVersionForSnapshots &&
                  messages.push(
                    `The \`useCalculatedVersionForSnapshots\` option is set as ${JSON.stringify(
                      useCalculatedVersionForSnapshots,
                      null,
                      2
                    )} when the only valid values are undefined or a boolean`
                  ))
          }
          if (messages.length)
            throw new errors.ValidationError(
              'Some errors occurred when validating the changesets config:\n' +
                messages.join('\n')
            )
          let config = {
            changelog: getNormalizedChangelogOption(
              void 0 === json.changelog
                ? defaultWrittenConfig.changelog
                : json.changelog
            ),
            access:
              void 0 === normalizedAccess
                ? defaultWrittenConfig.access
                : normalizedAccess,
            commit: getNormalizedCommitOption(
              void 0 === json.commit ? defaultWrittenConfig.commit : json.commit
            ),
            fixed: fixed,
            linked: linked,
            baseBranch:
              void 0 === json.baseBranch
                ? defaultWrittenConfig.baseBranch
                : json.baseBranch,
            changedFilePatterns:
              null !== (_json$changedFilePatt = json.changedFilePatterns) &&
              void 0 !== _json$changedFilePatt
                ? _json$changedFilePatt
                : ['**'],
            updateInternalDependencies:
              void 0 === json.updateInternalDependencies
                ? defaultWrittenConfig.updateInternalDependencies
                : json.updateInternalDependencies,
            ignore:
              void 0 === json.ignore
                ? defaultWrittenConfig.ignore
                : micromatch__default.default(pkgNames, json.ignore),
            bumpVersionsWithWorkspaceProtocolOnly:
              !0 === json.bumpVersionsWithWorkspaceProtocolOnly,
            snapshot: {
              prereleaseTemplate:
                null !==
                  (_json$snapshot$prerel =
                    null === (_json$snapshot = json.snapshot) ||
                    void 0 === _json$snapshot
                      ? void 0
                      : _json$snapshot.prereleaseTemplate) &&
                void 0 !== _json$snapshot$prerel
                  ? _json$snapshot$prerel
                  : null,
              useCalculatedVersion:
                void 0 !==
                (null === (_json$snapshot2 = json.snapshot) ||
                void 0 === _json$snapshot2
                  ? void 0
                  : _json$snapshot2.useCalculatedVersion)
                  ? json.snapshot.useCalculatedVersion
                  : void 0 !==
                      (null ===
                        (_json$___experimental =
                          json.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH) ||
                      void 0 === _json$___experimental
                        ? void 0
                        : _json$___experimental.useCalculatedVersionForSnapshots) &&
                    (null ===
                      (_json$___experimental2 =
                        json.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH) ||
                    void 0 === _json$___experimental2
                      ? void 0
                      : _json$___experimental2.useCalculatedVersionForSnapshots),
            },
            ___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH: {
              onlyUpdatePeerDependentsWhenOutOfRange:
                void 0 !==
                  json.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH &&
                void 0 !==
                  json.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH
                    .onlyUpdatePeerDependentsWhenOutOfRange &&
                json.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH
                  .onlyUpdatePeerDependentsWhenOutOfRange,
              updateInternalDependents:
                null !==
                  (_json$___experimental3 =
                    null ===
                      (_json$___experimental4 =
                        json.___experimentalUnsafeOptions_WILL_CHANGE_IN_PATCH) ||
                    void 0 === _json$___experimental4
                      ? void 0
                      : _json$___experimental4.updateInternalDependents) &&
                void 0 !== _json$___experimental3
                  ? _json$___experimental3
                  : 'out-of-range',
            },
            privatePackages:
              !1 === json.privatePackages
                ? {
                    tag: !1,
                    version: !1,
                  }
                : json.privatePackages
                ? {
                    version:
                      null ===
                        (_json$privatePackages =
                          json.privatePackages.version) ||
                      void 0 === _json$privatePackages ||
                      _json$privatePackages,
                    tag:
                      null !==
                        (_json$privatePackages2 = json.privatePackages.tag) &&
                      void 0 !== _json$privatePackages2 &&
                      _json$privatePackages2,
                  }
                : {
                    version: !0,
                    tag: !1,
                  },
          }
          if (
            !1 === config.privatePackages.version &&
            !0 === config.privatePackages.tag
          )
            throw new errors.ValidationError(
              'The `privatePackages.tag` option is set to `true` but `privatePackages.version` is set to `false`. This is not allowed.'
            )
          return config
        },
        fakePackage = {
          dir: '',
          packageJson: {
            name: '',
            version: '',
          },
        },
        defaultConfig = parse(defaultWrittenConfig, {
          root: fakePackage,
          tool: 'root',
          packages: [fakePackage],
        })

      ;(exports.defaultConfig = defaultConfig),
        (exports.defaultWrittenConfig = defaultWrittenConfig),
        (exports.parse = parse),
        (exports.read = read)

      /***/
    },

    /***/ 2274: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })

      function _interopDefault(ex) {
        return ex && typeof ex === 'object' && 'default' in ex
          ? ex['default']
          : ex
      }

      var ExtendableError = _interopDefault(__nccwpck_require__(8355))

      class GitError extends ExtendableError {
        constructor(code, message) {
          super(`${message}, exit code: ${code}`)
          this.code = code
        }
      }
      class ValidationError extends ExtendableError {}
      class ExitError extends ExtendableError {
        constructor(code) {
          super(`The process exited with code: ${code}`)
          this.code = code
        }
      }
      class PreExitButNotInPreModeError extends ExtendableError {
        constructor() {
          super('pre mode cannot be exited when not in pre mode')
        }
      }
      class PreEnterButInPreModeError extends ExtendableError {
        constructor() {
          super('pre mode cannot be entered when in pre mode')
        }
      }
      class InternalError extends ExtendableError {
        constructor(message) {
          super(message)
        }
      }

      exports.ExitError = ExitError
      exports.GitError = GitError
      exports.InternalError = InternalError
      exports.PreEnterButInPreModeError = PreEnterButInPreModeError
      exports.PreExitButNotInPreModeError = PreExitButNotInPreModeError
      exports.ValidationError = ValidationError

      /***/
    },

    /***/ 6740: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      if (process.env.NODE_ENV === 'production') {
        module.exports = __nccwpck_require__(6706)
      } else {
        module.exports = __nccwpck_require__(2274)
      }

      /***/
    },

    /***/ 6706: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      function _interopDefault(ex) {
        return ex && 'object' == typeof ex && 'default' in ex ? ex.default : ex
      }

      Object.defineProperty(exports, '__esModule', {
        value: !0,
      })

      var ExtendableError = _interopDefault(__nccwpck_require__(8355))

      class GitError extends ExtendableError {
        constructor(code, message) {
          super(`${message}, exit code: ${code}`), (this.code = code)
        }
      }

      class ValidationError extends ExtendableError {}

      class ExitError extends ExtendableError {
        constructor(code) {
          super(`The process exited with code: ${code}`), (this.code = code)
        }
      }

      class PreExitButNotInPreModeError extends ExtendableError {
        constructor() {
          super('pre mode cannot be exited when not in pre mode')
        }
      }

      class PreEnterButInPreModeError extends ExtendableError {
        constructor() {
          super('pre mode cannot be entered when in pre mode')
        }
      }

      class InternalError extends ExtendableError {
        constructor(message) {
          super(message)
        }
      }

      ;(exports.ExitError = ExitError),
        (exports.GitError = GitError),
        (exports.InternalError = InternalError),
        (exports.PreEnterButInPreModeError = PreEnterButInPreModeError),
        (exports.PreExitButNotInPreModeError = PreExitButNotInPreModeError),
        (exports.ValidationError = ValidationError)

      /***/
    },

    /***/ 4509: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })

      var semver = __nccwpck_require__(9075)
      var chalk = __nccwpck_require__(1568)

      function _interopDefault(e) {
        return e && e.__esModule ? e : { default: e }
      }

      var semver__default = /*#__PURE__*/ _interopDefault(semver)
      var chalk__default = /*#__PURE__*/ _interopDefault(chalk)

      // This is a modified version of the graph-getting in bolt
      const DEPENDENCY_TYPES = [
        'dependencies',
        'devDependencies',
        'peerDependencies',
        'optionalDependencies',
      ]

      const getAllDependencies = config => {
        const allDependencies = new Map()

        for (const type of DEPENDENCY_TYPES) {
          const deps = config[type]
          if (!deps) continue

          for (const name of Object.keys(deps)) {
            const depRange = deps[name]

            if (
              (depRange.startsWith('link:') || depRange.startsWith('file:')) &&
              type === 'devDependencies'
            ) {
              continue
            }

            allDependencies.set(name, depRange)
          }
        }

        return allDependencies
      }

      const isProtocolRange = range => range.indexOf(':') !== -1

      const getValidRange = potentialRange => {
        if (isProtocolRange(potentialRange)) {
          return null
        }

        try {
          return new semver__default['default'].Range(potentialRange)
        } catch (_unused) {
          return null
        }
      }

      function getDependencyGraph(packages, opts) {
        const graph = new Map()
        let valid = true
        const packagesByName = {
          [packages.root.packageJson.name]: packages.root,
        }
        const queue = [packages.root]

        for (const pkg of packages.packages) {
          queue.push(pkg)
          packagesByName[pkg.packageJson.name] = pkg
        }

        for (const pkg of queue) {
          const { name } = pkg.packageJson
          const dependencies = []
          const allDependencies = getAllDependencies(pkg.packageJson)

          for (let [depName, depRange] of allDependencies) {
            const match = packagesByName[depName]
            if (!match) continue
            const expected = match.packageJson.version
            const usesWorkspaceRange = depRange.startsWith('workspace:')

            if (usesWorkspaceRange) {
              depRange = depRange.replace(/^workspace:/, '')

              if (depRange === '*' || depRange === '^' || depRange === '~') {
                dependencies.push(depName)
                continue
              }
            } else if (
              (opts === null || opts === void 0
                ? void 0
                : opts.bumpVersionsWithWorkspaceProtocolOnly) === true
            ) {
              continue
            }

            const range = getValidRange(depRange)

            if ((range && !range.test(expected)) || isProtocolRange(depRange)) {
              valid = false
              console.error(
                `Package ${chalk__default['default'].cyan(
                  `"${name}"`
                )} must depend on the current version of ${chalk__default[
                  'default'
                ].cyan(`"${depName}"`)}: ${chalk__default['default'].green(
                  `"${expected}"`
                )} vs ${chalk__default['default'].red(`"${depRange}"`)}`
              )
              continue
            } // `depRange` could have been a tag and if a tag has been used there might have been a reason for that
            // we should not count this as a local monorepro dependant

            if (!range) {
              continue
            }

            dependencies.push(depName)
          }

          graph.set(name, {
            pkg,
            dependencies,
          })
        }

        return {
          graph,
          valid,
        }
      }

      function getDependentsGraph(packages, opts) {
        const graph = new Map()
        const { graph: dependencyGraph } = getDependencyGraph(packages, {
          bumpVersionsWithWorkspaceProtocolOnly:
            (opts === null || opts === void 0
              ? void 0
              : opts.bumpVersionsWithWorkspaceProtocolOnly) === true,
        })
        const dependentsLookup = {}
        packages.packages.forEach(pkg => {
          dependentsLookup[pkg.packageJson.name] = {
            pkg,
            dependents: [],
          }
        })
        packages.packages.forEach(pkg => {
          const dependent = pkg.packageJson.name
          const valFromDependencyGraph = dependencyGraph.get(dependent)

          if (valFromDependencyGraph) {
            const dependencies = valFromDependencyGraph.dependencies
            dependencies.forEach(dependency => {
              dependentsLookup[dependency].dependents.push(dependent)
            })
          }
        })
        Object.keys(dependentsLookup).forEach(key => {
          graph.set(key, dependentsLookup[key])
        })
        const simplifiedDependentsGraph = new Map()
        graph.forEach((pkgInfo, pkgName) => {
          simplifiedDependentsGraph.set(pkgName, pkgInfo.dependents)
        })
        return simplifiedDependentsGraph
      }

      exports.getDependentsGraph = getDependentsGraph

      /***/
    },

    /***/ 935: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      if (process.env.NODE_ENV === 'production') {
        module.exports = __nccwpck_require__(1151)
      } else {
        module.exports = __nccwpck_require__(4509)
      }

      /***/
    },

    /***/ 1151: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: !0,
      })

      var semver = __nccwpck_require__(9075),
        chalk = __nccwpck_require__(1568)

      function _interopDefault(e) {
        return e && e.__esModule
          ? e
          : {
              default: e,
            }
      }

      var semver__default = _interopDefault(semver),
        chalk__default = _interopDefault(chalk)

      const DEPENDENCY_TYPES = [
          'dependencies',
          'devDependencies',
          'peerDependencies',
          'optionalDependencies',
        ],
        getAllDependencies = config => {
          const allDependencies = new Map()
          for (const type of DEPENDENCY_TYPES) {
            const deps = config[type]
            if (deps)
              for (const name of Object.keys(deps)) {
                const depRange = deps[name]
                ;((depRange.startsWith('link:') ||
                  depRange.startsWith('file:')) &&
                  'devDependencies' === type) ||
                  allDependencies.set(name, depRange)
              }
          }
          return allDependencies
        },
        isProtocolRange = range => -1 !== range.indexOf(':'),
        getValidRange = potentialRange => {
          if (isProtocolRange(potentialRange)) return null
          try {
            return new semver__default.default.Range(potentialRange)
          } catch (_unused) {
            return null
          }
        }

      function getDependencyGraph(packages, opts) {
        const graph = new Map()
        let valid = !0
        const packagesByName = {
            [packages.root.packageJson.name]: packages.root,
          },
          queue = [packages.root]
        for (const pkg of packages.packages)
          queue.push(pkg), (packagesByName[pkg.packageJson.name] = pkg)
        for (const pkg of queue) {
          const { name: name } = pkg.packageJson,
            dependencies = [],
            allDependencies = getAllDependencies(pkg.packageJson)
          for (let [depName, depRange] of allDependencies) {
            const match = packagesByName[depName]
            if (!match) continue
            const expected = match.packageJson.version
            if (depRange.startsWith('workspace:')) {
              if (
                ((depRange = depRange.replace(/^workspace:/, '')),
                '*' === depRange || '^' === depRange || '~' === depRange)
              ) {
                dependencies.push(depName)
                continue
              }
            } else if (
              !0 ===
              (null == opts
                ? void 0
                : opts.bumpVersionsWithWorkspaceProtocolOnly)
            )
              continue
            const range = getValidRange(depRange)
            ;(range && !range.test(expected)) || isProtocolRange(depRange)
              ? ((valid = !1),
                console.error(
                  `Package ${chalk__default.default.cyan(
                    `"${name}"`
                  )} must depend on the current version of ${chalk__default.default.cyan(
                    `"${depName}"`
                  )}: ${chalk__default.default.green(
                    `"${expected}"`
                  )} vs ${chalk__default.default.red(`"${depRange}"`)}`
                ))
              : range && dependencies.push(depName)
          }
          graph.set(name, {
            pkg: pkg,
            dependencies: dependencies,
          })
        }
        return {
          graph: graph,
          valid: valid,
        }
      }

      function getDependentsGraph(packages, opts) {
        const graph = new Map(),
          { graph: dependencyGraph } = getDependencyGraph(packages, {
            bumpVersionsWithWorkspaceProtocolOnly:
              !0 ===
              (null == opts
                ? void 0
                : opts.bumpVersionsWithWorkspaceProtocolOnly),
          }),
          dependentsLookup = {}
        packages.packages.forEach(pkg => {
          dependentsLookup[pkg.packageJson.name] = {
            pkg: pkg,
            dependents: [],
          }
        }),
          packages.packages.forEach(pkg => {
            const dependent = pkg.packageJson.name,
              valFromDependencyGraph = dependencyGraph.get(dependent)
            if (valFromDependencyGraph) {
              valFromDependencyGraph.dependencies.forEach(dependency => {
                dependentsLookup[dependency].dependents.push(dependent)
              })
            }
          }),
          Object.keys(dependentsLookup).forEach(key => {
            graph.set(key, dependentsLookup[key])
          })
        const simplifiedDependentsGraph = new Map()
        return (
          graph.forEach((pkgInfo, pkgName) => {
            simplifiedDependentsGraph.set(pkgName, pkgInfo.dependents)
          }),
          simplifiedDependentsGraph
        )
      }

      exports.getDependentsGraph = getDependentsGraph

      /***/
    },

    /***/ 2564: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'
      /* module decorator */ module = __nccwpck_require__.nmd(module)

      const colorConvert = __nccwpck_require__(3596)

      const wrapAnsi16 = (fn, offset) =>
        function () {
          const code = fn.apply(colorConvert, arguments)
          return `\u001B[${code + offset}m`
        }

      const wrapAnsi256 = (fn, offset) =>
        function () {
          const code = fn.apply(colorConvert, arguments)
          return `\u001B[${38 + offset};5;${code}m`
        }

      const wrapAnsi16m = (fn, offset) =>
        function () {
          const rgb = fn.apply(colorConvert, arguments)
          return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`
        }

      function assembleStyles() {
        const codes = new Map()
        const styles = {
          modifier: {
            reset: [0, 0],
            // 21 isn't widely supported and 22 does the same thing
            bold: [1, 22],
            dim: [2, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            hidden: [8, 28],
            strikethrough: [9, 29],
          },
          color: {
            black: [30, 39],
            red: [31, 39],
            green: [32, 39],
            yellow: [33, 39],
            blue: [34, 39],
            magenta: [35, 39],
            cyan: [36, 39],
            white: [37, 39],
            gray: [90, 39],

            // Bright color
            redBright: [91, 39],
            greenBright: [92, 39],
            yellowBright: [93, 39],
            blueBright: [94, 39],
            magentaBright: [95, 39],
            cyanBright: [96, 39],
            whiteBright: [97, 39],
          },
          bgColor: {
            bgBlack: [40, 49],
            bgRed: [41, 49],
            bgGreen: [42, 49],
            bgYellow: [43, 49],
            bgBlue: [44, 49],
            bgMagenta: [45, 49],
            bgCyan: [46, 49],
            bgWhite: [47, 49],

            // Bright color
            bgBlackBright: [100, 49],
            bgRedBright: [101, 49],
            bgGreenBright: [102, 49],
            bgYellowBright: [103, 49],
            bgBlueBright: [104, 49],
            bgMagentaBright: [105, 49],
            bgCyanBright: [106, 49],
            bgWhiteBright: [107, 49],
          },
        }

        // Fix humans
        styles.color.grey = styles.color.gray

        for (const groupName of Object.keys(styles)) {
          const group = styles[groupName]

          for (const styleName of Object.keys(group)) {
            const style = group[styleName]

            styles[styleName] = {
              open: `\u001B[${style[0]}m`,
              close: `\u001B[${style[1]}m`,
            }

            group[styleName] = styles[styleName]

            codes.set(style[0], style[1])
          }

          Object.defineProperty(styles, groupName, {
            value: group,
            enumerable: false,
          })

          Object.defineProperty(styles, 'codes', {
            value: codes,
            enumerable: false,
          })
        }

        const ansi2ansi = n => n
        const rgb2rgb = (r, g, b) => [r, g, b]

        styles.color.close = '\u001B[39m'
        styles.bgColor.close = '\u001B[49m'

        styles.color.ansi = {
          ansi: wrapAnsi16(ansi2ansi, 0),
        }
        styles.color.ansi256 = {
          ansi256: wrapAnsi256(ansi2ansi, 0),
        }
        styles.color.ansi16m = {
          rgb: wrapAnsi16m(rgb2rgb, 0),
        }

        styles.bgColor.ansi = {
          ansi: wrapAnsi16(ansi2ansi, 10),
        }
        styles.bgColor.ansi256 = {
          ansi256: wrapAnsi256(ansi2ansi, 10),
        }
        styles.bgColor.ansi16m = {
          rgb: wrapAnsi16m(rgb2rgb, 10),
        }

        for (let key of Object.keys(colorConvert)) {
          if (typeof colorConvert[key] !== 'object') {
            continue
          }

          const suite = colorConvert[key]

          if (key === 'ansi16') {
            key = 'ansi'
          }

          if ('ansi16' in suite) {
            styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0)
            styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10)
          }

          if ('ansi256' in suite) {
            styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0)
            styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10)
          }

          if ('rgb' in suite) {
            styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0)
            styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10)
          }
        }

        return styles
      }

      // Make the export immutable
      Object.defineProperty(module, 'exports', {
        enumerable: true,
        get: assembleStyles,
      })

      /***/
    },

    /***/ 1568: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const escapeStringRegexp = __nccwpck_require__(8691)
      const ansiStyles = __nccwpck_require__(2564)
      const stdoutColor = __nccwpck_require__(6571).stdout

      const template = __nccwpck_require__(2593)

      const isSimpleWindowsTerm =
        process.platform === 'win32' &&
        !(process.env.TERM || '').toLowerCase().startsWith('xterm')

      // `supportsColor.level` → `ansiStyles.color[name]` mapping
      const levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m']

      // `color-convert` models to exclude from the Chalk API due to conflicts and such
      const skipModels = new Set(['gray'])

      const styles = Object.create(null)

      function applyOptions(obj, options) {
        options = options || {}

        // Detect level if not set manually
        const scLevel = stdoutColor ? stdoutColor.level : 0
        obj.level = options.level === undefined ? scLevel : options.level
        obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0
      }

      function Chalk(options) {
        // We check for this.template here since calling `chalk.constructor()`
        // by itself will have a `this` of a previously constructed chalk object
        if (!this || !(this instanceof Chalk) || this.template) {
          const chalk = {}
          applyOptions(chalk, options)

          chalk.template = function () {
            const args = [].slice.call(arguments)
            return chalkTag.apply(null, [chalk.template].concat(args))
          }

          Object.setPrototypeOf(chalk, Chalk.prototype)
          Object.setPrototypeOf(chalk.template, chalk)

          chalk.template.constructor = Chalk

          return chalk.template
        }

        applyOptions(this, options)
      }

      // Use bright blue on Windows as the normal blue color is illegible
      if (isSimpleWindowsTerm) {
        ansiStyles.blue.open = '\u001B[94m'
      }

      for (const key of Object.keys(ansiStyles)) {
        ansiStyles[key].closeRe = new RegExp(
          escapeStringRegexp(ansiStyles[key].close),
          'g'
        )

        styles[key] = {
          get() {
            const codes = ansiStyles[key]
            return build.call(
              this,
              this._styles ? this._styles.concat(codes) : [codes],
              this._empty,
              key
            )
          },
        }
      }

      styles.visible = {
        get() {
          return build.call(this, this._styles || [], true, 'visible')
        },
      }

      ansiStyles.color.closeRe = new RegExp(
        escapeStringRegexp(ansiStyles.color.close),
        'g'
      )
      for (const model of Object.keys(ansiStyles.color.ansi)) {
        if (skipModels.has(model)) {
          continue
        }

        styles[model] = {
          get() {
            const level = this.level
            return function () {
              const open = ansiStyles.color[levelMapping[level]][model].apply(
                null,
                arguments
              )
              const codes = {
                open,
                close: ansiStyles.color.close,
                closeRe: ansiStyles.color.closeRe,
              }
              return build.call(
                this,
                this._styles ? this._styles.concat(codes) : [codes],
                this._empty,
                model
              )
            }
          },
        }
      }

      ansiStyles.bgColor.closeRe = new RegExp(
        escapeStringRegexp(ansiStyles.bgColor.close),
        'g'
      )
      for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
        if (skipModels.has(model)) {
          continue
        }

        const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1)
        styles[bgModel] = {
          get() {
            const level = this.level
            return function () {
              const open = ansiStyles.bgColor[levelMapping[level]][model].apply(
                null,
                arguments
              )
              const codes = {
                open,
                close: ansiStyles.bgColor.close,
                closeRe: ansiStyles.bgColor.closeRe,
              }
              return build.call(
                this,
                this._styles ? this._styles.concat(codes) : [codes],
                this._empty,
                model
              )
            }
          },
        }
      }

      const proto = Object.defineProperties(() => {}, styles)

      function build(_styles, _empty, key) {
        const builder = function () {
          return applyStyle.apply(builder, arguments)
        }

        builder._styles = _styles
        builder._empty = _empty

        const self = this

        Object.defineProperty(builder, 'level', {
          enumerable: true,
          get() {
            return self.level
          },
          set(level) {
            self.level = level
          },
        })

        Object.defineProperty(builder, 'enabled', {
          enumerable: true,
          get() {
            return self.enabled
          },
          set(enabled) {
            self.enabled = enabled
          },
        })

        // See below for fix regarding invisible grey/dim combination on Windows
        builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey'

        // `__proto__` is used because we must return a function, but there is
        // no way to create a function with a different prototype
        builder.__proto__ = proto // eslint-disable-line no-proto

        return builder
      }

      function applyStyle() {
        // Support varags, but simply cast to string in case there's only one arg
        const args = arguments
        const argsLen = args.length
        let str = String(arguments[0])

        if (argsLen === 0) {
          return ''
        }

        if (argsLen > 1) {
          // Don't slice `arguments`, it prevents V8 optimizations
          for (let a = 1; a < argsLen; a++) {
            str += ' ' + args[a]
          }
        }

        if (!this.enabled || this.level <= 0 || !str) {
          return this._empty ? '' : str
        }

        // Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
        // see https://github.com/chalk/chalk/issues/58
        // If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
        const originalDim = ansiStyles.dim.open
        if (isSimpleWindowsTerm && this.hasGrey) {
          ansiStyles.dim.open = ''
        }

        for (const code of this._styles.slice().reverse()) {
          // Replace any instances already present with a re-opening code
          // otherwise only the part of the string until said closing code
          // will be colored, and the rest will simply be 'plain'.
          str = code.open + str.replace(code.closeRe, code.open) + code.close

          // Close the styling before a linebreak and reopen
          // after next line to fix a bleed issue on macOS
          // https://github.com/chalk/chalk/pull/92
          str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`)
        }

        // Reset the original `dim` if we changed it to work around the Windows dimmed gray issue
        ansiStyles.dim.open = originalDim

        return str
      }

      function chalkTag(chalk, strings) {
        if (!Array.isArray(strings)) {
          // If chalk() was called by itself or with a string,
          // return the string itself as a string.
          return [].slice.call(arguments, 1).join(' ')
        }

        const args = [].slice.call(arguments, 2)
        const parts = [strings.raw[0]]

        for (let i = 1; i < strings.length; i++) {
          parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'))
          parts.push(String(strings.raw[i]))
        }

        return template(chalk, parts.join(''))
      }

      Object.defineProperties(Chalk.prototype, styles)

      module.exports = Chalk() // eslint-disable-line new-cap
      module.exports.supportsColor = stdoutColor
      module.exports['default'] = module.exports // For TypeScript

      /***/
    },

    /***/ 2593: /***/ module => {
      'use strict'

      const TEMPLATE_REGEX =
        /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi
      const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g
      const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/
      const ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi

      const ESCAPES = new Map([
        ['n', '\n'],
        ['r', '\r'],
        ['t', '\t'],
        ['b', '\b'],
        ['f', '\f'],
        ['v', '\v'],
        ['0', '\0'],
        ['\\', '\\'],
        ['e', '\u001B'],
        ['a', '\u0007'],
      ])

      function unescape(c) {
        if (
          (c[0] === 'u' && c.length === 5) ||
          (c[0] === 'x' && c.length === 3)
        ) {
          return String.fromCharCode(parseInt(c.slice(1), 16))
        }

        return ESCAPES.get(c) || c
      }

      function parseArguments(name, args) {
        const results = []
        const chunks = args.trim().split(/\s*,\s*/g)
        let matches

        for (const chunk of chunks) {
          if (!isNaN(chunk)) {
            results.push(Number(chunk))
          } else if ((matches = chunk.match(STRING_REGEX))) {
            results.push(
              matches[2].replace(ESCAPE_REGEX, (m, escape, chr) =>
                escape ? unescape(escape) : chr
              )
            )
          } else {
            throw new Error(
              `Invalid Chalk template style argument: ${chunk} (in style '${name}')`
            )
          }
        }

        return results
      }

      function parseStyle(style) {
        STYLE_REGEX.lastIndex = 0

        const results = []
        let matches

        while ((matches = STYLE_REGEX.exec(style)) !== null) {
          const name = matches[1]

          if (matches[2]) {
            const args = parseArguments(name, matches[2])
            results.push([name].concat(args))
          } else {
            results.push([name])
          }
        }

        return results
      }

      function buildStyle(chalk, styles) {
        const enabled = {}

        for (const layer of styles) {
          for (const style of layer.styles) {
            enabled[style[0]] = layer.inverse ? null : style.slice(1)
          }
        }

        let current = chalk
        for (const styleName of Object.keys(enabled)) {
          if (Array.isArray(enabled[styleName])) {
            if (!(styleName in current)) {
              throw new Error(`Unknown Chalk style: ${styleName}`)
            }

            if (enabled[styleName].length > 0) {
              current = current[styleName].apply(current, enabled[styleName])
            } else {
              current = current[styleName]
            }
          }
        }

        return current
      }

      module.exports = (chalk, tmp) => {
        const styles = []
        const chunks = []
        let chunk = []

        // eslint-disable-next-line max-params
        tmp.replace(
          TEMPLATE_REGEX,
          (m, escapeChar, inverse, style, close, chr) => {
            if (escapeChar) {
              chunk.push(unescape(escapeChar))
            } else if (style) {
              const str = chunk.join('')
              chunk = []
              chunks.push(
                styles.length === 0 ? str : buildStyle(chalk, styles)(str)
              )
              styles.push({ inverse, styles: parseStyle(style) })
            } else if (close) {
              if (styles.length === 0) {
                throw new Error('Found extraneous } in Chalk template literal')
              }

              chunks.push(buildStyle(chalk, styles)(chunk.join('')))
              chunk = []
              styles.pop()
            } else {
              chunk.push(chr)
            }
          }
        )

        chunks.push(chunk.join(''))

        if (styles.length > 0) {
          const errMsg = `Chalk template literal is missing ${
            styles.length
          } closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`
          throw new Error(errMsg)
        }

        return chunks.join('')
      }

      /***/
    },

    /***/ 9508: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      /* MIT license */
      var cssKeywords = __nccwpck_require__(8642)

      // NOTE: conversions should only return primitive values (i.e. arrays, or
      //       values that give correct `typeof` results).
      //       do not use box values types (i.e. Number(), String(), etc.)

      var reverseKeywords = {}
      for (var key in cssKeywords) {
        if (cssKeywords.hasOwnProperty(key)) {
          reverseKeywords[cssKeywords[key]] = key
        }
      }

      var convert = (module.exports = {
        rgb: { channels: 3, labels: 'rgb' },
        hsl: { channels: 3, labels: 'hsl' },
        hsv: { channels: 3, labels: 'hsv' },
        hwb: { channels: 3, labels: 'hwb' },
        cmyk: { channels: 4, labels: 'cmyk' },
        xyz: { channels: 3, labels: 'xyz' },
        lab: { channels: 3, labels: 'lab' },
        lch: { channels: 3, labels: 'lch' },
        hex: { channels: 1, labels: ['hex'] },
        keyword: { channels: 1, labels: ['keyword'] },
        ansi16: { channels: 1, labels: ['ansi16'] },
        ansi256: { channels: 1, labels: ['ansi256'] },
        hcg: { channels: 3, labels: ['h', 'c', 'g'] },
        apple: { channels: 3, labels: ['r16', 'g16', 'b16'] },
        gray: { channels: 1, labels: ['gray'] },
      })

      // hide .channels and .labels properties
      for (var model in convert) {
        if (convert.hasOwnProperty(model)) {
          if (!('channels' in convert[model])) {
            throw new Error('missing channels property: ' + model)
          }

          if (!('labels' in convert[model])) {
            throw new Error('missing channel labels property: ' + model)
          }

          if (convert[model].labels.length !== convert[model].channels) {
            throw new Error('channel and label counts mismatch: ' + model)
          }

          var channels = convert[model].channels
          var labels = convert[model].labels
          delete convert[model].channels
          delete convert[model].labels
          Object.defineProperty(convert[model], 'channels', { value: channels })
          Object.defineProperty(convert[model], 'labels', { value: labels })
        }
      }

      convert.rgb.hsl = function (rgb) {
        var r = rgb[0] / 255
        var g = rgb[1] / 255
        var b = rgb[2] / 255
        var min = Math.min(r, g, b)
        var max = Math.max(r, g, b)
        var delta = max - min
        var h
        var s
        var l

        if (max === min) {
          h = 0
        } else if (r === max) {
          h = (g - b) / delta
        } else if (g === max) {
          h = 2 + (b - r) / delta
        } else if (b === max) {
          h = 4 + (r - g) / delta
        }

        h = Math.min(h * 60, 360)

        if (h < 0) {
          h += 360
        }

        l = (min + max) / 2

        if (max === min) {
          s = 0
        } else if (l <= 0.5) {
          s = delta / (max + min)
        } else {
          s = delta / (2 - max - min)
        }

        return [h, s * 100, l * 100]
      }

      convert.rgb.hsv = function (rgb) {
        var rdif
        var gdif
        var bdif
        var h
        var s

        var r = rgb[0] / 255
        var g = rgb[1] / 255
        var b = rgb[2] / 255
        var v = Math.max(r, g, b)
        var diff = v - Math.min(r, g, b)
        var diffc = function (c) {
          return (v - c) / 6 / diff + 1 / 2
        }

        if (diff === 0) {
          h = s = 0
        } else {
          s = diff / v
          rdif = diffc(r)
          gdif = diffc(g)
          bdif = diffc(b)

          if (r === v) {
            h = bdif - gdif
          } else if (g === v) {
            h = 1 / 3 + rdif - bdif
          } else if (b === v) {
            h = 2 / 3 + gdif - rdif
          }
          if (h < 0) {
            h += 1
          } else if (h > 1) {
            h -= 1
          }
        }

        return [h * 360, s * 100, v * 100]
      }

      convert.rgb.hwb = function (rgb) {
        var r = rgb[0]
        var g = rgb[1]
        var b = rgb[2]
        var h = convert.rgb.hsl(rgb)[0]
        var w = (1 / 255) * Math.min(r, Math.min(g, b))

        b = 1 - (1 / 255) * Math.max(r, Math.max(g, b))

        return [h, w * 100, b * 100]
      }

      convert.rgb.cmyk = function (rgb) {
        var r = rgb[0] / 255
        var g = rgb[1] / 255
        var b = rgb[2] / 255
        var c
        var m
        var y
        var k

        k = Math.min(1 - r, 1 - g, 1 - b)
        c = (1 - r - k) / (1 - k) || 0
        m = (1 - g - k) / (1 - k) || 0
        y = (1 - b - k) / (1 - k) || 0

        return [c * 100, m * 100, y * 100, k * 100]
      }

      /**
       * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
       * */
      function comparativeDistance(x, y) {
        return (
          Math.pow(x[0] - y[0], 2) +
          Math.pow(x[1] - y[1], 2) +
          Math.pow(x[2] - y[2], 2)
        )
      }

      convert.rgb.keyword = function (rgb) {
        var reversed = reverseKeywords[rgb]
        if (reversed) {
          return reversed
        }

        var currentClosestDistance = Infinity
        var currentClosestKeyword

        for (var keyword in cssKeywords) {
          if (cssKeywords.hasOwnProperty(keyword)) {
            var value = cssKeywords[keyword]

            // Compute comparative distance
            var distance = comparativeDistance(rgb, value)

            // Check if its less, if so set as closest
            if (distance < currentClosestDistance) {
              currentClosestDistance = distance
              currentClosestKeyword = keyword
            }
          }
        }

        return currentClosestKeyword
      }

      convert.keyword.rgb = function (keyword) {
        return cssKeywords[keyword]
      }

      convert.rgb.xyz = function (rgb) {
        var r = rgb[0] / 255
        var g = rgb[1] / 255
        var b = rgb[2] / 255

        // assume sRGB
        r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92
        g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92
        b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92

        var x = r * 0.4124 + g * 0.3576 + b * 0.1805
        var y = r * 0.2126 + g * 0.7152 + b * 0.0722
        var z = r * 0.0193 + g * 0.1192 + b * 0.9505

        return [x * 100, y * 100, z * 100]
      }

      convert.rgb.lab = function (rgb) {
        var xyz = convert.rgb.xyz(rgb)
        var x = xyz[0]
        var y = xyz[1]
        var z = xyz[2]
        var l
        var a
        var b

        x /= 95.047
        y /= 100
        z /= 108.883

        x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116
        y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116
        z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116

        l = 116 * y - 16
        a = 500 * (x - y)
        b = 200 * (y - z)

        return [l, a, b]
      }

      convert.hsl.rgb = function (hsl) {
        var h = hsl[0] / 360
        var s = hsl[1] / 100
        var l = hsl[2] / 100
        var t1
        var t2
        var t3
        var rgb
        var val

        if (s === 0) {
          val = l * 255
          return [val, val, val]
        }

        if (l < 0.5) {
          t2 = l * (1 + s)
        } else {
          t2 = l + s - l * s
        }

        t1 = 2 * l - t2

        rgb = [0, 0, 0]
        for (var i = 0; i < 3; i++) {
          t3 = h + (1 / 3) * -(i - 1)
          if (t3 < 0) {
            t3++
          }
          if (t3 > 1) {
            t3--
          }

          if (6 * t3 < 1) {
            val = t1 + (t2 - t1) * 6 * t3
          } else if (2 * t3 < 1) {
            val = t2
          } else if (3 * t3 < 2) {
            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6
          } else {
            val = t1
          }

          rgb[i] = val * 255
        }

        return rgb
      }

      convert.hsl.hsv = function (hsl) {
        var h = hsl[0]
        var s = hsl[1] / 100
        var l = hsl[2] / 100
        var smin = s
        var lmin = Math.max(l, 0.01)
        var sv
        var v

        l *= 2
        s *= l <= 1 ? l : 2 - l
        smin *= lmin <= 1 ? lmin : 2 - lmin
        v = (l + s) / 2
        sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s)

        return [h, sv * 100, v * 100]
      }

      convert.hsv.rgb = function (hsv) {
        var h = hsv[0] / 60
        var s = hsv[1] / 100
        var v = hsv[2] / 100
        var hi = Math.floor(h) % 6

        var f = h - Math.floor(h)
        var p = 255 * v * (1 - s)
        var q = 255 * v * (1 - s * f)
        var t = 255 * v * (1 - s * (1 - f))
        v *= 255

        switch (hi) {
          case 0:
            return [v, t, p]
          case 1:
            return [q, v, p]
          case 2:
            return [p, v, t]
          case 3:
            return [p, q, v]
          case 4:
            return [t, p, v]
          case 5:
            return [v, p, q]
        }
      }

      convert.hsv.hsl = function (hsv) {
        var h = hsv[0]
        var s = hsv[1] / 100
        var v = hsv[2] / 100
        var vmin = Math.max(v, 0.01)
        var lmin
        var sl
        var l

        l = (2 - s) * v
        lmin = (2 - s) * vmin
        sl = s * vmin
        sl /= lmin <= 1 ? lmin : 2 - lmin
        sl = sl || 0
        l /= 2

        return [h, sl * 100, l * 100]
      }

      // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
      convert.hwb.rgb = function (hwb) {
        var h = hwb[0] / 360
        var wh = hwb[1] / 100
        var bl = hwb[2] / 100
        var ratio = wh + bl
        var i
        var v
        var f
        var n

        // wh + bl cant be > 1
        if (ratio > 1) {
          wh /= ratio
          bl /= ratio
        }

        i = Math.floor(6 * h)
        v = 1 - bl
        f = 6 * h - i

        if ((i & 0x01) !== 0) {
          f = 1 - f
        }

        n = wh + f * (v - wh) // linear interpolation

        var r
        var g
        var b
        switch (i) {
          default:
          case 6:
          case 0:
            r = v
            g = n
            b = wh
            break
          case 1:
            r = n
            g = v
            b = wh
            break
          case 2:
            r = wh
            g = v
            b = n
            break
          case 3:
            r = wh
            g = n
            b = v
            break
          case 4:
            r = n
            g = wh
            b = v
            break
          case 5:
            r = v
            g = wh
            b = n
            break
        }

        return [r * 255, g * 255, b * 255]
      }

      convert.cmyk.rgb = function (cmyk) {
        var c = cmyk[0] / 100
        var m = cmyk[1] / 100
        var y = cmyk[2] / 100
        var k = cmyk[3] / 100
        var r
        var g
        var b

        r = 1 - Math.min(1, c * (1 - k) + k)
        g = 1 - Math.min(1, m * (1 - k) + k)
        b = 1 - Math.min(1, y * (1 - k) + k)

        return [r * 255, g * 255, b * 255]
      }

      convert.xyz.rgb = function (xyz) {
        var x = xyz[0] / 100
        var y = xyz[1] / 100
        var z = xyz[2] / 100
        var r
        var g
        var b

        r = x * 3.2406 + y * -1.5372 + z * -0.4986
        g = x * -0.9689 + y * 1.8758 + z * 0.0415
        b = x * 0.0557 + y * -0.204 + z * 1.057

        // assume sRGB
        r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r * 12.92

        g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g * 12.92

        b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b * 12.92

        r = Math.min(Math.max(0, r), 1)
        g = Math.min(Math.max(0, g), 1)
        b = Math.min(Math.max(0, b), 1)

        return [r * 255, g * 255, b * 255]
      }

      convert.xyz.lab = function (xyz) {
        var x = xyz[0]
        var y = xyz[1]
        var z = xyz[2]
        var l
        var a
        var b

        x /= 95.047
        y /= 100
        z /= 108.883

        x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116
        y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116
        z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116

        l = 116 * y - 16
        a = 500 * (x - y)
        b = 200 * (y - z)

        return [l, a, b]
      }

      convert.lab.xyz = function (lab) {
        var l = lab[0]
        var a = lab[1]
        var b = lab[2]
        var x
        var y
        var z

        y = (l + 16) / 116
        x = a / 500 + y
        z = y - b / 200

        var y2 = Math.pow(y, 3)
        var x2 = Math.pow(x, 3)
        var z2 = Math.pow(z, 3)
        y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787
        x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787
        z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787

        x *= 95.047
        y *= 100
        z *= 108.883

        return [x, y, z]
      }

      convert.lab.lch = function (lab) {
        var l = lab[0]
        var a = lab[1]
        var b = lab[2]
        var hr
        var h
        var c

        hr = Math.atan2(b, a)
        h = (hr * 360) / 2 / Math.PI

        if (h < 0) {
          h += 360
        }

        c = Math.sqrt(a * a + b * b)

        return [l, c, h]
      }

      convert.lch.lab = function (lch) {
        var l = lch[0]
        var c = lch[1]
        var h = lch[2]
        var a
        var b
        var hr

        hr = (h / 360) * 2 * Math.PI
        a = c * Math.cos(hr)
        b = c * Math.sin(hr)

        return [l, a, b]
      }

      convert.rgb.ansi16 = function (args) {
        var r = args[0]
        var g = args[1]
        var b = args[2]
        var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2] // hsv -> ansi16 optimization

        value = Math.round(value / 50)

        if (value === 0) {
          return 30
        }

        var ansi =
          30 +
          ((Math.round(b / 255) << 2) |
            (Math.round(g / 255) << 1) |
            Math.round(r / 255))

        if (value === 2) {
          ansi += 60
        }

        return ansi
      }

      convert.hsv.ansi16 = function (args) {
        // optimization here; we already know the value and don't need to get
        // it converted for us.
        return convert.rgb.ansi16(convert.hsv.rgb(args), args[2])
      }

      convert.rgb.ansi256 = function (args) {
        var r = args[0]
        var g = args[1]
        var b = args[2]

        // we use the extended greyscale palette here, with the exception of
        // black and white. normal palette only has 4 greyscale shades.
        if (r === g && g === b) {
          if (r < 8) {
            return 16
          }

          if (r > 248) {
            return 231
          }

          return Math.round(((r - 8) / 247) * 24) + 232
        }

        var ansi =
          16 +
          36 * Math.round((r / 255) * 5) +
          6 * Math.round((g / 255) * 5) +
          Math.round((b / 255) * 5)

        return ansi
      }

      convert.ansi16.rgb = function (args) {
        var color = args % 10

        // handle greyscale
        if (color === 0 || color === 7) {
          if (args > 50) {
            color += 3.5
          }

          color = (color / 10.5) * 255

          return [color, color, color]
        }

        var mult = (~~(args > 50) + 1) * 0.5
        var r = (color & 1) * mult * 255
        var g = ((color >> 1) & 1) * mult * 255
        var b = ((color >> 2) & 1) * mult * 255

        return [r, g, b]
      }

      convert.ansi256.rgb = function (args) {
        // handle greyscale
        if (args >= 232) {
          var c = (args - 232) * 10 + 8
          return [c, c, c]
        }

        args -= 16

        var rem
        var r = (Math.floor(args / 36) / 5) * 255
        var g = (Math.floor((rem = args % 36) / 6) / 5) * 255
        var b = ((rem % 6) / 5) * 255

        return [r, g, b]
      }

      convert.rgb.hex = function (args) {
        var integer =
          ((Math.round(args[0]) & 0xff) << 16) +
          ((Math.round(args[1]) & 0xff) << 8) +
          (Math.round(args[2]) & 0xff)

        var string = integer.toString(16).toUpperCase()
        return '000000'.substring(string.length) + string
      }

      convert.hex.rgb = function (args) {
        var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i)
        if (!match) {
          return [0, 0, 0]
        }

        var colorString = match[0]

        if (match[0].length === 3) {
          colorString = colorString
            .split('')
            .map(function (char) {
              return char + char
            })
            .join('')
        }

        var integer = parseInt(colorString, 16)
        var r = (integer >> 16) & 0xff
        var g = (integer >> 8) & 0xff
        var b = integer & 0xff

        return [r, g, b]
      }

      convert.rgb.hcg = function (rgb) {
        var r = rgb[0] / 255
        var g = rgb[1] / 255
        var b = rgb[2] / 255
        var max = Math.max(Math.max(r, g), b)
        var min = Math.min(Math.min(r, g), b)
        var chroma = max - min
        var grayscale
        var hue

        if (chroma < 1) {
          grayscale = min / (1 - chroma)
        } else {
          grayscale = 0
        }

        if (chroma <= 0) {
          hue = 0
        } else if (max === r) {
          hue = ((g - b) / chroma) % 6
        } else if (max === g) {
          hue = 2 + (b - r) / chroma
        } else {
          hue = 4 + (r - g) / chroma + 4
        }

        hue /= 6
        hue %= 1

        return [hue * 360, chroma * 100, grayscale * 100]
      }

      convert.hsl.hcg = function (hsl) {
        var s = hsl[1] / 100
        var l = hsl[2] / 100
        var c = 1
        var f = 0

        if (l < 0.5) {
          c = 2.0 * s * l
        } else {
          c = 2.0 * s * (1.0 - l)
        }

        if (c < 1.0) {
          f = (l - 0.5 * c) / (1.0 - c)
        }

        return [hsl[0], c * 100, f * 100]
      }

      convert.hsv.hcg = function (hsv) {
        var s = hsv[1] / 100
        var v = hsv[2] / 100

        var c = s * v
        var f = 0

        if (c < 1.0) {
          f = (v - c) / (1 - c)
        }

        return [hsv[0], c * 100, f * 100]
      }

      convert.hcg.rgb = function (hcg) {
        var h = hcg[0] / 360
        var c = hcg[1] / 100
        var g = hcg[2] / 100

        if (c === 0.0) {
          return [g * 255, g * 255, g * 255]
        }

        var pure = [0, 0, 0]
        var hi = (h % 1) * 6
        var v = hi % 1
        var w = 1 - v
        var mg = 0

        switch (Math.floor(hi)) {
          case 0:
            pure[0] = 1
            pure[1] = v
            pure[2] = 0
            break
          case 1:
            pure[0] = w
            pure[1] = 1
            pure[2] = 0
            break
          case 2:
            pure[0] = 0
            pure[1] = 1
            pure[2] = v
            break
          case 3:
            pure[0] = 0
            pure[1] = w
            pure[2] = 1
            break
          case 4:
            pure[0] = v
            pure[1] = 0
            pure[2] = 1
            break
          default:
            pure[0] = 1
            pure[1] = 0
            pure[2] = w
        }

        mg = (1.0 - c) * g

        return [
          (c * pure[0] + mg) * 255,
          (c * pure[1] + mg) * 255,
          (c * pure[2] + mg) * 255,
        ]
      }

      convert.hcg.hsv = function (hcg) {
        var c = hcg[1] / 100
        var g = hcg[2] / 100

        var v = c + g * (1.0 - c)
        var f = 0

        if (v > 0.0) {
          f = c / v
        }

        return [hcg[0], f * 100, v * 100]
      }

      convert.hcg.hsl = function (hcg) {
        var c = hcg[1] / 100
        var g = hcg[2] / 100

        var l = g * (1.0 - c) + 0.5 * c
        var s = 0

        if (l > 0.0 && l < 0.5) {
          s = c / (2 * l)
        } else if (l >= 0.5 && l < 1.0) {
          s = c / (2 * (1 - l))
        }

        return [hcg[0], s * 100, l * 100]
      }

      convert.hcg.hwb = function (hcg) {
        var c = hcg[1] / 100
        var g = hcg[2] / 100
        var v = c + g * (1.0 - c)
        return [hcg[0], (v - c) * 100, (1 - v) * 100]
      }

      convert.hwb.hcg = function (hwb) {
        var w = hwb[1] / 100
        var b = hwb[2] / 100
        var v = 1 - b
        var c = v - w
        var g = 0

        if (c < 1) {
          g = (v - c) / (1 - c)
        }

        return [hwb[0], c * 100, g * 100]
      }

      convert.apple.rgb = function (apple) {
        return [
          (apple[0] / 65535) * 255,
          (apple[1] / 65535) * 255,
          (apple[2] / 65535) * 255,
        ]
      }

      convert.rgb.apple = function (rgb) {
        return [
          (rgb[0] / 255) * 65535,
          (rgb[1] / 255) * 65535,
          (rgb[2] / 255) * 65535,
        ]
      }

      convert.gray.rgb = function (args) {
        return [
          (args[0] / 100) * 255,
          (args[0] / 100) * 255,
          (args[0] / 100) * 255,
        ]
      }

      convert.gray.hsl = convert.gray.hsv = function (args) {
        return [0, 0, args[0]]
      }

      convert.gray.hwb = function (gray) {
        return [0, 100, gray[0]]
      }

      convert.gray.cmyk = function (gray) {
        return [0, 0, 0, gray[0]]
      }

      convert.gray.lab = function (gray) {
        return [gray[0], 0, 0]
      }

      convert.gray.hex = function (gray) {
        var val = Math.round((gray[0] / 100) * 255) & 0xff
        var integer = (val << 16) + (val << 8) + val

        var string = integer.toString(16).toUpperCase()
        return '000000'.substring(string.length) + string
      }

      convert.rgb.gray = function (rgb) {
        var val = (rgb[0] + rgb[1] + rgb[2]) / 3
        return [(val / 255) * 100]
      }

      /***/
    },

    /***/ 3596: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      var conversions = __nccwpck_require__(9508)
      var route = __nccwpck_require__(6967)

      var convert = {}

      var models = Object.keys(conversions)

      function wrapRaw(fn) {
        var wrappedFn = function (args) {
          if (args === undefined || args === null) {
            return args
          }

          if (arguments.length > 1) {
            args = Array.prototype.slice.call(arguments)
          }

          return fn(args)
        }

        // preserve .conversion property if there is one
        if ('conversion' in fn) {
          wrappedFn.conversion = fn.conversion
        }

        return wrappedFn
      }

      function wrapRounded(fn) {
        var wrappedFn = function (args) {
          if (args === undefined || args === null) {
            return args
          }

          if (arguments.length > 1) {
            args = Array.prototype.slice.call(arguments)
          }

          var result = fn(args)

          // we're assuming the result is an array here.
          // see notice in conversions.js; don't use box types
          // in conversion functions.
          if (typeof result === 'object') {
            for (var len = result.length, i = 0; i < len; i++) {
              result[i] = Math.round(result[i])
            }
          }

          return result
        }

        // preserve .conversion property if there is one
        if ('conversion' in fn) {
          wrappedFn.conversion = fn.conversion
        }

        return wrappedFn
      }

      models.forEach(function (fromModel) {
        convert[fromModel] = {}

        Object.defineProperty(convert[fromModel], 'channels', {
          value: conversions[fromModel].channels,
        })
        Object.defineProperty(convert[fromModel], 'labels', {
          value: conversions[fromModel].labels,
        })

        var routes = route(fromModel)
        var routeModels = Object.keys(routes)

        routeModels.forEach(function (toModel) {
          var fn = routes[toModel]

          convert[fromModel][toModel] = wrapRounded(fn)
          convert[fromModel][toModel].raw = wrapRaw(fn)
        })
      })

      module.exports = convert

      /***/
    },

    /***/ 6967: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      var conversions = __nccwpck_require__(9508)

      /*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

      function buildGraph() {
        var graph = {}
        // https://jsperf.com/object-keys-vs-for-in-with-closure/3
        var models = Object.keys(conversions)

        for (var len = models.length, i = 0; i < len; i++) {
          graph[models[i]] = {
            // http://jsperf.com/1-vs-infinity
            // micro-opt, but this is simple.
            distance: -1,
            parent: null,
          }
        }

        return graph
      }

      // https://en.wikipedia.org/wiki/Breadth-first_search
      function deriveBFS(fromModel) {
        var graph = buildGraph()
        var queue = [fromModel] // unshift -> queue -> pop

        graph[fromModel].distance = 0

        while (queue.length) {
          var current = queue.pop()
          var adjacents = Object.keys(conversions[current])

          for (var len = adjacents.length, i = 0; i < len; i++) {
            var adjacent = adjacents[i]
            var node = graph[adjacent]

            if (node.distance === -1) {
              node.distance = graph[current].distance + 1
              node.parent = current
              queue.unshift(adjacent)
            }
          }
        }

        return graph
      }

      function link(from, to) {
        return function (args) {
          return to(from(args))
        }
      }

      function wrapConversion(toModel, graph) {
        var path = [graph[toModel].parent, toModel]
        var fn = conversions[graph[toModel].parent][toModel]

        var cur = graph[toModel].parent
        while (graph[cur].parent) {
          path.unshift(graph[cur].parent)
          fn = link(conversions[graph[cur].parent][cur], fn)
          cur = graph[cur].parent
        }

        fn.conversion = path
        return fn
      }

      module.exports = function (fromModel) {
        var graph = deriveBFS(fromModel)
        var conversion = {}

        var models = Object.keys(graph)
        for (var len = models.length, i = 0; i < len; i++) {
          var toModel = models[i]
          var node = graph[toModel]

          if (node.parent === null) {
            // no possible conversion, or this node is the source model.
            continue
          }

          conversion[toModel] = wrapConversion(toModel, graph)
        }

        return conversion
      }

      /***/
    },

    /***/ 8642: /***/ module => {
      'use strict'

      module.exports = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50],
      }

      /***/
    },

    /***/ 2082: /***/ module => {
      'use strict'

      module.exports = (flag, argv) => {
        argv = argv || process.argv
        const prefix = flag.startsWith('-')
          ? ''
          : flag.length === 1
          ? '-'
          : '--'
        const pos = argv.indexOf(prefix + flag)
        const terminatorPos = argv.indexOf('--')
        return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos)
      }

      /***/
    },

    /***/ 9075: /***/ (module, exports) => {
      exports = module.exports = SemVer

      var debug
      /* istanbul ignore next */
      if (
        typeof process === 'object' &&
        process.env &&
        process.env.NODE_DEBUG &&
        /\bsemver\b/i.test(process.env.NODE_DEBUG)
      ) {
        debug = function () {
          var args = Array.prototype.slice.call(arguments, 0)
          args.unshift('SEMVER')
          console.log.apply(console, args)
        }
      } else {
        debug = function () {}
      }

      // Note: this is the semver.org version of the spec that it implements
      // Not necessarily the package version of this code.
      exports.SEMVER_SPEC_VERSION = '2.0.0'

      var MAX_LENGTH = 256
      var MAX_SAFE_INTEGER =
        Number.MAX_SAFE_INTEGER || /* istanbul ignore next */ 9007199254740991

      // Max safe segment length for coercion.
      var MAX_SAFE_COMPONENT_LENGTH = 16

      var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6

      // The actual regexps go on exports.re
      var re = (exports.re = [])
      var safeRe = (exports.safeRe = [])
      var src = (exports.src = [])
      var R = 0

      var LETTERDASHNUMBER = '[a-zA-Z0-9-]'

      // Replace some greedy regex tokens to prevent regex dos issues. These regex are
      // used internally via the safeRe object since all inputs in this library get
      // normalized first to trim and collapse all extra whitespace. The original
      // regexes are exported for userland consumption and lower level usage. A
      // future breaking change could export the safer regex only with a note that
      // all input should have extra whitespace removed.
      var safeRegexReplacements = [
        ['\\s', 1],
        ['\\d', MAX_LENGTH],
        [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
      ]

      function makeSafeRe(value) {
        for (var i = 0; i < safeRegexReplacements.length; i++) {
          var token = safeRegexReplacements[i][0]
          var max = safeRegexReplacements[i][1]
          value = value
            .split(token + '*')
            .join(token + '{0,' + max + '}')
            .split(token + '+')
            .join(token + '{1,' + max + '}')
        }
        return value
      }

      // The following Regular Expressions can be used for tokenizing,
      // validating, and parsing SemVer version strings.

      // ## Numeric Identifier
      // A single `0`, or a non-zero digit followed by zero or more digits.

      var NUMERICIDENTIFIER = R++
      src[NUMERICIDENTIFIER] = '0|[1-9]\\d*'
      var NUMERICIDENTIFIERLOOSE = R++
      src[NUMERICIDENTIFIERLOOSE] = '\\d+'

      // ## Non-numeric Identifier
      // Zero or more digits, followed by a letter or hyphen, and then zero or
      // more letters, digits, or hyphens.

      var NONNUMERICIDENTIFIER = R++
      src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-]' + LETTERDASHNUMBER + '*'

      // ## Main Version
      // Three dot-separated numeric identifiers.

      var MAINVERSION = R++
      src[MAINVERSION] =
        '(' +
        src[NUMERICIDENTIFIER] +
        ')\\.' +
        '(' +
        src[NUMERICIDENTIFIER] +
        ')\\.' +
        '(' +
        src[NUMERICIDENTIFIER] +
        ')'

      var MAINVERSIONLOOSE = R++
      src[MAINVERSIONLOOSE] =
        '(' +
        src[NUMERICIDENTIFIERLOOSE] +
        ')\\.' +
        '(' +
        src[NUMERICIDENTIFIERLOOSE] +
        ')\\.' +
        '(' +
        src[NUMERICIDENTIFIERLOOSE] +
        ')'

      // ## Pre-release Version Identifier
      // A numeric identifier, or a non-numeric identifier.

      var PRERELEASEIDENTIFIER = R++
      src[PRERELEASEIDENTIFIER] =
        '(?:' + src[NUMERICIDENTIFIER] + '|' + src[NONNUMERICIDENTIFIER] + ')'

      var PRERELEASEIDENTIFIERLOOSE = R++
      src[PRERELEASEIDENTIFIERLOOSE] =
        '(?:' +
        src[NUMERICIDENTIFIERLOOSE] +
        '|' +
        src[NONNUMERICIDENTIFIER] +
        ')'

      // ## Pre-release Version
      // Hyphen, followed by one or more dot-separated pre-release version
      // identifiers.

      var PRERELEASE = R++
      src[PRERELEASE] =
        '(?:-(' +
        src[PRERELEASEIDENTIFIER] +
        '(?:\\.' +
        src[PRERELEASEIDENTIFIER] +
        ')*))'

      var PRERELEASELOOSE = R++
      src[PRERELEASELOOSE] =
        '(?:-?(' +
        src[PRERELEASEIDENTIFIERLOOSE] +
        '(?:\\.' +
        src[PRERELEASEIDENTIFIERLOOSE] +
        ')*))'

      // ## Build Metadata Identifier
      // Any combination of digits, letters, or hyphens.

      var BUILDIDENTIFIER = R++
      src[BUILDIDENTIFIER] = LETTERDASHNUMBER + '+'

      // ## Build Metadata
      // Plus sign, followed by one or more period-separated build metadata
      // identifiers.

      var BUILD = R++
      src[BUILD] =
        '(?:\\+(' +
        src[BUILDIDENTIFIER] +
        '(?:\\.' +
        src[BUILDIDENTIFIER] +
        ')*))'

      // ## Full Version String
      // A main version, followed optionally by a pre-release version and
      // build metadata.

      // Note that the only major, minor, patch, and pre-release sections of
      // the version string are capturing groups.  The build metadata is not a
      // capturing group, because it should not ever be used in version
      // comparison.

      var FULL = R++
      var FULLPLAIN =
        'v?' + src[MAINVERSION] + src[PRERELEASE] + '?' + src[BUILD] + '?'

      src[FULL] = '^' + FULLPLAIN + '$'

      // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
      // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
      // common in the npm registry.
      var LOOSEPLAIN =
        '[v=\\s]*' +
        src[MAINVERSIONLOOSE] +
        src[PRERELEASELOOSE] +
        '?' +
        src[BUILD] +
        '?'

      var LOOSE = R++
      src[LOOSE] = '^' + LOOSEPLAIN + '$'

      var GTLT = R++
      src[GTLT] = '((?:<|>)?=?)'

      // Something like "2.*" or "1.2.x".
      // Note that "x.x" is a valid xRange identifer, meaning "any version"
      // Only the first item is strictly required.
      var XRANGEIDENTIFIERLOOSE = R++
      src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
      var XRANGEIDENTIFIER = R++
      src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*'

      var XRANGEPLAIN = R++
      src[XRANGEPLAIN] =
        '[v=\\s]*(' +
        src[XRANGEIDENTIFIER] +
        ')' +
        '(?:\\.(' +
        src[XRANGEIDENTIFIER] +
        ')' +
        '(?:\\.(' +
        src[XRANGEIDENTIFIER] +
        ')' +
        '(?:' +
        src[PRERELEASE] +
        ')?' +
        src[BUILD] +
        '?' +
        ')?)?'

      var XRANGEPLAINLOOSE = R++
      src[XRANGEPLAINLOOSE] =
        '[v=\\s]*(' +
        src[XRANGEIDENTIFIERLOOSE] +
        ')' +
        '(?:\\.(' +
        src[XRANGEIDENTIFIERLOOSE] +
        ')' +
        '(?:\\.(' +
        src[XRANGEIDENTIFIERLOOSE] +
        ')' +
        '(?:' +
        src[PRERELEASELOOSE] +
        ')?' +
        src[BUILD] +
        '?' +
        ')?)?'

      var XRANGE = R++
      src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$'
      var XRANGELOOSE = R++
      src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'

      // Coercion.
      // Extract anything that could conceivably be a part of a valid semver
      var COERCE = R++
      src[COERCE] =
        '(?:^|[^\\d])' +
        '(\\d{1,' +
        MAX_SAFE_COMPONENT_LENGTH +
        '})' +
        '(?:\\.(\\d{1,' +
        MAX_SAFE_COMPONENT_LENGTH +
        '}))?' +
        '(?:\\.(\\d{1,' +
        MAX_SAFE_COMPONENT_LENGTH +
        '}))?' +
        '(?:$|[^\\d])'

      // Tilde ranges.
      // Meaning is "reasonably at or greater than"
      var LONETILDE = R++
      src[LONETILDE] = '(?:~>?)'

      var TILDETRIM = R++
      src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+'
      re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')
      safeRe[TILDETRIM] = new RegExp(makeSafeRe(src[TILDETRIM]), 'g')
      var tildeTrimReplace = '$1~'

      var TILDE = R++
      src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'
      var TILDELOOSE = R++
      src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'

      // Caret ranges.
      // Meaning is "at least and backwards compatible with"
      var LONECARET = R++
      src[LONECARET] = '(?:\\^)'

      var CARETTRIM = R++
      src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+'
      re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')
      safeRe[CARETTRIM] = new RegExp(makeSafeRe(src[CARETTRIM]), 'g')
      var caretTrimReplace = '$1^'

      var CARET = R++
      src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'
      var CARETLOOSE = R++
      src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'

      // A simple gt/lt/eq thing, or just "" to indicate "any version"
      var COMPARATORLOOSE = R++
      src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$'
      var COMPARATOR = R++
      src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'

      // An expression to strip any whitespace between the gtlt and the thing
      // it modifies, so that `> 1.2.3` ==> `>1.2.3`
      var COMPARATORTRIM = R++
      src[COMPARATORTRIM] =
        '(\\s*)' +
        src[GTLT] +
        '\\s*(' +
        LOOSEPLAIN +
        '|' +
        src[XRANGEPLAIN] +
        ')'

      // this one has to use the /g flag
      re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')
      safeRe[COMPARATORTRIM] = new RegExp(makeSafeRe(src[COMPARATORTRIM]), 'g')
      var comparatorTrimReplace = '$1$2$3'

      // Something like `1.2.3 - 1.2.4`
      // Note that these all use the loose form, because they'll be
      // checked against either the strict or loose comparator form
      // later.
      var HYPHENRANGE = R++
      src[HYPHENRANGE] =
        '^\\s*(' +
        src[XRANGEPLAIN] +
        ')' +
        '\\s+-\\s+' +
        '(' +
        src[XRANGEPLAIN] +
        ')' +
        '\\s*$'

      var HYPHENRANGELOOSE = R++
      src[HYPHENRANGELOOSE] =
        '^\\s*(' +
        src[XRANGEPLAINLOOSE] +
        ')' +
        '\\s+-\\s+' +
        '(' +
        src[XRANGEPLAINLOOSE] +
        ')' +
        '\\s*$'

      // Star ranges basically just allow anything at all.
      var STAR = R++
      src[STAR] = '(<|>)?=?\\s*\\*'

      // Compile to actual regexp objects.
      // All are flag-free, unless they were created above with a flag.
      for (var i = 0; i < R; i++) {
        debug(i, src[i])
        if (!re[i]) {
          re[i] = new RegExp(src[i])

          // Replace all greedy whitespace to prevent regex dos issues. These regex are
          // used internally via the safeRe object since all inputs in this library get
          // normalized first to trim and collapse all extra whitespace. The original
          // regexes are exported for userland consumption and lower level usage. A
          // future breaking change could export the safer regex only with a note that
          // all input should have extra whitespace removed.
          safeRe[i] = new RegExp(makeSafeRe(src[i]))
        }
      }

      exports.parse = parse
      function parse(version, options) {
        if (!options || typeof options !== 'object') {
          options = {
            loose: !!options,
            includePrerelease: false,
          }
        }

        if (version instanceof SemVer) {
          return version
        }

        if (typeof version !== 'string') {
          return null
        }

        if (version.length > MAX_LENGTH) {
          return null
        }

        var r = options.loose ? safeRe[LOOSE] : safeRe[FULL]
        if (!r.test(version)) {
          return null
        }

        try {
          return new SemVer(version, options)
        } catch (er) {
          return null
        }
      }

      exports.valid = valid
      function valid(version, options) {
        var v = parse(version, options)
        return v ? v.version : null
      }

      exports.clean = clean
      function clean(version, options) {
        var s = parse(version.trim().replace(/^[=v]+/, ''), options)
        return s ? s.version : null
      }

      exports.SemVer = SemVer

      function SemVer(version, options) {
        if (!options || typeof options !== 'object') {
          options = {
            loose: !!options,
            includePrerelease: false,
          }
        }
        if (version instanceof SemVer) {
          if (version.loose === options.loose) {
            return version
          } else {
            version = version.version
          }
        } else if (typeof version !== 'string') {
          throw new TypeError('Invalid Version: ' + version)
        }

        if (version.length > MAX_LENGTH) {
          throw new TypeError(
            'version is longer than ' + MAX_LENGTH + ' characters'
          )
        }

        if (!(this instanceof SemVer)) {
          return new SemVer(version, options)
        }

        debug('SemVer', version, options)
        this.options = options
        this.loose = !!options.loose

        var m = version
          .trim()
          .match(options.loose ? safeRe[LOOSE] : safeRe[FULL])

        if (!m) {
          throw new TypeError('Invalid Version: ' + version)
        }

        this.raw = version

        // these are actually numbers
        this.major = +m[1]
        this.minor = +m[2]
        this.patch = +m[3]

        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError('Invalid major version')
        }

        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError('Invalid minor version')
        }

        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError('Invalid patch version')
        }

        // numberify any prerelease numeric ids
        if (!m[4]) {
          this.prerelease = []
        } else {
          this.prerelease = m[4].split('.').map(function (id) {
            if (/^[0-9]+$/.test(id)) {
              var num = +id
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num
              }
            }
            return id
          })
        }

        this.build = m[5] ? m[5].split('.') : []
        this.format()
      }

      SemVer.prototype.format = function () {
        this.version = this.major + '.' + this.minor + '.' + this.patch
        if (this.prerelease.length) {
          this.version += '-' + this.prerelease.join('.')
        }
        return this.version
      }

      SemVer.prototype.toString = function () {
        return this.version
      }

      SemVer.prototype.compare = function (other) {
        debug('SemVer.compare', this.version, this.options, other)
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options)
        }

        return this.compareMain(other) || this.comparePre(other)
      }

      SemVer.prototype.compareMain = function (other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options)
        }

        return (
          compareIdentifiers(this.major, other.major) ||
          compareIdentifiers(this.minor, other.minor) ||
          compareIdentifiers(this.patch, other.patch)
        )
      }

      SemVer.prototype.comparePre = function (other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options)
        }

        // NOT having a prerelease is > having one
        if (this.prerelease.length && !other.prerelease.length) {
          return -1
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0
        }

        var i = 0
        do {
          var a = this.prerelease[i]
          var b = other.prerelease[i]
          debug('prerelease compare', i, a, b)
          if (a === undefined && b === undefined) {
            return 0
          } else if (b === undefined) {
            return 1
          } else if (a === undefined) {
            return -1
          } else if (a === b) {
            continue
          } else {
            return compareIdentifiers(a, b)
          }
        } while (++i)
      }

      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      SemVer.prototype.inc = function (release, identifier) {
        switch (release) {
          case 'premajor':
            this.prerelease.length = 0
            this.patch = 0
            this.minor = 0
            this.major++
            this.inc('pre', identifier)
            break
          case 'preminor':
            this.prerelease.length = 0
            this.patch = 0
            this.minor++
            this.inc('pre', identifier)
            break
          case 'prepatch':
            // If this is already a prerelease, it will bump to the next version
            // drop any prereleases that might already exist, since they are not
            // relevant at this point.
            this.prerelease.length = 0
            this.inc('patch', identifier)
            this.inc('pre', identifier)
            break
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case 'prerelease':
            if (this.prerelease.length === 0) {
              this.inc('patch', identifier)
            }
            this.inc('pre', identifier)
            break

          case 'major':
            // If this is a pre-major version, bump up to the same major version.
            // Otherwise increment major.
            // 1.0.0-5 bumps to 1.0.0
            // 1.1.0 bumps to 2.0.0
            if (
              this.minor !== 0 ||
              this.patch !== 0 ||
              this.prerelease.length === 0
            ) {
              this.major++
            }
            this.minor = 0
            this.patch = 0
            this.prerelease = []
            break
          case 'minor':
            // If this is a pre-minor version, bump up to the same minor version.
            // Otherwise increment minor.
            // 1.2.0-5 bumps to 1.2.0
            // 1.2.1 bumps to 1.3.0
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++
            }
            this.patch = 0
            this.prerelease = []
            break
          case 'patch':
            // If this is not a pre-release version, it will increment the patch.
            // If it is a pre-release it will bump up to the same patch version.
            // 1.2.0-5 patches to 1.2.0
            // 1.2.0 patches to 1.2.1
            if (this.prerelease.length === 0) {
              this.patch++
            }
            this.prerelease = []
            break
          // This probably shouldn't be used publicly.
          // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
          case 'pre':
            if (this.prerelease.length === 0) {
              this.prerelease = [0]
            } else {
              var i = this.prerelease.length
              while (--i >= 0) {
                if (typeof this.prerelease[i] === 'number') {
                  this.prerelease[i]++
                  i = -2
                }
              }
              if (i === -1) {
                // didn't increment anything
                this.prerelease.push(0)
              }
            }
            if (identifier) {
              // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
              // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
              if (this.prerelease[0] === identifier) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0]
                }
              } else {
                this.prerelease = [identifier, 0]
              }
            }
            break

          default:
            throw new Error('invalid increment argument: ' + release)
        }
        this.format()
        this.raw = this.version
        return this
      }

      exports.inc = inc
      function inc(version, release, loose, identifier) {
        if (typeof loose === 'string') {
          identifier = loose
          loose = undefined
        }

        try {
          return new SemVer(version, loose).inc(release, identifier).version
        } catch (er) {
          return null
        }
      }

      exports.diff = diff
      function diff(version1, version2) {
        if (eq(version1, version2)) {
          return null
        } else {
          var v1 = parse(version1)
          var v2 = parse(version2)
          var prefix = ''
          if (v1.prerelease.length || v2.prerelease.length) {
            prefix = 'pre'
            var defaultResult = 'prerelease'
          }
          for (var key in v1) {
            if (key === 'major' || key === 'minor' || key === 'patch') {
              if (v1[key] !== v2[key]) {
                return prefix + key
              }
            }
          }
          return defaultResult // may be undefined
        }
      }

      exports.compareIdentifiers = compareIdentifiers

      var numeric = /^[0-9]+$/
      function compareIdentifiers(a, b) {
        var anum = numeric.test(a)
        var bnum = numeric.test(b)

        if (anum && bnum) {
          a = +a
          b = +b
        }

        return a === b
          ? 0
          : anum && !bnum
          ? -1
          : bnum && !anum
          ? 1
          : a < b
          ? -1
          : 1
      }

      exports.rcompareIdentifiers = rcompareIdentifiers
      function rcompareIdentifiers(a, b) {
        return compareIdentifiers(b, a)
      }

      exports.major = major
      function major(a, loose) {
        return new SemVer(a, loose).major
      }

      exports.minor = minor
      function minor(a, loose) {
        return new SemVer(a, loose).minor
      }

      exports.patch = patch
      function patch(a, loose) {
        return new SemVer(a, loose).patch
      }

      exports.compare = compare
      function compare(a, b, loose) {
        return new SemVer(a, loose).compare(new SemVer(b, loose))
      }

      exports.compareLoose = compareLoose
      function compareLoose(a, b) {
        return compare(a, b, true)
      }

      exports.rcompare = rcompare
      function rcompare(a, b, loose) {
        return compare(b, a, loose)
      }

      exports.sort = sort
      function sort(list, loose) {
        return list.sort(function (a, b) {
          return exports.compare(a, b, loose)
        })
      }

      exports.rsort = rsort
      function rsort(list, loose) {
        return list.sort(function (a, b) {
          return exports.rcompare(a, b, loose)
        })
      }

      exports.gt = gt
      function gt(a, b, loose) {
        return compare(a, b, loose) > 0
      }

      exports.lt = lt
      function lt(a, b, loose) {
        return compare(a, b, loose) < 0
      }

      exports.eq = eq
      function eq(a, b, loose) {
        return compare(a, b, loose) === 0
      }

      exports.neq = neq
      function neq(a, b, loose) {
        return compare(a, b, loose) !== 0
      }

      exports.gte = gte
      function gte(a, b, loose) {
        return compare(a, b, loose) >= 0
      }

      exports.lte = lte
      function lte(a, b, loose) {
        return compare(a, b, loose) <= 0
      }

      exports.cmp = cmp
      function cmp(a, op, b, loose) {
        switch (op) {
          case '===':
            if (typeof a === 'object') a = a.version
            if (typeof b === 'object') b = b.version
            return a === b

          case '!==':
            if (typeof a === 'object') a = a.version
            if (typeof b === 'object') b = b.version
            return a !== b

          case '':
          case '=':
          case '==':
            return eq(a, b, loose)

          case '!=':
            return neq(a, b, loose)

          case '>':
            return gt(a, b, loose)

          case '>=':
            return gte(a, b, loose)

          case '<':
            return lt(a, b, loose)

          case '<=':
            return lte(a, b, loose)

          default:
            throw new TypeError('Invalid operator: ' + op)
        }
      }

      exports.Comparator = Comparator
      function Comparator(comp, options) {
        if (!options || typeof options !== 'object') {
          options = {
            loose: !!options,
            includePrerelease: false,
          }
        }

        if (comp instanceof Comparator) {
          if (comp.loose === !!options.loose) {
            return comp
          } else {
            comp = comp.value
          }
        }

        if (!(this instanceof Comparator)) {
          return new Comparator(comp, options)
        }

        comp = comp.trim().split(/\s+/).join(' ')
        debug('comparator', comp, options)
        this.options = options
        this.loose = !!options.loose
        this.parse(comp)

        if (this.semver === ANY) {
          this.value = ''
        } else {
          this.value = this.operator + this.semver.version
        }

        debug('comp', this)
      }

      var ANY = {}
      Comparator.prototype.parse = function (comp) {
        var r = this.options.loose
          ? safeRe[COMPARATORLOOSE]
          : safeRe[COMPARATOR]
        var m = comp.match(r)

        if (!m) {
          throw new TypeError('Invalid comparator: ' + comp)
        }

        this.operator = m[1]
        if (this.operator === '=') {
          this.operator = ''
        }

        // if it literally is just '>' or '' then allow anything.
        if (!m[2]) {
          this.semver = ANY
        } else {
          this.semver = new SemVer(m[2], this.options.loose)
        }
      }

      Comparator.prototype.toString = function () {
        return this.value
      }

      Comparator.prototype.test = function (version) {
        debug('Comparator.test', version, this.options.loose)

        if (this.semver === ANY) {
          return true
        }

        if (typeof version === 'string') {
          version = new SemVer(version, this.options)
        }

        return cmp(version, this.operator, this.semver, this.options)
      }

      Comparator.prototype.intersects = function (comp, options) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError('a Comparator is required')
        }

        if (!options || typeof options !== 'object') {
          options = {
            loose: !!options,
            includePrerelease: false,
          }
        }

        var rangeTmp

        if (this.operator === '') {
          rangeTmp = new Range(comp.value, options)
          return satisfies(this.value, rangeTmp, options)
        } else if (comp.operator === '') {
          rangeTmp = new Range(this.value, options)
          return satisfies(comp.semver, rangeTmp, options)
        }

        var sameDirectionIncreasing =
          (this.operator === '>=' || this.operator === '>') &&
          (comp.operator === '>=' || comp.operator === '>')
        var sameDirectionDecreasing =
          (this.operator === '<=' || this.operator === '<') &&
          (comp.operator === '<=' || comp.operator === '<')
        var sameSemVer = this.semver.version === comp.semver.version
        var differentDirectionsInclusive =
          (this.operator === '>=' || this.operator === '<=') &&
          (comp.operator === '>=' || comp.operator === '<=')
        var oppositeDirectionsLessThan =
          cmp(this.semver, '<', comp.semver, options) &&
          (this.operator === '>=' || this.operator === '>') &&
          (comp.operator === '<=' || comp.operator === '<')
        var oppositeDirectionsGreaterThan =
          cmp(this.semver, '>', comp.semver, options) &&
          (this.operator === '<=' || this.operator === '<') &&
          (comp.operator === '>=' || comp.operator === '>')

        return (
          sameDirectionIncreasing ||
          sameDirectionDecreasing ||
          (sameSemVer && differentDirectionsInclusive) ||
          oppositeDirectionsLessThan ||
          oppositeDirectionsGreaterThan
        )
      }

      exports.Range = Range
      function Range(range, options) {
        if (!options || typeof options !== 'object') {
          options = {
            loose: !!options,
            includePrerelease: false,
          }
        }

        if (range instanceof Range) {
          if (
            range.loose === !!options.loose &&
            range.includePrerelease === !!options.includePrerelease
          ) {
            return range
          } else {
            return new Range(range.raw, options)
          }
        }

        if (range instanceof Comparator) {
          return new Range(range.value, options)
        }

        if (!(this instanceof Range)) {
          return new Range(range, options)
        }

        this.options = options
        this.loose = !!options.loose
        this.includePrerelease = !!options.includePrerelease

        // First reduce all whitespace as much as possible so we do not have to rely
        // on potentially slow regexes like \s*. This is then stored and used for
        // future error messages as well.
        this.raw = range.trim().split(/\s+/).join(' ')

        // First, split based on boolean or ||
        this.set = this.raw
          .split('||')
          .map(function (range) {
            return this.parseRange(range.trim())
          }, this)
          .filter(function (c) {
            // throw out any that are not relevant for whatever reason
            return c.length
          })

        if (!this.set.length) {
          throw new TypeError('Invalid SemVer Range: ' + this.raw)
        }

        this.format()
      }

      Range.prototype.format = function () {
        this.range = this.set
          .map(function (comps) {
            return comps.join(' ').trim()
          })
          .join('||')
          .trim()
        return this.range
      }

      Range.prototype.toString = function () {
        return this.range
      }

      Range.prototype.parseRange = function (range) {
        var loose = this.options.loose
        // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
        var hr = loose ? safeRe[HYPHENRANGELOOSE] : safeRe[HYPHENRANGE]
        range = range.replace(hr, hyphenReplace)
        debug('hyphen replace', range)
        // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
        range = range.replace(safeRe[COMPARATORTRIM], comparatorTrimReplace)
        debug('comparator trim', range, safeRe[COMPARATORTRIM])

        // `~ 1.2.3` => `~1.2.3`
        range = range.replace(safeRe[TILDETRIM], tildeTrimReplace)

        // `^ 1.2.3` => `^1.2.3`
        range = range.replace(safeRe[CARETTRIM], caretTrimReplace)

        // At this point, the range is completely trimmed and
        // ready to be split into comparators.
        var compRe = loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR]
        var set = range
          .split(' ')
          .map(function (comp) {
            return parseComparator(comp, this.options)
          }, this)
          .join(' ')
          .split(/\s+/)
        if (this.options.loose) {
          // in loose mode, throw out any that are not valid comparators
          set = set.filter(function (comp) {
            return !!comp.match(compRe)
          })
        }
        set = set.map(function (comp) {
          return new Comparator(comp, this.options)
        }, this)

        return set
      }

      Range.prototype.intersects = function (range, options) {
        if (!(range instanceof Range)) {
          throw new TypeError('a Range is required')
        }

        return this.set.some(function (thisComparators) {
          return thisComparators.every(function (thisComparator) {
            return range.set.some(function (rangeComparators) {
              return rangeComparators.every(function (rangeComparator) {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          })
        })
      }

      // Mostly just for testing and legacy API reasons
      exports.toComparators = toComparators
      function toComparators(range, options) {
        return new Range(range, options).set.map(function (comp) {
          return comp
            .map(function (c) {
              return c.value
            })
            .join(' ')
            .trim()
            .split(' ')
        })
      }

      // comprised of xranges, tildes, stars, and gtlt's at this point.
      // already replaced the hyphen ranges
      // turn into a set of JUST comparators.
      function parseComparator(comp, options) {
        debug('comp', comp, options)
        comp = replaceCarets(comp, options)
        debug('caret', comp)
        comp = replaceTildes(comp, options)
        debug('tildes', comp)
        comp = replaceXRanges(comp, options)
        debug('xrange', comp)
        comp = replaceStars(comp, options)
        debug('stars', comp)
        return comp
      }

      function isX(id) {
        return !id || id.toLowerCase() === 'x' || id === '*'
      }

      // ~, ~> --> * (any, kinda silly)
      // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
      // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
      // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
      // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
      // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
      function replaceTildes(comp, options) {
        return comp
          .trim()
          .split(/\s+/)
          .map(function (comp) {
            return replaceTilde(comp, options)
          })
          .join(' ')
      }

      function replaceTilde(comp, options) {
        var r = options.loose ? safeRe[TILDELOOSE] : safeRe[TILDE]
        return comp.replace(r, function (_, M, m, p, pr) {
          debug('tilde', comp, _, M, m, p, pr)
          var ret

          if (isX(M)) {
            ret = ''
          } else if (isX(m)) {
            ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
          } else if (isX(p)) {
            // ~1.2 == >=1.2.0 <1.3.0
            ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
          } else if (pr) {
            debug('replaceTilde pr', pr)
            ret =
              '>=' +
              M +
              '.' +
              m +
              '.' +
              p +
              '-' +
              pr +
              ' <' +
              M +
              '.' +
              (+m + 1) +
              '.0'
          } else {
            // ~1.2.3 == >=1.2.3 <1.3.0
            ret =
              '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0'
          }

          debug('tilde return', ret)
          return ret
        })
      }

      // ^ --> * (any, kinda silly)
      // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
      // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
      // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
      // ^1.2.3 --> >=1.2.3 <2.0.0
      // ^1.2.0 --> >=1.2.0 <2.0.0
      function replaceCarets(comp, options) {
        return comp
          .trim()
          .split(/\s+/)
          .map(function (comp) {
            return replaceCaret(comp, options)
          })
          .join(' ')
      }

      function replaceCaret(comp, options) {
        debug('caret', comp, options)
        var r = options.loose ? safeRe[CARETLOOSE] : safeRe[CARET]
        return comp.replace(r, function (_, M, m, p, pr) {
          debug('caret', comp, _, M, m, p, pr)
          var ret

          if (isX(M)) {
            ret = ''
          } else if (isX(m)) {
            ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
          } else if (isX(p)) {
            if (M === '0') {
              ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
            } else {
              ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
            }
          } else if (pr) {
            debug('replaceCaret pr', pr)
            if (M === '0') {
              if (m === '0') {
                ret =
                  '>=' +
                  M +
                  '.' +
                  m +
                  '.' +
                  p +
                  '-' +
                  pr +
                  ' <' +
                  M +
                  '.' +
                  m +
                  '.' +
                  (+p + 1)
              } else {
                ret =
                  '>=' +
                  M +
                  '.' +
                  m +
                  '.' +
                  p +
                  '-' +
                  pr +
                  ' <' +
                  M +
                  '.' +
                  (+m + 1) +
                  '.0'
              }
            } else {
              ret =
                '>=' +
                M +
                '.' +
                m +
                '.' +
                p +
                '-' +
                pr +
                ' <' +
                (+M + 1) +
                '.0.0'
            }
          } else {
            debug('no pr')
            if (M === '0') {
              if (m === '0') {
                ret =
                  '>=' +
                  M +
                  '.' +
                  m +
                  '.' +
                  p +
                  ' <' +
                  M +
                  '.' +
                  m +
                  '.' +
                  (+p + 1)
              } else {
                ret =
                  '>=' +
                  M +
                  '.' +
                  m +
                  '.' +
                  p +
                  ' <' +
                  M +
                  '.' +
                  (+m + 1) +
                  '.0'
              }
            } else {
              ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0'
            }
          }

          debug('caret return', ret)
          return ret
        })
      }

      function replaceXRanges(comp, options) {
        debug('replaceXRanges', comp, options)
        return comp
          .split(/\s+/)
          .map(function (comp) {
            return replaceXRange(comp, options)
          })
          .join(' ')
      }

      function replaceXRange(comp, options) {
        comp = comp.trim()
        var r = options.loose ? safeRe[XRANGELOOSE] : safeRe[XRANGE]
        return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
          debug('xRange', comp, ret, gtlt, M, m, p, pr)
          var xM = isX(M)
          var xm = xM || isX(m)
          var xp = xm || isX(p)
          var anyX = xp

          if (gtlt === '=' && anyX) {
            gtlt = ''
          }

          if (xM) {
            if (gtlt === '>' || gtlt === '<') {
              // nothing is allowed
              ret = '<0.0.0'
            } else {
              // nothing is forbidden
              ret = '*'
            }
          } else if (gtlt && anyX) {
            // we know patch is an x, because we have any x at all.
            // replace X with 0
            if (xm) {
              m = 0
            }
            p = 0

            if (gtlt === '>') {
              // >1 => >=2.0.0
              // >1.2 => >=1.3.0
              // >1.2.3 => >= 1.2.4
              gtlt = '>='
              if (xm) {
                M = +M + 1
                m = 0
                p = 0
              } else {
                m = +m + 1
                p = 0
              }
            } else if (gtlt === '<=') {
              // <=0.7.x is actually <0.8.0, since any 0.7.x should
              // pass.  Similarly, <=7.x is actually <8.0.0, etc.
              gtlt = '<'
              if (xm) {
                M = +M + 1
              } else {
                m = +m + 1
              }
            }

            ret = gtlt + M + '.' + m + '.' + p
          } else if (xm) {
            ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
          } else if (xp) {
            ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
          }

          debug('xRange return', ret)

          return ret
        })
      }

      // Because * is AND-ed with everything else in the comparator,
      // and '' means "any version", just remove the *s entirely.
      function replaceStars(comp, options) {
        debug('replaceStars', comp, options)
        // Looseness is ignored here.  star is always as loose as it gets!
        return comp.trim().replace(safeRe[STAR], '')
      }

      // This function is passed to string.replace(safeRe[HYPHENRANGE])
      // M, m, patch, prerelease, build
      // 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
      // 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
      // 1.2 - 3.4 => >=1.2.0 <3.5.0
      function hyphenReplace(
        $0,
        from,
        fM,
        fm,
        fp,
        fpr,
        fb,
        to,
        tM,
        tm,
        tp,
        tpr,
        tb
      ) {
        if (isX(fM)) {
          from = ''
        } else if (isX(fm)) {
          from = '>=' + fM + '.0.0'
        } else if (isX(fp)) {
          from = '>=' + fM + '.' + fm + '.0'
        } else {
          from = '>=' + from
        }

        if (isX(tM)) {
          to = ''
        } else if (isX(tm)) {
          to = '<' + (+tM + 1) + '.0.0'
        } else if (isX(tp)) {
          to = '<' + tM + '.' + (+tm + 1) + '.0'
        } else if (tpr) {
          to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
        } else {
          to = '<=' + to
        }

        return (from + ' ' + to).trim()
      }

      // if ANY of the sets match ALL of its comparators, then pass
      Range.prototype.test = function (version) {
        if (!version) {
          return false
        }

        if (typeof version === 'string') {
          version = new SemVer(version, this.options)
        }

        for (var i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version, this.options)) {
            return true
          }
        }
        return false
      }

      function testSet(set, version, options) {
        for (var i = 0; i < set.length; i++) {
          if (!set[i].test(version)) {
            return false
          }
        }

        if (version.prerelease.length && !options.includePrerelease) {
          // Find the set of versions that are allowed to have prereleases
          // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
          // That should allow `1.2.3-pr.2` to pass.
          // However, `1.2.4-alpha.notready` should NOT be allowed,
          // even though it's within the range set by the comparators.
          for (i = 0; i < set.length; i++) {
            debug(set[i].semver)
            if (set[i].semver === ANY) {
              continue
            }

            if (set[i].semver.prerelease.length > 0) {
              var allowed = set[i].semver
              if (
                allowed.major === version.major &&
                allowed.minor === version.minor &&
                allowed.patch === version.patch
              ) {
                return true
              }
            }
          }

          // Version has a -pre, but it's not one of the ones we like.
          return false
        }

        return true
      }

      exports.satisfies = satisfies
      function satisfies(version, range, options) {
        try {
          range = new Range(range, options)
        } catch (er) {
          return false
        }
        return range.test(version)
      }

      exports.maxSatisfying = maxSatisfying
      function maxSatisfying(versions, range, options) {
        var max = null
        var maxSV = null
        try {
          var rangeObj = new Range(range, options)
        } catch (er) {
          return null
        }
        versions.forEach(function (v) {
          if (rangeObj.test(v)) {
            // satisfies(v, range, options)
            if (!max || maxSV.compare(v) === -1) {
              // compare(max, v, true)
              max = v
              maxSV = new SemVer(max, options)
            }
          }
        })
        return max
      }

      exports.minSatisfying = minSatisfying
      function minSatisfying(versions, range, options) {
        var min = null
        var minSV = null
        try {
          var rangeObj = new Range(range, options)
        } catch (er) {
          return null
        }
        versions.forEach(function (v) {
          if (rangeObj.test(v)) {
            // satisfies(v, range, options)
            if (!min || minSV.compare(v) === 1) {
              // compare(min, v, true)
              min = v
              minSV = new SemVer(min, options)
            }
          }
        })
        return min
      }

      exports.minVersion = minVersion
      function minVersion(range, loose) {
        range = new Range(range, loose)

        var minver = new SemVer('0.0.0')
        if (range.test(minver)) {
          return minver
        }

        minver = new SemVer('0.0.0-0')
        if (range.test(minver)) {
          return minver
        }

        minver = null
        for (var i = 0; i < range.set.length; ++i) {
          var comparators = range.set[i]

          comparators.forEach(function (comparator) {
            // Clone to avoid manipulating the comparator's semver object.
            var compver = new SemVer(comparator.semver.version)
            switch (comparator.operator) {
              case '>':
                if (compver.prerelease.length === 0) {
                  compver.patch++
                } else {
                  compver.prerelease.push(0)
                }
                compver.raw = compver.format()
              /* fallthrough */
              case '':
              case '>=':
                if (!minver || gt(minver, compver)) {
                  minver = compver
                }
                break
              case '<':
              case '<=':
                /* Ignore maximum versions */
                break
              /* istanbul ignore next */
              default:
                throw new Error('Unexpected operation: ' + comparator.operator)
            }
          })
        }

        if (minver && range.test(minver)) {
          return minver
        }

        return null
      }

      exports.validRange = validRange
      function validRange(range, options) {
        try {
          // Return '*' instead of '' so that truthiness works.
          // This will throw if it's invalid anyway
          return new Range(range, options).range || '*'
        } catch (er) {
          return null
        }
      }

      // Determine if version is less than all the versions possible in the range
      exports.ltr = ltr
      function ltr(version, range, options) {
        return outside(version, range, '<', options)
      }

      // Determine if version is greater than all the versions possible in the range.
      exports.gtr = gtr
      function gtr(version, range, options) {
        return outside(version, range, '>', options)
      }

      exports.outside = outside
      function outside(version, range, hilo, options) {
        version = new SemVer(version, options)
        range = new Range(range, options)

        var gtfn, ltefn, ltfn, comp, ecomp
        switch (hilo) {
          case '>':
            gtfn = gt
            ltefn = lte
            ltfn = lt
            comp = '>'
            ecomp = '>='
            break
          case '<':
            gtfn = lt
            ltefn = gte
            ltfn = gt
            comp = '<'
            ecomp = '<='
            break
          default:
            throw new TypeError('Must provide a hilo val of "<" or ">"')
        }

        // If it satisifes the range it is not outside
        if (satisfies(version, range, options)) {
          return false
        }

        // From now on, variable terms are as if we're in "gtr" mode.
        // but note that everything is flipped for the "ltr" function.

        for (var i = 0; i < range.set.length; ++i) {
          var comparators = range.set[i]

          var high = null
          var low = null

          comparators.forEach(function (comparator) {
            if (comparator.semver === ANY) {
              comparator = new Comparator('>=0.0.0')
            }
            high = high || comparator
            low = low || comparator
            if (gtfn(comparator.semver, high.semver, options)) {
              high = comparator
            } else if (ltfn(comparator.semver, low.semver, options)) {
              low = comparator
            }
          })

          // If the edge version comparator has a operator then our version
          // isn't outside it
          if (high.operator === comp || high.operator === ecomp) {
            return false
          }

          // If the lowest version comparator has an operator and our version
          // is less than it then it isn't higher than the range
          if (
            (!low.operator || low.operator === comp) &&
            ltefn(version, low.semver)
          ) {
            return false
          } else if (low.operator === ecomp && ltfn(version, low.semver)) {
            return false
          }
        }
        return true
      }

      exports.prerelease = prerelease
      function prerelease(version, options) {
        var parsed = parse(version, options)
        return parsed && parsed.prerelease.length ? parsed.prerelease : null
      }

      exports.intersects = intersects
      function intersects(r1, r2, options) {
        r1 = new Range(r1, options)
        r2 = new Range(r2, options)
        return r1.intersects(r2)
      }

      exports.coerce = coerce
      function coerce(version) {
        if (version instanceof SemVer) {
          return version
        }

        if (typeof version !== 'string') {
          return null
        }

        var match = version.match(safeRe[COERCE])

        if (match == null) {
          return null
        }

        return parse(
          match[1] + '.' + (match[2] || '0') + '.' + (match[3] || '0')
        )
      }

      /***/
    },

    /***/ 6571: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const os = __nccwpck_require__(2037)
      const hasFlag = __nccwpck_require__(2082)

      const env = process.env

      let forceColor
      if (
        hasFlag('no-color') ||
        hasFlag('no-colors') ||
        hasFlag('color=false')
      ) {
        forceColor = false
      } else if (
        hasFlag('color') ||
        hasFlag('colors') ||
        hasFlag('color=true') ||
        hasFlag('color=always')
      ) {
        forceColor = true
      }
      if ('FORCE_COLOR' in env) {
        forceColor =
          env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0
      }

      function translateLevel(level) {
        if (level === 0) {
          return false
        }

        return {
          level,
          hasBasic: true,
          has256: level >= 2,
          has16m: level >= 3,
        }
      }

      function supportsColor(stream) {
        if (forceColor === false) {
          return 0
        }

        if (
          hasFlag('color=16m') ||
          hasFlag('color=full') ||
          hasFlag('color=truecolor')
        ) {
          return 3
        }

        if (hasFlag('color=256')) {
          return 2
        }

        if (stream && !stream.isTTY && forceColor !== true) {
          return 0
        }

        const min = forceColor ? 1 : 0

        if (process.platform === 'win32') {
          // Node.js 7.5.0 is the first version of Node.js to include a patch to
          // libuv that enables 256 color output on Windows. Anything earlier and it
          // won't work. However, here we target Node.js 8 at minimum as it is an LTS
          // release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
          // release that supports 256 colors. Windows 10 build 14931 is the first release
          // that supports 16m/TrueColor.
          const osRelease = os.release().split('.')
          if (
            Number(process.versions.node.split('.')[0]) >= 8 &&
            Number(osRelease[0]) >= 10 &&
            Number(osRelease[2]) >= 10586
          ) {
            return Number(osRelease[2]) >= 14931 ? 3 : 2
          }

          return 1
        }

        if ('CI' in env) {
          if (
            ['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(
              sign => sign in env
            ) ||
            env.CI_NAME === 'codeship'
          ) {
            return 1
          }

          return min
        }

        if ('TEAMCITY_VERSION' in env) {
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION)
            ? 1
            : 0
        }

        if (env.COLORTERM === 'truecolor') {
          return 3
        }

        if ('TERM_PROGRAM' in env) {
          const version = parseInt(
            (env.TERM_PROGRAM_VERSION || '').split('.')[0],
            10
          )

          switch (env.TERM_PROGRAM) {
            case 'iTerm.app':
              return version >= 3 ? 3 : 2
            case 'Apple_Terminal':
              return 2
            // No default
          }
        }

        if (/-256(color)?$/i.test(env.TERM)) {
          return 2
        }

        if (
          /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(
            env.TERM
          )
        ) {
          return 1
        }

        if ('COLORTERM' in env) {
          return 1
        }

        if (env.TERM === 'dumb') {
          return min
        }

        return min
      }

      function getSupportLevel(stream) {
        const level = supportsColor(stream)
        return translateLevel(level)
      }

      module.exports = {
        supportsColor: getSupportLevel,
        stdout: getSupportLevel(process.stdout),
        stderr: getSupportLevel(process.stderr),
      }

      /***/
    },

    /***/ 9769: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })

      var assembleReleasePlan = __nccwpck_require__(4633)
      var readChangesets = __nccwpck_require__(1878)
      var config = __nccwpck_require__(3355)
      var getPackages = __nccwpck_require__(8166)
      var pre = __nccwpck_require__(5272)

      function _interopDefault(e) {
        return e && e.__esModule ? e : { default: e }
      }

      var assembleReleasePlan__default =
        /*#__PURE__*/ _interopDefault(assembleReleasePlan)
      var readChangesets__default =
        /*#__PURE__*/ _interopDefault(readChangesets)

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true,
          })
        } else {
          obj[key] = value
        }

        return obj
      }

      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object)

        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object)
          if (enumerableOnly)
            symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable
            })
          keys.push.apply(keys, symbols)
        }

        return keys
      }

      function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {}

          if (i % 2) {
            ownKeys(Object(source), true).forEach(function (key) {
              _defineProperty(target, key, source[key])
            })
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(
              target,
              Object.getOwnPropertyDescriptors(source)
            )
          } else {
            ownKeys(Object(source)).forEach(function (key) {
              Object.defineProperty(
                target,
                key,
                Object.getOwnPropertyDescriptor(source, key)
              )
            })
          }
        }

        return target
      }

      async function getReleasePlan(cwd, sinceRef, passedConfig) {
        const packages = await getPackages.getPackages(cwd)
        const preState = await pre.readPreState(cwd)
        const readConfig = await config.read(cwd, packages)
        const config$1 = passedConfig
          ? _objectSpread2(_objectSpread2({}, readConfig), passedConfig)
          : readConfig
        const changesets = await readChangesets__default['default'](
          cwd,
          sinceRef
        )
        return assembleReleasePlan__default['default'](
          changesets,
          packages,
          config$1,
          preState
        )
      }

      exports['default'] = getReleasePlan

      /***/
    },

    /***/ 9568: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      if (process.env.NODE_ENV === 'production') {
        module.exports = __nccwpck_require__(5382)
      } else {
        module.exports = __nccwpck_require__(9769)
      }

      /***/
    },

    /***/ 5382: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: !0,
      })

      var assembleReleasePlan = __nccwpck_require__(4633),
        readChangesets = __nccwpck_require__(1878),
        config = __nccwpck_require__(3355),
        getPackages = __nccwpck_require__(8166),
        pre = __nccwpck_require__(5272)

      function _interopDefault(e) {
        return e && e.__esModule
          ? e
          : {
              default: e,
            }
      }

      var assembleReleasePlan__default = _interopDefault(assembleReleasePlan),
        readChangesets__default = _interopDefault(readChangesets)

      function _defineProperty(obj, key, value) {
        return (
          key in obj
            ? Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (obj[key] = value),
          obj
        )
      }

      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object)
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object)
          enumerableOnly &&
            (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable
            })),
            keys.push.apply(keys, symbols)
        }
        return keys
      }

      function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = null != arguments[i] ? arguments[i] : {}
          i % 2
            ? ownKeys(Object(source), !0).forEach(function (key) {
                _defineProperty(target, key, source[key])
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(
                target,
                Object.getOwnPropertyDescriptors(source)
              )
            : ownKeys(Object(source)).forEach(function (key) {
                Object.defineProperty(
                  target,
                  key,
                  Object.getOwnPropertyDescriptor(source, key)
                )
              })
        }
        return target
      }

      async function getReleasePlan(cwd, sinceRef, passedConfig) {
        const packages = await getPackages.getPackages(cwd),
          preState = await pre.readPreState(cwd),
          readConfig = await config.read(cwd, packages),
          config$1 = passedConfig
            ? _objectSpread2(_objectSpread2({}, readConfig), passedConfig)
            : readConfig,
          changesets = await readChangesets__default.default(cwd, sinceRef)
        return assembleReleasePlan__default.default(
          changesets,
          packages,
          config$1,
          preState
        )
      }

      exports['default'] = getReleasePlan

      /***/
    },

    /***/ 7298: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })

      var spawn = __nccwpck_require__(4374)
      var fs = __nccwpck_require__(7147)
      var path = __nccwpck_require__(1017)
      var getPackages = __nccwpck_require__(8166)
      var errors = __nccwpck_require__(6740)
      var isSubdir = __nccwpck_require__(8760)
      var util = __nccwpck_require__(3837)

      function _interopDefault(e) {
        return e && e.__esModule ? e : { default: e }
      }

      var spawn__default = /*#__PURE__*/ _interopDefault(spawn)
      var fs__default = /*#__PURE__*/ _interopDefault(fs)
      var path__default = /*#__PURE__*/ _interopDefault(path)
      var isSubdir__default = /*#__PURE__*/ _interopDefault(isSubdir)

      const isInDir = dir => subdir => isSubdir__default['default'](dir, subdir)

      async function add(pathToFile, cwd) {
        const gitCmd = await spawn__default['default'](
          'git',
          ['add', pathToFile],
          {
            cwd,
          }
        )

        if (gitCmd.code !== 0) {
          console.log(pathToFile, gitCmd.stderr.toString())
        }

        return gitCmd.code === 0
      }
      async function commit(message, cwd) {
        const gitCmd = await spawn__default['default'](
          'git',
          ['commit', '-m', message, '--allow-empty'],
          {
            cwd,
          }
        )
        return gitCmd.code === 0
      }
      async function getAllTags(cwd) {
        const gitCmd = await spawn__default['default']('git', ['tag'], {
          cwd,
        })

        if (gitCmd.code !== 0) {
          throw new Error(gitCmd.stderr.toString())
        }

        const tags = gitCmd.stdout.toString().trim().split('\n')
        return new Set(tags)
      } // used to create a single tag at a time for the current head only

      async function tag(tagStr, cwd) {
        // NOTE: it's important we use the -m flag to create annotated tag otherwise 'git push --follow-tags' won't actually push
        // the tags
        const gitCmd = await spawn__default['default'](
          'git',
          ['tag', tagStr, '-m', tagStr],
          {
            cwd,
          }
        )
        return gitCmd.code === 0
      } // Find the commit where we diverged from `ref` at using `git merge-base`

      async function getDivergedCommit(cwd, ref) {
        const cmd = await spawn__default['default'](
          'git',
          ['merge-base', ref, 'HEAD'],
          {
            cwd,
          }
        )

        if (cmd.code !== 0) {
          throw new Error(
            `Failed to find where HEAD diverged from ${ref}. Does ${ref} exist?`
          )
        }

        return cmd.stdout.toString().trim()
      }
      const getCommitThatAddsFile = util.deprecate(async (gitPath, cwd) => {
        return (await getCommitsThatAddFiles([gitPath], cwd))[0]
      }, 'Use the bulk getCommitsThatAddFiles function instead')
      /**
       * Get the short SHAs for the commits that added files, including automatically
       * extending a shallow clone if necessary to determine any commits.
       * @param gitPaths - Paths to fetch
       * @param cwd - Location of the repository
       */

      async function getCommitsThatAddFiles(gitPaths, cwd) {
        // Maps gitPath to short commit SHA
        const map = new Map() // Paths we haven't completed processing on yet

        let remaining = gitPaths

        do {
          // Fetch commit information for all paths we don't have yet
          const commitInfos = await Promise.all(
            remaining.map(async gitPath => {
              const [commitSha, parentSha] = (
                await spawn__default['default'](
                  'git',
                  [
                    'log',
                    '--diff-filter=A',
                    '--max-count=1',
                    '--pretty=format:%h:%p',
                    gitPath,
                  ],
                  {
                    cwd,
                  }
                )
              ).stdout
                .toString()
                .split(':')
              return {
                path: gitPath,
                commitSha,
                parentSha,
              }
            })
          ) // To collect commits without parents (usually because they're absent from
          // a shallow clone).

          let commitsWithMissingParents = []

          for (const info of commitInfos) {
            if (info.commitSha) {
              if (info.parentSha) {
                // We have found the parent of the commit that added the file.
                // Therefore we know that the commit is legitimate and isn't simply the boundary of a shallow clone.
                map.set(info.path, info.commitSha)
              } else {
                commitsWithMissingParents.push(info)
              }
            }
          }

          if (commitsWithMissingParents.length === 0) {
            break
          } // The commits we've found may be the real commits or they may be the boundary of
          // a shallow clone.
          // Can we deepen the clone?

          if (
            await isRepoShallow({
              cwd,
            })
          ) {
            // Yes.
            await deepenCloneBy({
              by: 50,
              cwd,
            })
            remaining = commitsWithMissingParents.map(p => p.path)
          } else {
            // It's not a shallow clone, so all the commit SHAs we have are legitimate.
            for (const unresolved of commitsWithMissingParents) {
              map.set(unresolved.path, unresolved.commitSha)
            }

            break
          }
        } while (true)

        return gitPaths.map(p => map.get(p))
      }
      async function isRepoShallow({ cwd }) {
        const isShallowRepoOutput = (
          await spawn__default['default'](
            'git',
            ['rev-parse', '--is-shallow-repository'],
            {
              cwd,
            }
          )
        ).stdout
          .toString()
          .trim()

        if (isShallowRepoOutput === '--is-shallow-repository') {
          // We have an old version of Git (<2.15) which doesn't support `rev-parse --is-shallow-repository`
          // In that case, we'll test for the existence of .git/shallow.
          // Firstly, find the .git folder for the repo; note that this will be relative to the repo dir
          const gitDir = (
            await spawn__default['default']('git', ['rev-parse', '--git-dir'], {
              cwd,
            })
          ).stdout
            .toString()
            .trim()
          const fullGitDir = path__default['default'].resolve(cwd, gitDir) // Check for the existence of <gitDir>/shallow

          return fs__default['default'].existsSync(
            path__default['default'].join(fullGitDir, 'shallow')
          )
        } else {
          // We have a newer Git which supports `rev-parse --is-shallow-repository`. We'll use
          // the output of that instead of messing with .git/shallow in case that changes in the future.
          return isShallowRepoOutput === 'true'
        }
      }
      async function deepenCloneBy({ by, cwd }) {
        await spawn__default['default']('git', ['fetch', `--deepen=${by}`], {
          cwd,
        })
      }

      async function getRepoRoot({ cwd }) {
        const { stdout, code, stderr } = await spawn__default['default'](
          'git',
          ['rev-parse', '--show-toplevel'],
          {
            cwd,
          }
        )

        if (code !== 0) {
          throw new Error(stderr.toString())
        }

        return stdout.toString().trim().replace(/\n|\r/g, '')
      }

      async function getChangedFilesSince({ cwd, ref, fullPath = false }) {
        const divergedAt = await getDivergedCommit(cwd, ref) // Now we can find which files we added

        const cmd = await spawn__default['default'](
          'git',
          ['diff', '--name-only', divergedAt],
          {
            cwd,
          }
        )

        if (cmd.code !== 0) {
          throw new Error(
            `Failed to diff against ${divergedAt}. Is ${divergedAt} a valid ref?`
          )
        }

        const files = cmd.stdout
          .toString()
          .trim()
          .split('\n')
          .filter(a => a)
        if (!fullPath) return files
        const repoRoot = await getRepoRoot({
          cwd,
        })
        return files.map(file =>
          path__default['default'].resolve(repoRoot, file)
        )
      } // below are less generic functions that we use in combination with other things we are doing

      async function getChangedChangesetFilesSinceRef({ cwd, ref }) {
        try {
          const divergedAt = await getDivergedCommit(cwd, ref) // Now we can find which files we added

          const cmd = await spawn__default['default'](
            'git',
            ['diff', '--name-only', '--diff-filter=d', divergedAt],
            {
              cwd,
            }
          )
          let tester = /.changeset\/[^/]+\.md$/
          const files = cmd.stdout
            .toString()
            .trim()
            .split('\n')
            .filter(file => tester.test(file))
          return files
        } catch (err) {
          if (err instanceof errors.GitError) return []
          throw err
        }
      }
      async function getChangedPackagesSinceRef({ cwd, ref }) {
        const changedFiles = await getChangedFilesSince({
          ref,
          cwd,
          fullPath: true,
        })
        let packages = await getPackages.getPackages(cwd)
        const fileToPackage = {}
        packages.packages.forEach(pkg =>
          changedFiles.filter(isInDir(pkg.dir)).forEach(fileName => {
            const prevPkg = fileToPackage[fileName] || {
              dir: '',
            }
            if (pkg.dir.length > prevPkg.dir.length)
              fileToPackage[fileName] = pkg
          })
        )
        return Object.values(fileToPackage) // filter, so that we have only unique packages
          .filter((pkg, idx, packages) => packages.indexOf(pkg) === idx)
      }
      async function tagExists(tagStr, cwd) {
        const gitCmd = await spawn__default['default'](
          'git',
          ['tag', '-l', tagStr],
          {
            cwd,
          }
        )
        const output = gitCmd.stdout.toString().trim()
        const tagExists = !!output
        return tagExists
      }
      async function getCurrentCommitId({ cwd }) {
        return (
          await spawn__default['default'](
            'git',
            ['rev-parse', '--short', 'HEAD'],
            {
              cwd,
            }
          )
        ).stdout
          .toString()
          .trim()
      }
      async function remoteTagExists(tagStr) {
        const gitCmd = await spawn__default['default']('git', [
          'ls-remote',
          '--tags',
          'origin',
          '-l',
          tagStr,
        ])
        const output = gitCmd.stdout.toString().trim()
        const tagExists = !!output
        return tagExists
      }

      exports.add = add
      exports.commit = commit
      exports.deepenCloneBy = deepenCloneBy
      exports.getAllTags = getAllTags
      exports.getChangedChangesetFilesSinceRef =
        getChangedChangesetFilesSinceRef
      exports.getChangedFilesSince = getChangedFilesSince
      exports.getChangedPackagesSinceRef = getChangedPackagesSinceRef
      exports.getCommitThatAddsFile = getCommitThatAddsFile
      exports.getCommitsThatAddFiles = getCommitsThatAddFiles
      exports.getCurrentCommitId = getCurrentCommitId
      exports.getDivergedCommit = getDivergedCommit
      exports.isRepoShallow = isRepoShallow
      exports.remoteTagExists = remoteTagExists
      exports.tag = tag
      exports.tagExists = tagExists

      /***/
    },

    /***/ 9942: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      if (process.env.NODE_ENV === 'production') {
        module.exports = __nccwpck_require__(732)
      } else {
        module.exports = __nccwpck_require__(7298)
      }

      /***/
    },

    /***/ 732: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: !0,
      })

      var spawn = __nccwpck_require__(4374),
        fs = __nccwpck_require__(7147),
        path = __nccwpck_require__(1017),
        getPackages = __nccwpck_require__(8166),
        errors = __nccwpck_require__(6740),
        isSubdir = __nccwpck_require__(8760),
        util = __nccwpck_require__(3837)

      function _interopDefault(e) {
        return e && e.__esModule
          ? e
          : {
              default: e,
            }
      }

      var spawn__default = _interopDefault(spawn),
        fs__default = _interopDefault(fs),
        path__default = _interopDefault(path),
        isSubdir__default = _interopDefault(isSubdir)

      const isInDir = dir => subdir => isSubdir__default.default(dir, subdir)

      async function add(pathToFile, cwd) {
        const gitCmd = await spawn__default.default(
          'git',
          ['add', pathToFile],
          {
            cwd: cwd,
          }
        )
        return (
          0 !== gitCmd.code &&
            console.log(pathToFile, gitCmd.stderr.toString()),
          0 === gitCmd.code
        )
      }

      async function commit(message, cwd) {
        return (
          0 ===
          (
            await spawn__default.default(
              'git',
              ['commit', '-m', message, '--allow-empty'],
              {
                cwd: cwd,
              }
            )
          ).code
        )
      }

      async function getAllTags(cwd) {
        const gitCmd = await spawn__default.default('git', ['tag'], {
          cwd: cwd,
        })
        if (0 !== gitCmd.code) throw new Error(gitCmd.stderr.toString())
        const tags = gitCmd.stdout.toString().trim().split('\n')
        return new Set(tags)
      }

      async function tag(tagStr, cwd) {
        return (
          0 ===
          (
            await spawn__default.default('git', ['tag', tagStr, '-m', tagStr], {
              cwd: cwd,
            })
          ).code
        )
      }

      async function getDivergedCommit(cwd, ref) {
        const cmd = await spawn__default.default(
          'git',
          ['merge-base', ref, 'HEAD'],
          {
            cwd: cwd,
          }
        )
        if (0 !== cmd.code)
          throw new Error(
            `Failed to find where HEAD diverged from ${ref}. Does ${ref} exist?`
          )
        return cmd.stdout.toString().trim()
      }

      const getCommitThatAddsFile = util.deprecate(
        async (gitPath, cwd) =>
          (await getCommitsThatAddFiles([gitPath], cwd))[0],
        'Use the bulk getCommitsThatAddFiles function instead'
      )

      async function getCommitsThatAddFiles(gitPaths, cwd) {
        const map = new Map()
        let remaining = gitPaths
        for (;;) {
          const commitInfos = await Promise.all(
            remaining.map(async gitPath => {
              const [commitSha, parentSha] = (
                await spawn__default.default(
                  'git',
                  [
                    'log',
                    '--diff-filter=A',
                    '--max-count=1',
                    '--pretty=format:%h:%p',
                    gitPath,
                  ],
                  {
                    cwd: cwd,
                  }
                )
              ).stdout
                .toString()
                .split(':')
              return {
                path: gitPath,
                commitSha: commitSha,
                parentSha: parentSha,
              }
            })
          )
          let commitsWithMissingParents = []
          for (const info of commitInfos)
            info.commitSha &&
              (info.parentSha
                ? map.set(info.path, info.commitSha)
                : commitsWithMissingParents.push(info))
          if (0 === commitsWithMissingParents.length) break
          if (
            !(await isRepoShallow({
              cwd: cwd,
            }))
          ) {
            for (const unresolved of commitsWithMissingParents)
              map.set(unresolved.path, unresolved.commitSha)
            break
          }
          await deepenCloneBy({
            by: 50,
            cwd: cwd,
          }),
            (remaining = commitsWithMissingParents.map(p => p.path))
        }
        return gitPaths.map(p => map.get(p))
      }

      async function isRepoShallow({ cwd: cwd }) {
        const isShallowRepoOutput = (
          await spawn__default.default(
            'git',
            ['rev-parse', '--is-shallow-repository'],
            {
              cwd: cwd,
            }
          )
        ).stdout
          .toString()
          .trim()
        if ('--is-shallow-repository' === isShallowRepoOutput) {
          const gitDir = (
              await spawn__default.default('git', ['rev-parse', '--git-dir'], {
                cwd: cwd,
              })
            ).stdout
              .toString()
              .trim(),
            fullGitDir = path__default.default.resolve(cwd, gitDir)
          return fs__default.default.existsSync(
            path__default.default.join(fullGitDir, 'shallow')
          )
        }
        return 'true' === isShallowRepoOutput
      }

      async function deepenCloneBy({ by: by, cwd: cwd }) {
        await spawn__default.default('git', ['fetch', '--deepen=' + by], {
          cwd: cwd,
        })
      }

      async function getRepoRoot({ cwd: cwd }) {
        const {
          stdout: stdout,
          code: code,
          stderr: stderr,
        } = await spawn__default.default(
          'git',
          ['rev-parse', '--show-toplevel'],
          {
            cwd: cwd,
          }
        )
        if (0 !== code) throw new Error(stderr.toString())
        return stdout.toString().trim().replace(/\n|\r/g, '')
      }

      async function getChangedFilesSince({
        cwd: cwd,
        ref: ref,
        fullPath: fullPath = !1,
      }) {
        const divergedAt = await getDivergedCommit(cwd, ref),
          cmd = await spawn__default.default(
            'git',
            ['diff', '--name-only', divergedAt],
            {
              cwd: cwd,
            }
          )
        if (0 !== cmd.code)
          throw new Error(
            `Failed to diff against ${divergedAt}. Is ${divergedAt} a valid ref?`
          )
        const files = cmd.stdout
          .toString()
          .trim()
          .split('\n')
          .filter(a => a)
        if (!fullPath) return files
        const repoRoot = await getRepoRoot({
          cwd: cwd,
        })
        return files.map(file => path__default.default.resolve(repoRoot, file))
      }

      async function getChangedChangesetFilesSinceRef({ cwd: cwd, ref: ref }) {
        try {
          const divergedAt = await getDivergedCommit(cwd, ref),
            cmd = await spawn__default.default(
              'git',
              ['diff', '--name-only', '--diff-filter=d', divergedAt],
              {
                cwd: cwd,
              }
            )
          let tester = /.changeset\/[^/]+\.md$/
          return cmd.stdout
            .toString()
            .trim()
            .split('\n')
            .filter(file => tester.test(file))
        } catch (err) {
          if (err instanceof errors.GitError) return []
          throw err
        }
      }

      async function getChangedPackagesSinceRef({ cwd: cwd, ref: ref }) {
        const changedFiles = await getChangedFilesSince({
          ref: ref,
          cwd: cwd,
          fullPath: !0,
        })
        let packages = await getPackages.getPackages(cwd)
        const fileToPackage = {}
        return (
          packages.packages.forEach(pkg => {
            return changedFiles
              .filter(
                ((dir = pkg.dir),
                subdir => isSubdir__default.default(dir, subdir))
              )
              .forEach(fileName => {
                const prevPkg = fileToPackage[fileName] || {
                  dir: '',
                }
                pkg.dir.length > prevPkg.dir.length &&
                  (fileToPackage[fileName] = pkg)
              })
            var dir
          }),
          Object.values(fileToPackage).filter(
            (pkg, idx, packages) => packages.indexOf(pkg) === idx
          )
        )
      }

      async function tagExists(tagStr, cwd) {
        return !!(
          await spawn__default.default('git', ['tag', '-l', tagStr], {
            cwd: cwd,
          })
        ).stdout
          .toString()
          .trim()
      }

      async function getCurrentCommitId({ cwd: cwd }) {
        return (
          await spawn__default.default(
            'git',
            ['rev-parse', '--short', 'HEAD'],
            {
              cwd: cwd,
            }
          )
        ).stdout
          .toString()
          .trim()
      }

      async function remoteTagExists(tagStr) {
        return !!(
          await spawn__default.default('git', [
            'ls-remote',
            '--tags',
            'origin',
            '-l',
            tagStr,
          ])
        ).stdout
          .toString()
          .trim()
      }

      ;(exports.add = add),
        (exports.commit = commit),
        (exports.deepenCloneBy = deepenCloneBy),
        (exports.getAllTags = getAllTags),
        (exports.getChangedChangesetFilesSinceRef =
          getChangedChangesetFilesSinceRef),
        (exports.getChangedFilesSince = getChangedFilesSince),
        (exports.getChangedPackagesSinceRef = getChangedPackagesSinceRef),
        (exports.getCommitThatAddsFile = getCommitThatAddsFile),
        (exports.getCommitsThatAddFiles = getCommitsThatAddFiles),
        (exports.getCurrentCommitId = getCurrentCommitId),
        (exports.getDivergedCommit = getDivergedCommit),
        (exports.isRepoShallow = isRepoShallow),
        (exports.remoteTagExists = remoteTagExists),
        (exports.tag = tag),
        (exports.tagExists = tagExists)

      /***/
    },

    /***/ 928: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })

      function _interopDefault(ex) {
        return ex && typeof ex === 'object' && 'default' in ex
          ? ex['default']
          : ex
      }

      var chalk = _interopDefault(__nccwpck_require__(6425))
      var util = _interopDefault(__nccwpck_require__(3837))

      let prefix = '🦋 '

      function format(args, customPrefix) {
        let fullPrefix =
          prefix + (customPrefix === undefined ? '' : ' ' + customPrefix)
        return (
          fullPrefix +
          util
            .format('', ...args)
            .split('\n')
            .join('\n' + fullPrefix + ' ')
        )
      }

      function error(...args) {
        console.error(format(args, chalk.red('error')))
      }
      function info(...args) {
        console.info(format(args, chalk.cyan('info')))
      }
      function log(...args) {
        console.log(format(args))
      }
      function success(...args) {
        console.log(format(args, chalk.green('success')))
      }
      function warn(...args) {
        console.warn(format(args, chalk.yellow('warn')))
      }

      exports.error = error
      exports.info = info
      exports.log = log
      exports.prefix = prefix
      exports.success = success
      exports.warn = warn

      /***/
    },

    /***/ 6010: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      if (process.env.NODE_ENV === 'production') {
        module.exports = __nccwpck_require__(4442)
      } else {
        module.exports = __nccwpck_require__(928)
      }

      /***/
    },

    /***/ 4442: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      function _interopDefault(ex) {
        return ex && 'object' == typeof ex && 'default' in ex ? ex.default : ex
      }

      Object.defineProperty(exports, '__esModule', {
        value: !0,
      })

      var chalk = _interopDefault(__nccwpck_require__(6425)),
        util = _interopDefault(__nccwpck_require__(3837))

      let prefix = '🦋 '

      function format(args, customPrefix) {
        let fullPrefix =
          prefix + (void 0 === customPrefix ? '' : ' ' + customPrefix)
        return (
          fullPrefix +
          util
            .format('', ...args)
            .split('\n')
            .join('\n' + fullPrefix + ' ')
        )
      }

      function error(...args) {
        console.error(format(args, chalk.red('error')))
      }

      function info(...args) {
        console.info(format(args, chalk.cyan('info')))
      }

      function log(...args) {
        console.log(format(args))
      }

      function success(...args) {
        console.log(format(args, chalk.green('success')))
      }

      function warn(...args) {
        console.warn(format(args, chalk.yellow('warn')))
      }

      ;(exports.error = error),
        (exports.info = info),
        (exports.log = log),
        (exports.prefix = prefix),
        (exports.success = success),
        (exports.warn = warn)

      /***/
    },

    /***/ 6338: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'
      /* module decorator */ module = __nccwpck_require__.nmd(module)

      const colorConvert = __nccwpck_require__(8842)

      const wrapAnsi16 = (fn, offset) =>
        function () {
          const code = fn.apply(colorConvert, arguments)
          return `\u001B[${code + offset}m`
        }

      const wrapAnsi256 = (fn, offset) =>
        function () {
          const code = fn.apply(colorConvert, arguments)
          return `\u001B[${38 + offset};5;${code}m`
        }

      const wrapAnsi16m = (fn, offset) =>
        function () {
          const rgb = fn.apply(colorConvert, arguments)
          return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`
        }

      function assembleStyles() {
        const codes = new Map()
        const styles = {
          modifier: {
            reset: [0, 0],
            // 21 isn't widely supported and 22 does the same thing
            bold: [1, 22],
            dim: [2, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            hidden: [8, 28],
            strikethrough: [9, 29],
          },
          color: {
            black: [30, 39],
            red: [31, 39],
            green: [32, 39],
            yellow: [33, 39],
            blue: [34, 39],
            magenta: [35, 39],
            cyan: [36, 39],
            white: [37, 39],
            gray: [90, 39],

            // Bright color
            redBright: [91, 39],
            greenBright: [92, 39],
            yellowBright: [93, 39],
            blueBright: [94, 39],
            magentaBright: [95, 39],
            cyanBright: [96, 39],
            whiteBright: [97, 39],
          },
          bgColor: {
            bgBlack: [40, 49],
            bgRed: [41, 49],
            bgGreen: [42, 49],
            bgYellow: [43, 49],
            bgBlue: [44, 49],
            bgMagenta: [45, 49],
            bgCyan: [46, 49],
            bgWhite: [47, 49],

            // Bright color
            bgBlackBright: [100, 49],
            bgRedBright: [101, 49],
            bgGreenBright: [102, 49],
            bgYellowBright: [103, 49],
            bgBlueBright: [104, 49],
            bgMagentaBright: [105, 49],
            bgCyanBright: [106, 49],
            bgWhiteBright: [107, 49],
          },
        }

        // Fix humans
        styles.color.grey = styles.color.gray

        for (const groupName of Object.keys(styles)) {
          const group = styles[groupName]

          for (const styleName of Object.keys(group)) {
            const style = group[styleName]

            styles[styleName] = {
              open: `\u001B[${style[0]}m`,
              close: `\u001B[${style[1]}m`,
            }

            group[styleName] = styles[styleName]

            codes.set(style[0], style[1])
          }

          Object.defineProperty(styles, groupName, {
            value: group,
            enumerable: false,
          })

          Object.defineProperty(styles, 'codes', {
            value: codes,
            enumerable: false,
          })
        }

        const ansi2ansi = n => n
        const rgb2rgb = (r, g, b) => [r, g, b]

        styles.color.close = '\u001B[39m'
        styles.bgColor.close = '\u001B[49m'

        styles.color.ansi = {
          ansi: wrapAnsi16(ansi2ansi, 0),
        }
        styles.color.ansi256 = {
          ansi256: wrapAnsi256(ansi2ansi, 0),
        }
        styles.color.ansi16m = {
          rgb: wrapAnsi16m(rgb2rgb, 0),
        }

        styles.bgColor.ansi = {
          ansi: wrapAnsi16(ansi2ansi, 10),
        }
        styles.bgColor.ansi256 = {
          ansi256: wrapAnsi256(ansi2ansi, 10),
        }
        styles.bgColor.ansi16m = {
          rgb: wrapAnsi16m(rgb2rgb, 10),
        }

        for (let key of Object.keys(colorConvert)) {
          if (typeof colorConvert[key] !== 'object') {
            continue
          }

          const suite = colorConvert[key]

          if (key === 'ansi16') {
            key = 'ansi'
          }

          if ('ansi16' in suite) {
            styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0)
            styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10)
          }

          if ('ansi256' in suite) {
            styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0)
            styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10)
          }

          if ('rgb' in suite) {
            styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0)
            styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10)
          }
        }

        return styles
      }

      // Make the export immutable
      Object.defineProperty(module, 'exports', {
        enumerable: true,
        get: assembleStyles,
      })

      /***/
    },

    /***/ 6425: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const escapeStringRegexp = __nccwpck_require__(8691)
      const ansiStyles = __nccwpck_require__(6338)
      const stdoutColor = __nccwpck_require__(7016).stdout

      const template = __nccwpck_require__(1664)

      const isSimpleWindowsTerm =
        process.platform === 'win32' &&
        !(process.env.TERM || '').toLowerCase().startsWith('xterm')

      // `supportsColor.level` → `ansiStyles.color[name]` mapping
      const levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m']

      // `color-convert` models to exclude from the Chalk API due to conflicts and such
      const skipModels = new Set(['gray'])

      const styles = Object.create(null)

      function applyOptions(obj, options) {
        options = options || {}

        // Detect level if not set manually
        const scLevel = stdoutColor ? stdoutColor.level : 0
        obj.level = options.level === undefined ? scLevel : options.level
        obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0
      }

      function Chalk(options) {
        // We check for this.template here since calling `chalk.constructor()`
        // by itself will have a `this` of a previously constructed chalk object
        if (!this || !(this instanceof Chalk) || this.template) {
          const chalk = {}
          applyOptions(chalk, options)

          chalk.template = function () {
            const args = [].slice.call(arguments)
            return chalkTag.apply(null, [chalk.template].concat(args))
          }

          Object.setPrototypeOf(chalk, Chalk.prototype)
          Object.setPrototypeOf(chalk.template, chalk)

          chalk.template.constructor = Chalk

          return chalk.template
        }

        applyOptions(this, options)
      }

      // Use bright blue on Windows as the normal blue color is illegible
      if (isSimpleWindowsTerm) {
        ansiStyles.blue.open = '\u001B[94m'
      }

      for (const key of Object.keys(ansiStyles)) {
        ansiStyles[key].closeRe = new RegExp(
          escapeStringRegexp(ansiStyles[key].close),
          'g'
        )

        styles[key] = {
          get() {
            const codes = ansiStyles[key]
            return build.call(
              this,
              this._styles ? this._styles.concat(codes) : [codes],
              this._empty,
              key
            )
          },
        }
      }

      styles.visible = {
        get() {
          return build.call(this, this._styles || [], true, 'visible')
        },
      }

      ansiStyles.color.closeRe = new RegExp(
        escapeStringRegexp(ansiStyles.color.close),
        'g'
      )
      for (const model of Object.keys(ansiStyles.color.ansi)) {
        if (skipModels.has(model)) {
          continue
        }

        styles[model] = {
          get() {
            const level = this.level
            return function () {
              const open = ansiStyles.color[levelMapping[level]][model].apply(
                null,
                arguments
              )
              const codes = {
                open,
                close: ansiStyles.color.close,
                closeRe: ansiStyles.color.closeRe,
              }
              return build.call(
                this,
                this._styles ? this._styles.concat(codes) : [codes],
                this._empty,
                model
              )
            }
          },
        }
      }

      ansiStyles.bgColor.closeRe = new RegExp(
        escapeStringRegexp(ansiStyles.bgColor.close),
        'g'
      )
      for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
        if (skipModels.has(model)) {
          continue
        }

        const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1)
        styles[bgModel] = {
          get() {
            const level = this.level
            return function () {
              const open = ansiStyles.bgColor[levelMapping[level]][model].apply(
                null,
                arguments
              )
              const codes = {
                open,
                close: ansiStyles.bgColor.close,
                closeRe: ansiStyles.bgColor.closeRe,
              }
              return build.call(
                this,
                this._styles ? this._styles.concat(codes) : [codes],
                this._empty,
                model
              )
            }
          },
        }
      }

      const proto = Object.defineProperties(() => {}, styles)

      function build(_styles, _empty, key) {
        const builder = function () {
          return applyStyle.apply(builder, arguments)
        }

        builder._styles = _styles
        builder._empty = _empty

        const self = this

        Object.defineProperty(builder, 'level', {
          enumerable: true,
          get() {
            return self.level
          },
          set(level) {
            self.level = level
          },
        })

        Object.defineProperty(builder, 'enabled', {
          enumerable: true,
          get() {
            return self.enabled
          },
          set(enabled) {
            self.enabled = enabled
          },
        })

        // See below for fix regarding invisible grey/dim combination on Windows
        builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey'

        // `__proto__` is used because we must return a function, but there is
        // no way to create a function with a different prototype
        builder.__proto__ = proto // eslint-disable-line no-proto

        return builder
      }

      function applyStyle() {
        // Support varags, but simply cast to string in case there's only one arg
        const args = arguments
        const argsLen = args.length
        let str = String(arguments[0])

        if (argsLen === 0) {
          return ''
        }

        if (argsLen > 1) {
          // Don't slice `arguments`, it prevents V8 optimizations
          for (let a = 1; a < argsLen; a++) {
            str += ' ' + args[a]
          }
        }

        if (!this.enabled || this.level <= 0 || !str) {
          return this._empty ? '' : str
        }

        // Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
        // see https://github.com/chalk/chalk/issues/58
        // If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
        const originalDim = ansiStyles.dim.open
        if (isSimpleWindowsTerm && this.hasGrey) {
          ansiStyles.dim.open = ''
        }

        for (const code of this._styles.slice().reverse()) {
          // Replace any instances already present with a re-opening code
          // otherwise only the part of the string until said closing code
          // will be colored, and the rest will simply be 'plain'.
          str = code.open + str.replace(code.closeRe, code.open) + code.close

          // Close the styling before a linebreak and reopen
          // after next line to fix a bleed issue on macOS
          // https://github.com/chalk/chalk/pull/92
          str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`)
        }

        // Reset the original `dim` if we changed it to work around the Windows dimmed gray issue
        ansiStyles.dim.open = originalDim

        return str
      }

      function chalkTag(chalk, strings) {
        if (!Array.isArray(strings)) {
          // If chalk() was called by itself or with a string,
          // return the string itself as a string.
          return [].slice.call(arguments, 1).join(' ')
        }

        const args = [].slice.call(arguments, 2)
        const parts = [strings.raw[0]]

        for (let i = 1; i < strings.length; i++) {
          parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'))
          parts.push(String(strings.raw[i]))
        }

        return template(chalk, parts.join(''))
      }

      Object.defineProperties(Chalk.prototype, styles)

      module.exports = Chalk() // eslint-disable-line new-cap
      module.exports.supportsColor = stdoutColor
      module.exports['default'] = module.exports // For TypeScript

      /***/
    },

    /***/ 1664: /***/ module => {
      'use strict'

      const TEMPLATE_REGEX =
        /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi
      const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g
      const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/
      const ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi

      const ESCAPES = new Map([
        ['n', '\n'],
        ['r', '\r'],
        ['t', '\t'],
        ['b', '\b'],
        ['f', '\f'],
        ['v', '\v'],
        ['0', '\0'],
        ['\\', '\\'],
        ['e', '\u001B'],
        ['a', '\u0007'],
      ])

      function unescape(c) {
        if (
          (c[0] === 'u' && c.length === 5) ||
          (c[0] === 'x' && c.length === 3)
        ) {
          return String.fromCharCode(parseInt(c.slice(1), 16))
        }

        return ESCAPES.get(c) || c
      }

      function parseArguments(name, args) {
        const results = []
        const chunks = args.trim().split(/\s*,\s*/g)
        let matches

        for (const chunk of chunks) {
          if (!isNaN(chunk)) {
            results.push(Number(chunk))
          } else if ((matches = chunk.match(STRING_REGEX))) {
            results.push(
              matches[2].replace(ESCAPE_REGEX, (m, escape, chr) =>
                escape ? unescape(escape) : chr
              )
            )
          } else {
            throw new Error(
              `Invalid Chalk template style argument: ${chunk} (in style '${name}')`
            )
          }
        }

        return results
      }

      function parseStyle(style) {
        STYLE_REGEX.lastIndex = 0

        const results = []
        let matches

        while ((matches = STYLE_REGEX.exec(style)) !== null) {
          const name = matches[1]

          if (matches[2]) {
            const args = parseArguments(name, matches[2])
            results.push([name].concat(args))
          } else {
            results.push([name])
          }
        }

        return results
      }

      function buildStyle(chalk, styles) {
        const enabled = {}

        for (const layer of styles) {
          for (const style of layer.styles) {
            enabled[style[0]] = layer.inverse ? null : style.slice(1)
          }
        }

        let current = chalk
        for (const styleName of Object.keys(enabled)) {
          if (Array.isArray(enabled[styleName])) {
            if (!(styleName in current)) {
              throw new Error(`Unknown Chalk style: ${styleName}`)
            }

            if (enabled[styleName].length > 0) {
              current = current[styleName].apply(current, enabled[styleName])
            } else {
              current = current[styleName]
            }
          }
        }

        return current
      }

      module.exports = (chalk, tmp) => {
        const styles = []
        const chunks = []
        let chunk = []

        // eslint-disable-next-line max-params
        tmp.replace(
          TEMPLATE_REGEX,
          (m, escapeChar, inverse, style, close, chr) => {
            if (escapeChar) {
              chunk.push(unescape(escapeChar))
            } else if (style) {
              const str = chunk.join('')
              chunk = []
              chunks.push(
                styles.length === 0 ? str : buildStyle(chalk, styles)(str)
              )
              styles.push({ inverse, styles: parseStyle(style) })
            } else if (close) {
              if (styles.length === 0) {
                throw new Error('Found extraneous } in Chalk template literal')
              }

              chunks.push(buildStyle(chalk, styles)(chunk.join('')))
              chunk = []
              styles.pop()
            } else {
              chunk.push(chr)
            }
          }
        )

        chunks.push(chunk.join(''))

        if (styles.length > 0) {
          const errMsg = `Chalk template literal is missing ${
            styles.length
          } closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`
          throw new Error(errMsg)
        }

        return chunks.join('')
      }

      /***/
    },

    /***/ 4698: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      /* MIT license */
      var cssKeywords = __nccwpck_require__(7730)

      // NOTE: conversions should only return primitive values (i.e. arrays, or
      //       values that give correct `typeof` results).
      //       do not use box values types (i.e. Number(), String(), etc.)

      var reverseKeywords = {}
      for (var key in cssKeywords) {
        if (cssKeywords.hasOwnProperty(key)) {
          reverseKeywords[cssKeywords[key]] = key
        }
      }

      var convert = (module.exports = {
        rgb: { channels: 3, labels: 'rgb' },
        hsl: { channels: 3, labels: 'hsl' },
        hsv: { channels: 3, labels: 'hsv' },
        hwb: { channels: 3, labels: 'hwb' },
        cmyk: { channels: 4, labels: 'cmyk' },
        xyz: { channels: 3, labels: 'xyz' },
        lab: { channels: 3, labels: 'lab' },
        lch: { channels: 3, labels: 'lch' },
        hex: { channels: 1, labels: ['hex'] },
        keyword: { channels: 1, labels: ['keyword'] },
        ansi16: { channels: 1, labels: ['ansi16'] },
        ansi256: { channels: 1, labels: ['ansi256'] },
        hcg: { channels: 3, labels: ['h', 'c', 'g'] },
        apple: { channels: 3, labels: ['r16', 'g16', 'b16'] },
        gray: { channels: 1, labels: ['gray'] },
      })

      // hide .channels and .labels properties
      for (var model in convert) {
        if (convert.hasOwnProperty(model)) {
          if (!('channels' in convert[model])) {
            throw new Error('missing channels property: ' + model)
          }

          if (!('labels' in convert[model])) {
            throw new Error('missing channel labels property: ' + model)
          }

          if (convert[model].labels.length !== convert[model].channels) {
            throw new Error('channel and label counts mismatch: ' + model)
          }

          var channels = convert[model].channels
          var labels = convert[model].labels
          delete convert[model].channels
          delete convert[model].labels
          Object.defineProperty(convert[model], 'channels', { value: channels })
          Object.defineProperty(convert[model], 'labels', { value: labels })
        }
      }

      convert.rgb.hsl = function (rgb) {
        var r = rgb[0] / 255
        var g = rgb[1] / 255
        var b = rgb[2] / 255
        var min = Math.min(r, g, b)
        var max = Math.max(r, g, b)
        var delta = max - min
        var h
        var s
        var l

        if (max === min) {
          h = 0
        } else if (r === max) {
          h = (g - b) / delta
        } else if (g === max) {
          h = 2 + (b - r) / delta
        } else if (b === max) {
          h = 4 + (r - g) / delta
        }

        h = Math.min(h * 60, 360)

        if (h < 0) {
          h += 360
        }

        l = (min + max) / 2

        if (max === min) {
          s = 0
        } else if (l <= 0.5) {
          s = delta / (max + min)
        } else {
          s = delta / (2 - max - min)
        }

        return [h, s * 100, l * 100]
      }

      convert.rgb.hsv = function (rgb) {
        var rdif
        var gdif
        var bdif
        var h
        var s

        var r = rgb[0] / 255
        var g = rgb[1] / 255
        var b = rgb[2] / 255
        var v = Math.max(r, g, b)
        var diff = v - Math.min(r, g, b)
        var diffc = function (c) {
          return (v - c) / 6 / diff + 1 / 2
        }

        if (diff === 0) {
          h = s = 0
        } else {
          s = diff / v
          rdif = diffc(r)
          gdif = diffc(g)
          bdif = diffc(b)

          if (r === v) {
            h = bdif - gdif
          } else if (g === v) {
            h = 1 / 3 + rdif - bdif
          } else if (b === v) {
            h = 2 / 3 + gdif - rdif
          }
          if (h < 0) {
            h += 1
          } else if (h > 1) {
            h -= 1
          }
        }

        return [h * 360, s * 100, v * 100]
      }

      convert.rgb.hwb = function (rgb) {
        var r = rgb[0]
        var g = rgb[1]
        var b = rgb[2]
        var h = convert.rgb.hsl(rgb)[0]
        var w = (1 / 255) * Math.min(r, Math.min(g, b))

        b = 1 - (1 / 255) * Math.max(r, Math.max(g, b))

        return [h, w * 100, b * 100]
      }

      convert.rgb.cmyk = function (rgb) {
        var r = rgb[0] / 255
        var g = rgb[1] / 255
        var b = rgb[2] / 255
        var c
        var m
        var y
        var k

        k = Math.min(1 - r, 1 - g, 1 - b)
        c = (1 - r - k) / (1 - k) || 0
        m = (1 - g - k) / (1 - k) || 0
        y = (1 - b - k) / (1 - k) || 0

        return [c * 100, m * 100, y * 100, k * 100]
      }

      /**
       * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
       * */
      function comparativeDistance(x, y) {
        return (
          Math.pow(x[0] - y[0], 2) +
          Math.pow(x[1] - y[1], 2) +
          Math.pow(x[2] - y[2], 2)
        )
      }

      convert.rgb.keyword = function (rgb) {
        var reversed = reverseKeywords[rgb]
        if (reversed) {
          return reversed
        }

        var currentClosestDistance = Infinity
        var currentClosestKeyword

        for (var keyword in cssKeywords) {
          if (cssKeywords.hasOwnProperty(keyword)) {
            var value = cssKeywords[keyword]

            // Compute comparative distance
            var distance = comparativeDistance(rgb, value)

            // Check if its less, if so set as closest
            if (distance < currentClosestDistance) {
              currentClosestDistance = distance
              currentClosestKeyword = keyword
            }
          }
        }

        return currentClosestKeyword
      }

      convert.keyword.rgb = function (keyword) {
        return cssKeywords[keyword]
      }

      convert.rgb.xyz = function (rgb) {
        var r = rgb[0] / 255
        var g = rgb[1] / 255
        var b = rgb[2] / 255

        // assume sRGB
        r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92
        g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92
        b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92

        var x = r * 0.4124 + g * 0.3576 + b * 0.1805
        var y = r * 0.2126 + g * 0.7152 + b * 0.0722
        var z = r * 0.0193 + g * 0.1192 + b * 0.9505

        return [x * 100, y * 100, z * 100]
      }

      convert.rgb.lab = function (rgb) {
        var xyz = convert.rgb.xyz(rgb)
        var x = xyz[0]
        var y = xyz[1]
        var z = xyz[2]
        var l
        var a
        var b

        x /= 95.047
        y /= 100
        z /= 108.883

        x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116
        y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116
        z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116

        l = 116 * y - 16
        a = 500 * (x - y)
        b = 200 * (y - z)

        return [l, a, b]
      }

      convert.hsl.rgb = function (hsl) {
        var h = hsl[0] / 360
        var s = hsl[1] / 100
        var l = hsl[2] / 100
        var t1
        var t2
        var t3
        var rgb
        var val

        if (s === 0) {
          val = l * 255
          return [val, val, val]
        }

        if (l < 0.5) {
          t2 = l * (1 + s)
        } else {
          t2 = l + s - l * s
        }

        t1 = 2 * l - t2

        rgb = [0, 0, 0]
        for (var i = 0; i < 3; i++) {
          t3 = h + (1 / 3) * -(i - 1)
          if (t3 < 0) {
            t3++
          }
          if (t3 > 1) {
            t3--
          }

          if (6 * t3 < 1) {
            val = t1 + (t2 - t1) * 6 * t3
          } else if (2 * t3 < 1) {
            val = t2
          } else if (3 * t3 < 2) {
            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6
          } else {
            val = t1
          }

          rgb[i] = val * 255
        }

        return rgb
      }

      convert.hsl.hsv = function (hsl) {
        var h = hsl[0]
        var s = hsl[1] / 100
        var l = hsl[2] / 100
        var smin = s
        var lmin = Math.max(l, 0.01)
        var sv
        var v

        l *= 2
        s *= l <= 1 ? l : 2 - l
        smin *= lmin <= 1 ? lmin : 2 - lmin
        v = (l + s) / 2
        sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s)

        return [h, sv * 100, v * 100]
      }

      convert.hsv.rgb = function (hsv) {
        var h = hsv[0] / 60
        var s = hsv[1] / 100
        var v = hsv[2] / 100
        var hi = Math.floor(h) % 6

        var f = h - Math.floor(h)
        var p = 255 * v * (1 - s)
        var q = 255 * v * (1 - s * f)
        var t = 255 * v * (1 - s * (1 - f))
        v *= 255

        switch (hi) {
          case 0:
            return [v, t, p]
          case 1:
            return [q, v, p]
          case 2:
            return [p, v, t]
          case 3:
            return [p, q, v]
          case 4:
            return [t, p, v]
          case 5:
            return [v, p, q]
        }
      }

      convert.hsv.hsl = function (hsv) {
        var h = hsv[0]
        var s = hsv[1] / 100
        var v = hsv[2] / 100
        var vmin = Math.max(v, 0.01)
        var lmin
        var sl
        var l

        l = (2 - s) * v
        lmin = (2 - s) * vmin
        sl = s * vmin
        sl /= lmin <= 1 ? lmin : 2 - lmin
        sl = sl || 0
        l /= 2

        return [h, sl * 100, l * 100]
      }

      // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
      convert.hwb.rgb = function (hwb) {
        var h = hwb[0] / 360
        var wh = hwb[1] / 100
        var bl = hwb[2] / 100
        var ratio = wh + bl
        var i
        var v
        var f
        var n

        // wh + bl cant be > 1
        if (ratio > 1) {
          wh /= ratio
          bl /= ratio
        }

        i = Math.floor(6 * h)
        v = 1 - bl
        f = 6 * h - i

        if ((i & 0x01) !== 0) {
          f = 1 - f
        }

        n = wh + f * (v - wh) // linear interpolation

        var r
        var g
        var b
        switch (i) {
          default:
          case 6:
          case 0:
            r = v
            g = n
            b = wh
            break
          case 1:
            r = n
            g = v
            b = wh
            break
          case 2:
            r = wh
            g = v
            b = n
            break
          case 3:
            r = wh
            g = n
            b = v
            break
          case 4:
            r = n
            g = wh
            b = v
            break
          case 5:
            r = v
            g = wh
            b = n
            break
        }

        return [r * 255, g * 255, b * 255]
      }

      convert.cmyk.rgb = function (cmyk) {
        var c = cmyk[0] / 100
        var m = cmyk[1] / 100
        var y = cmyk[2] / 100
        var k = cmyk[3] / 100
        var r
        var g
        var b

        r = 1 - Math.min(1, c * (1 - k) + k)
        g = 1 - Math.min(1, m * (1 - k) + k)
        b = 1 - Math.min(1, y * (1 - k) + k)

        return [r * 255, g * 255, b * 255]
      }

      convert.xyz.rgb = function (xyz) {
        var x = xyz[0] / 100
        var y = xyz[1] / 100
        var z = xyz[2] / 100
        var r
        var g
        var b

        r = x * 3.2406 + y * -1.5372 + z * -0.4986
        g = x * -0.9689 + y * 1.8758 + z * 0.0415
        b = x * 0.0557 + y * -0.204 + z * 1.057

        // assume sRGB
        r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r * 12.92

        g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g * 12.92

        b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b * 12.92

        r = Math.min(Math.max(0, r), 1)
        g = Math.min(Math.max(0, g), 1)
        b = Math.min(Math.max(0, b), 1)

        return [r * 255, g * 255, b * 255]
      }

      convert.xyz.lab = function (xyz) {
        var x = xyz[0]
        var y = xyz[1]
        var z = xyz[2]
        var l
        var a
        var b

        x /= 95.047
        y /= 100
        z /= 108.883

        x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116
        y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116
        z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116

        l = 116 * y - 16
        a = 500 * (x - y)
        b = 200 * (y - z)

        return [l, a, b]
      }

      convert.lab.xyz = function (lab) {
        var l = lab[0]
        var a = lab[1]
        var b = lab[2]
        var x
        var y
        var z

        y = (l + 16) / 116
        x = a / 500 + y
        z = y - b / 200

        var y2 = Math.pow(y, 3)
        var x2 = Math.pow(x, 3)
        var z2 = Math.pow(z, 3)
        y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787
        x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787
        z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787

        x *= 95.047
        y *= 100
        z *= 108.883

        return [x, y, z]
      }

      convert.lab.lch = function (lab) {
        var l = lab[0]
        var a = lab[1]
        var b = lab[2]
        var hr
        var h
        var c

        hr = Math.atan2(b, a)
        h = (hr * 360) / 2 / Math.PI

        if (h < 0) {
          h += 360
        }

        c = Math.sqrt(a * a + b * b)

        return [l, c, h]
      }

      convert.lch.lab = function (lch) {
        var l = lch[0]
        var c = lch[1]
        var h = lch[2]
        var a
        var b
        var hr

        hr = (h / 360) * 2 * Math.PI
        a = c * Math.cos(hr)
        b = c * Math.sin(hr)

        return [l, a, b]
      }

      convert.rgb.ansi16 = function (args) {
        var r = args[0]
        var g = args[1]
        var b = args[2]
        var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2] // hsv -> ansi16 optimization

        value = Math.round(value / 50)

        if (value === 0) {
          return 30
        }

        var ansi =
          30 +
          ((Math.round(b / 255) << 2) |
            (Math.round(g / 255) << 1) |
            Math.round(r / 255))

        if (value === 2) {
          ansi += 60
        }

        return ansi
      }

      convert.hsv.ansi16 = function (args) {
        // optimization here; we already know the value and don't need to get
        // it converted for us.
        return convert.rgb.ansi16(convert.hsv.rgb(args), args[2])
      }

      convert.rgb.ansi256 = function (args) {
        var r = args[0]
        var g = args[1]
        var b = args[2]

        // we use the extended greyscale palette here, with the exception of
        // black and white. normal palette only has 4 greyscale shades.
        if (r === g && g === b) {
          if (r < 8) {
            return 16
          }

          if (r > 248) {
            return 231
          }

          return Math.round(((r - 8) / 247) * 24) + 232
        }

        var ansi =
          16 +
          36 * Math.round((r / 255) * 5) +
          6 * Math.round((g / 255) * 5) +
          Math.round((b / 255) * 5)

        return ansi
      }

      convert.ansi16.rgb = function (args) {
        var color = args % 10

        // handle greyscale
        if (color === 0 || color === 7) {
          if (args > 50) {
            color += 3.5
          }

          color = (color / 10.5) * 255

          return [color, color, color]
        }

        var mult = (~~(args > 50) + 1) * 0.5
        var r = (color & 1) * mult * 255
        var g = ((color >> 1) & 1) * mult * 255
        var b = ((color >> 2) & 1) * mult * 255

        return [r, g, b]
      }

      convert.ansi256.rgb = function (args) {
        // handle greyscale
        if (args >= 232) {
          var c = (args - 232) * 10 + 8
          return [c, c, c]
        }

        args -= 16

        var rem
        var r = (Math.floor(args / 36) / 5) * 255
        var g = (Math.floor((rem = args % 36) / 6) / 5) * 255
        var b = ((rem % 6) / 5) * 255

        return [r, g, b]
      }

      convert.rgb.hex = function (args) {
        var integer =
          ((Math.round(args[0]) & 0xff) << 16) +
          ((Math.round(args[1]) & 0xff) << 8) +
          (Math.round(args[2]) & 0xff)

        var string = integer.toString(16).toUpperCase()
        return '000000'.substring(string.length) + string
      }

      convert.hex.rgb = function (args) {
        var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i)
        if (!match) {
          return [0, 0, 0]
        }

        var colorString = match[0]

        if (match[0].length === 3) {
          colorString = colorString
            .split('')
            .map(function (char) {
              return char + char
            })
            .join('')
        }

        var integer = parseInt(colorString, 16)
        var r = (integer >> 16) & 0xff
        var g = (integer >> 8) & 0xff
        var b = integer & 0xff

        return [r, g, b]
      }

      convert.rgb.hcg = function (rgb) {
        var r = rgb[0] / 255
        var g = rgb[1] / 255
        var b = rgb[2] / 255
        var max = Math.max(Math.max(r, g), b)
        var min = Math.min(Math.min(r, g), b)
        var chroma = max - min
        var grayscale
        var hue

        if (chroma < 1) {
          grayscale = min / (1 - chroma)
        } else {
          grayscale = 0
        }

        if (chroma <= 0) {
          hue = 0
        } else if (max === r) {
          hue = ((g - b) / chroma) % 6
        } else if (max === g) {
          hue = 2 + (b - r) / chroma
        } else {
          hue = 4 + (r - g) / chroma + 4
        }

        hue /= 6
        hue %= 1

        return [hue * 360, chroma * 100, grayscale * 100]
      }

      convert.hsl.hcg = function (hsl) {
        var s = hsl[1] / 100
        var l = hsl[2] / 100
        var c = 1
        var f = 0

        if (l < 0.5) {
          c = 2.0 * s * l
        } else {
          c = 2.0 * s * (1.0 - l)
        }

        if (c < 1.0) {
          f = (l - 0.5 * c) / (1.0 - c)
        }

        return [hsl[0], c * 100, f * 100]
      }

      convert.hsv.hcg = function (hsv) {
        var s = hsv[1] / 100
        var v = hsv[2] / 100

        var c = s * v
        var f = 0

        if (c < 1.0) {
          f = (v - c) / (1 - c)
        }

        return [hsv[0], c * 100, f * 100]
      }

      convert.hcg.rgb = function (hcg) {
        var h = hcg[0] / 360
        var c = hcg[1] / 100
        var g = hcg[2] / 100

        if (c === 0.0) {
          return [g * 255, g * 255, g * 255]
        }

        var pure = [0, 0, 0]
        var hi = (h % 1) * 6
        var v = hi % 1
        var w = 1 - v
        var mg = 0

        switch (Math.floor(hi)) {
          case 0:
            pure[0] = 1
            pure[1] = v
            pure[2] = 0
            break
          case 1:
            pure[0] = w
            pure[1] = 1
            pure[2] = 0
            break
          case 2:
            pure[0] = 0
            pure[1] = 1
            pure[2] = v
            break
          case 3:
            pure[0] = 0
            pure[1] = w
            pure[2] = 1
            break
          case 4:
            pure[0] = v
            pure[1] = 0
            pure[2] = 1
            break
          default:
            pure[0] = 1
            pure[1] = 0
            pure[2] = w
        }

        mg = (1.0 - c) * g

        return [
          (c * pure[0] + mg) * 255,
          (c * pure[1] + mg) * 255,
          (c * pure[2] + mg) * 255,
        ]
      }

      convert.hcg.hsv = function (hcg) {
        var c = hcg[1] / 100
        var g = hcg[2] / 100

        var v = c + g * (1.0 - c)
        var f = 0

        if (v > 0.0) {
          f = c / v
        }

        return [hcg[0], f * 100, v * 100]
      }

      convert.hcg.hsl = function (hcg) {
        var c = hcg[1] / 100
        var g = hcg[2] / 100

        var l = g * (1.0 - c) + 0.5 * c
        var s = 0

        if (l > 0.0 && l < 0.5) {
          s = c / (2 * l)
        } else if (l >= 0.5 && l < 1.0) {
          s = c / (2 * (1 - l))
        }

        return [hcg[0], s * 100, l * 100]
      }

      convert.hcg.hwb = function (hcg) {
        var c = hcg[1] / 100
        var g = hcg[2] / 100
        var v = c + g * (1.0 - c)
        return [hcg[0], (v - c) * 100, (1 - v) * 100]
      }

      convert.hwb.hcg = function (hwb) {
        var w = hwb[1] / 100
        var b = hwb[2] / 100
        var v = 1 - b
        var c = v - w
        var g = 0

        if (c < 1) {
          g = (v - c) / (1 - c)
        }

        return [hwb[0], c * 100, g * 100]
      }

      convert.apple.rgb = function (apple) {
        return [
          (apple[0] / 65535) * 255,
          (apple[1] / 65535) * 255,
          (apple[2] / 65535) * 255,
        ]
      }

      convert.rgb.apple = function (rgb) {
        return [
          (rgb[0] / 255) * 65535,
          (rgb[1] / 255) * 65535,
          (rgb[2] / 255) * 65535,
        ]
      }

      convert.gray.rgb = function (args) {
        return [
          (args[0] / 100) * 255,
          (args[0] / 100) * 255,
          (args[0] / 100) * 255,
        ]
      }

      convert.gray.hsl = convert.gray.hsv = function (args) {
        return [0, 0, args[0]]
      }

      convert.gray.hwb = function (gray) {
        return [0, 100, gray[0]]
      }

      convert.gray.cmyk = function (gray) {
        return [0, 0, 0, gray[0]]
      }

      convert.gray.lab = function (gray) {
        return [gray[0], 0, 0]
      }

      convert.gray.hex = function (gray) {
        var val = Math.round((gray[0] / 100) * 255) & 0xff
        var integer = (val << 16) + (val << 8) + val

        var string = integer.toString(16).toUpperCase()
        return '000000'.substring(string.length) + string
      }

      convert.rgb.gray = function (rgb) {
        var val = (rgb[0] + rgb[1] + rgb[2]) / 3
        return [(val / 255) * 100]
      }

      /***/
    },

    /***/ 8842: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      var conversions = __nccwpck_require__(4698)
      var route = __nccwpck_require__(8891)

      var convert = {}

      var models = Object.keys(conversions)

      function wrapRaw(fn) {
        var wrappedFn = function (args) {
          if (args === undefined || args === null) {
            return args
          }

          if (arguments.length > 1) {
            args = Array.prototype.slice.call(arguments)
          }

          return fn(args)
        }

        // preserve .conversion property if there is one
        if ('conversion' in fn) {
          wrappedFn.conversion = fn.conversion
        }

        return wrappedFn
      }

      function wrapRounded(fn) {
        var wrappedFn = function (args) {
          if (args === undefined || args === null) {
            return args
          }

          if (arguments.length > 1) {
            args = Array.prototype.slice.call(arguments)
          }

          var result = fn(args)

          // we're assuming the result is an array here.
          // see notice in conversions.js; don't use box types
          // in conversion functions.
          if (typeof result === 'object') {
            for (var len = result.length, i = 0; i < len; i++) {
              result[i] = Math.round(result[i])
            }
          }

          return result
        }

        // preserve .conversion property if there is one
        if ('conversion' in fn) {
          wrappedFn.conversion = fn.conversion
        }

        return wrappedFn
      }

      models.forEach(function (fromModel) {
        convert[fromModel] = {}

        Object.defineProperty(convert[fromModel], 'channels', {
          value: conversions[fromModel].channels,
        })
        Object.defineProperty(convert[fromModel], 'labels', {
          value: conversions[fromModel].labels,
        })

        var routes = route(fromModel)
        var routeModels = Object.keys(routes)

        routeModels.forEach(function (toModel) {
          var fn = routes[toModel]

          convert[fromModel][toModel] = wrapRounded(fn)
          convert[fromModel][toModel].raw = wrapRaw(fn)
        })
      })

      module.exports = convert

      /***/
    },

    /***/ 8891: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      var conversions = __nccwpck_require__(4698)

      /*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

      function buildGraph() {
        var graph = {}
        // https://jsperf.com/object-keys-vs-for-in-with-closure/3
        var models = Object.keys(conversions)

        for (var len = models.length, i = 0; i < len; i++) {
          graph[models[i]] = {
            // http://jsperf.com/1-vs-infinity
            // micro-opt, but this is simple.
            distance: -1,
            parent: null,
          }
        }

        return graph
      }

      // https://en.wikipedia.org/wiki/Breadth-first_search
      function deriveBFS(fromModel) {
        var graph = buildGraph()
        var queue = [fromModel] // unshift -> queue -> pop

        graph[fromModel].distance = 0

        while (queue.length) {
          var current = queue.pop()
          var adjacents = Object.keys(conversions[current])

          for (var len = adjacents.length, i = 0; i < len; i++) {
            var adjacent = adjacents[i]
            var node = graph[adjacent]

            if (node.distance === -1) {
              node.distance = graph[current].distance + 1
              node.parent = current
              queue.unshift(adjacent)
            }
          }
        }

        return graph
      }

      function link(from, to) {
        return function (args) {
          return to(from(args))
        }
      }

      function wrapConversion(toModel, graph) {
        var path = [graph[toModel].parent, toModel]
        var fn = conversions[graph[toModel].parent][toModel]

        var cur = graph[toModel].parent
        while (graph[cur].parent) {
          path.unshift(graph[cur].parent)
          fn = link(conversions[graph[cur].parent][cur], fn)
          cur = graph[cur].parent
        }

        fn.conversion = path
        return fn
      }

      module.exports = function (fromModel) {
        var graph = deriveBFS(fromModel)
        var conversion = {}

        var models = Object.keys(graph)
        for (var len = models.length, i = 0; i < len; i++) {
          var toModel = models[i]
          var node = graph[toModel]

          if (node.parent === null) {
            // no possible conversion, or this node is the source model.
            continue
          }

          conversion[toModel] = wrapConversion(toModel, graph)
        }

        return conversion
      }

      /***/
    },

    /***/ 7730: /***/ module => {
      'use strict'

      module.exports = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50],
      }

      /***/
    },

    /***/ 8484: /***/ module => {
      'use strict'

      module.exports = (flag, argv) => {
        argv = argv || process.argv
        const prefix = flag.startsWith('-')
          ? ''
          : flag.length === 1
          ? '-'
          : '--'
        const pos = argv.indexOf(prefix + flag)
        const terminatorPos = argv.indexOf('--')
        return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos)
      }

      /***/
    },

    /***/ 7016: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const os = __nccwpck_require__(2037)
      const hasFlag = __nccwpck_require__(8484)

      const env = process.env

      let forceColor
      if (
        hasFlag('no-color') ||
        hasFlag('no-colors') ||
        hasFlag('color=false')
      ) {
        forceColor = false
      } else if (
        hasFlag('color') ||
        hasFlag('colors') ||
        hasFlag('color=true') ||
        hasFlag('color=always')
      ) {
        forceColor = true
      }
      if ('FORCE_COLOR' in env) {
        forceColor =
          env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0
      }

      function translateLevel(level) {
        if (level === 0) {
          return false
        }

        return {
          level,
          hasBasic: true,
          has256: level >= 2,
          has16m: level >= 3,
        }
      }

      function supportsColor(stream) {
        if (forceColor === false) {
          return 0
        }

        if (
          hasFlag('color=16m') ||
          hasFlag('color=full') ||
          hasFlag('color=truecolor')
        ) {
          return 3
        }

        if (hasFlag('color=256')) {
          return 2
        }

        if (stream && !stream.isTTY && forceColor !== true) {
          return 0
        }

        const min = forceColor ? 1 : 0

        if (process.platform === 'win32') {
          // Node.js 7.5.0 is the first version of Node.js to include a patch to
          // libuv that enables 256 color output on Windows. Anything earlier and it
          // won't work. However, here we target Node.js 8 at minimum as it is an LTS
          // release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
          // release that supports 256 colors. Windows 10 build 14931 is the first release
          // that supports 16m/TrueColor.
          const osRelease = os.release().split('.')
          if (
            Number(process.versions.node.split('.')[0]) >= 8 &&
            Number(osRelease[0]) >= 10 &&
            Number(osRelease[2]) >= 10586
          ) {
            return Number(osRelease[2]) >= 14931 ? 3 : 2
          }

          return 1
        }

        if ('CI' in env) {
          if (
            ['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(
              sign => sign in env
            ) ||
            env.CI_NAME === 'codeship'
          ) {
            return 1
          }

          return min
        }

        if ('TEAMCITY_VERSION' in env) {
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION)
            ? 1
            : 0
        }

        if (env.COLORTERM === 'truecolor') {
          return 3
        }

        if ('TERM_PROGRAM' in env) {
          const version = parseInt(
            (env.TERM_PROGRAM_VERSION || '').split('.')[0],
            10
          )

          switch (env.TERM_PROGRAM) {
            case 'iTerm.app':
              return version >= 3 ? 3 : 2
            case 'Apple_Terminal':
              return 2
            // No default
          }
        }

        if (/-256(color)?$/i.test(env.TERM)) {
          return 2
        }

        if (
          /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(
            env.TERM
          )
        ) {
          return 1
        }

        if ('COLORTERM' in env) {
          return 1
        }

        if (env.TERM === 'dumb') {
          return min
        }

        return min
      }

      function getSupportLevel(stream) {
        const level = supportsColor(stream)
        return translateLevel(level)
      }

      module.exports = {
        supportsColor: getSupportLevel,
        stdout: getSupportLevel(process.stdout),
        stderr: getSupportLevel(process.stderr),
      }

      /***/
    },

    /***/ 8926: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })

      var yaml = __nccwpck_require__(4721)

      function _interopDefault(e) {
        return e && e.__esModule ? e : { default: e }
      }

      var yaml__default = /*#__PURE__*/ _interopDefault(yaml)

      const mdRegex = /\s*---([^]*?)\n\s*---(\s*(?:\n|$)[^]*)/
      function parseChangesetFile(contents) {
        const execResult = mdRegex.exec(contents)

        if (!execResult) {
          throw new Error(
            `could not parse changeset - invalid frontmatter: ${contents}`
          )
        }

        let [, roughReleases, roughSummary] = execResult
        let summary = roughSummary.trim()
        let releases

        try {
          const yamlStuff = yaml__default['default'].safeLoad(roughReleases)

          if (yamlStuff) {
            releases = Object.entries(yamlStuff).map(([name, type]) => ({
              name,
              type,
            }))
          } else {
            releases = []
          }
        } catch (e) {
          throw new Error(
            `could not parse changeset - invalid frontmatter: ${contents}`
          )
        }

        if (!releases) {
          throw new Error(
            `could not parse changeset - unknown error: ${contents}`
          )
        }

        return {
          releases,
          summary,
        }
      }

      exports['default'] = parseChangesetFile

      /***/
    },

    /***/ 9758: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      if (process.env.NODE_ENV === 'production') {
        module.exports = __nccwpck_require__(7575)
      } else {
        module.exports = __nccwpck_require__(8926)
      }

      /***/
    },

    /***/ 7575: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: !0,
      })

      var yaml = __nccwpck_require__(4721)

      function _interopDefault(e) {
        return e && e.__esModule
          ? e
          : {
              default: e,
            }
      }

      var yaml__default = _interopDefault(yaml)

      const mdRegex = /\s*---([^]*?)\n\s*---(\s*(?:\n|$)[^]*)/

      function parseChangesetFile(contents) {
        const execResult = mdRegex.exec(contents)
        if (!execResult)
          throw new Error(
            'could not parse changeset - invalid frontmatter: ' + contents
          )
        let releases,
          [, roughReleases, roughSummary] = execResult,
          summary = roughSummary.trim()
        try {
          const yamlStuff = yaml__default.default.safeLoad(roughReleases)
          releases = yamlStuff
            ? Object.entries(yamlStuff).map(([name, type]) => ({
                name: name,
                type: type,
              }))
            : []
        } catch (e) {
          throw new Error(
            'could not parse changeset - invalid frontmatter: ' + contents
          )
        }
        if (!releases)
          throw new Error(
            'could not parse changeset - unknown error: ' + contents
          )
        return {
          releases: releases,
          summary: summary,
        }
      }

      exports['default'] = parseChangesetFile

      /***/
    },

    /***/ 4721: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var yaml = __nccwpck_require__(2428)

      module.exports = yaml

      /***/
    },

    /***/ 2428: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var loader = __nccwpck_require__(3794)
      var dumper = __nccwpck_require__(9142)

      function deprecated(name) {
        return function () {
          throw new Error(
            'Function ' + name + ' is deprecated and cannot be used.'
          )
        }
      }

      module.exports.Type = __nccwpck_require__(8971)
      module.exports.Schema = __nccwpck_require__(2434)
      module.exports.FAILSAFE_SCHEMA = __nccwpck_require__(2617)
      module.exports.JSON_SCHEMA = __nccwpck_require__(8129)
      module.exports.CORE_SCHEMA = __nccwpck_require__(5737)
      module.exports.DEFAULT_SAFE_SCHEMA = __nccwpck_require__(7920)
      module.exports.DEFAULT_FULL_SCHEMA = __nccwpck_require__(9219)
      module.exports.load = loader.load
      module.exports.loadAll = loader.loadAll
      module.exports.safeLoad = loader.safeLoad
      module.exports.safeLoadAll = loader.safeLoadAll
      module.exports.dump = dumper.dump
      module.exports.safeDump = dumper.safeDump
      module.exports.YAMLException = __nccwpck_require__(4665)

      // Deprecated schema names from JS-YAML 2.0.x
      module.exports.MINIMAL_SCHEMA = __nccwpck_require__(2617)
      module.exports.SAFE_SCHEMA = __nccwpck_require__(7920)
      module.exports.DEFAULT_SCHEMA = __nccwpck_require__(9219)

      // Deprecated functions from JS-YAML 1.x.x
      module.exports.scan = deprecated('scan')
      module.exports.parse = deprecated('parse')
      module.exports.compose = deprecated('compose')
      module.exports.addConstructor = deprecated('addConstructor')

      /***/
    },

    /***/ 3209: /***/ module => {
      'use strict'

      function isNothing(subject) {
        return typeof subject === 'undefined' || subject === null
      }

      function isObject(subject) {
        return typeof subject === 'object' && subject !== null
      }

      function toArray(sequence) {
        if (Array.isArray(sequence)) return sequence
        else if (isNothing(sequence)) return []

        return [sequence]
      }

      function extend(target, source) {
        var index, length, key, sourceKeys

        if (source) {
          sourceKeys = Object.keys(source)

          for (
            index = 0, length = sourceKeys.length;
            index < length;
            index += 1
          ) {
            key = sourceKeys[index]
            target[key] = source[key]
          }
        }

        return target
      }

      function repeat(string, count) {
        var result = '',
          cycle

        for (cycle = 0; cycle < count; cycle += 1) {
          result += string
        }

        return result
      }

      function isNegativeZero(number) {
        return number === 0 && Number.NEGATIVE_INFINITY === 1 / number
      }

      module.exports.isNothing = isNothing
      module.exports.isObject = isObject
      module.exports.toArray = toArray
      module.exports.repeat = repeat
      module.exports.isNegativeZero = isNegativeZero
      module.exports.extend = extend

      /***/
    },

    /***/ 9142: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      /*eslint-disable no-use-before-define*/

      var common = __nccwpck_require__(3209)
      var YAMLException = __nccwpck_require__(4665)
      var DEFAULT_FULL_SCHEMA = __nccwpck_require__(9219)
      var DEFAULT_SAFE_SCHEMA = __nccwpck_require__(7920)

      var _toString = Object.prototype.toString
      var _hasOwnProperty = Object.prototype.hasOwnProperty

      var CHAR_TAB = 0x09 /* Tab */
      var CHAR_LINE_FEED = 0x0a /* LF */
      var CHAR_CARRIAGE_RETURN = 0x0d /* CR */
      var CHAR_SPACE = 0x20 /* Space */
      var CHAR_EXCLAMATION = 0x21 /* ! */
      var CHAR_DOUBLE_QUOTE = 0x22 /* " */
      var CHAR_SHARP = 0x23 /* # */
      var CHAR_PERCENT = 0x25 /* % */
      var CHAR_AMPERSAND = 0x26 /* & */
      var CHAR_SINGLE_QUOTE = 0x27 /* ' */
      var CHAR_ASTERISK = 0x2a /* * */
      var CHAR_COMMA = 0x2c /* , */
      var CHAR_MINUS = 0x2d /* - */
      var CHAR_COLON = 0x3a /* : */
      var CHAR_EQUALS = 0x3d /* = */
      var CHAR_GREATER_THAN = 0x3e /* > */
      var CHAR_QUESTION = 0x3f /* ? */
      var CHAR_COMMERCIAL_AT = 0x40 /* @ */
      var CHAR_LEFT_SQUARE_BRACKET = 0x5b /* [ */
      var CHAR_RIGHT_SQUARE_BRACKET = 0x5d /* ] */
      var CHAR_GRAVE_ACCENT = 0x60 /* ` */
      var CHAR_LEFT_CURLY_BRACKET = 0x7b /* { */
      var CHAR_VERTICAL_LINE = 0x7c /* | */
      var CHAR_RIGHT_CURLY_BRACKET = 0x7d /* } */

      var ESCAPE_SEQUENCES = {}

      ESCAPE_SEQUENCES[0x00] = '\\0'
      ESCAPE_SEQUENCES[0x07] = '\\a'
      ESCAPE_SEQUENCES[0x08] = '\\b'
      ESCAPE_SEQUENCES[0x09] = '\\t'
      ESCAPE_SEQUENCES[0x0a] = '\\n'
      ESCAPE_SEQUENCES[0x0b] = '\\v'
      ESCAPE_SEQUENCES[0x0c] = '\\f'
      ESCAPE_SEQUENCES[0x0d] = '\\r'
      ESCAPE_SEQUENCES[0x1b] = '\\e'
      ESCAPE_SEQUENCES[0x22] = '\\"'
      ESCAPE_SEQUENCES[0x5c] = '\\\\'
      ESCAPE_SEQUENCES[0x85] = '\\N'
      ESCAPE_SEQUENCES[0xa0] = '\\_'
      ESCAPE_SEQUENCES[0x2028] = '\\L'
      ESCAPE_SEQUENCES[0x2029] = '\\P'

      var DEPRECATED_BOOLEANS_SYNTAX = [
        'y',
        'Y',
        'yes',
        'Yes',
        'YES',
        'on',
        'On',
        'ON',
        'n',
        'N',
        'no',
        'No',
        'NO',
        'off',
        'Off',
        'OFF',
      ]

      function compileStyleMap(schema, map) {
        var result, keys, index, length, tag, style, type

        if (map === null) return {}

        result = {}
        keys = Object.keys(map)

        for (index = 0, length = keys.length; index < length; index += 1) {
          tag = keys[index]
          style = String(map[tag])

          if (tag.slice(0, 2) === '!!') {
            tag = 'tag:yaml.org,2002:' + tag.slice(2)
          }
          type = schema.compiledTypeMap['fallback'][tag]

          if (type && _hasOwnProperty.call(type.styleAliases, style)) {
            style = type.styleAliases[style]
          }

          result[tag] = style
        }

        return result
      }

      function encodeHex(character) {
        var string, handle, length

        string = character.toString(16).toUpperCase()

        if (character <= 0xff) {
          handle = 'x'
          length = 2
        } else if (character <= 0xffff) {
          handle = 'u'
          length = 4
        } else if (character <= 0xffffffff) {
          handle = 'U'
          length = 8
        } else {
          throw new YAMLException(
            'code point within a string may not be greater than 0xFFFFFFFF'
          )
        }

        return (
          '\\' + handle + common.repeat('0', length - string.length) + string
        )
      }

      function State(options) {
        this.schema = options['schema'] || DEFAULT_FULL_SCHEMA
        this.indent = Math.max(1, options['indent'] || 2)
        this.noArrayIndent = options['noArrayIndent'] || false
        this.skipInvalid = options['skipInvalid'] || false
        this.flowLevel = common.isNothing(options['flowLevel'])
          ? -1
          : options['flowLevel']
        this.styleMap = compileStyleMap(this.schema, options['styles'] || null)
        this.sortKeys = options['sortKeys'] || false
        this.lineWidth = options['lineWidth'] || 80
        this.noRefs = options['noRefs'] || false
        this.noCompatMode = options['noCompatMode'] || false
        this.condenseFlow = options['condenseFlow'] || false

        this.implicitTypes = this.schema.compiledImplicit
        this.explicitTypes = this.schema.compiledExplicit

        this.tag = null
        this.result = ''

        this.duplicates = []
        this.usedDuplicates = null
      }

      // Indents every line in a string. Empty lines (\n only) are not indented.
      function indentString(string, spaces) {
        var ind = common.repeat(' ', spaces),
          position = 0,
          next = -1,
          result = '',
          line,
          length = string.length

        while (position < length) {
          next = string.indexOf('\n', position)
          if (next === -1) {
            line = string.slice(position)
            position = length
          } else {
            line = string.slice(position, next + 1)
            position = next + 1
          }

          if (line.length && line !== '\n') result += ind

          result += line
        }

        return result
      }

      function generateNextLine(state, level) {
        return '\n' + common.repeat(' ', state.indent * level)
      }

      function testImplicitResolving(state, str) {
        var index, length, type

        for (
          index = 0, length = state.implicitTypes.length;
          index < length;
          index += 1
        ) {
          type = state.implicitTypes[index]

          if (type.resolve(str)) {
            return true
          }
        }

        return false
      }

      // [33] s-white ::= s-space | s-tab
      function isWhitespace(c) {
        return c === CHAR_SPACE || c === CHAR_TAB
      }

      // Returns true if the character can be printed without escaping.
      // From YAML 1.2: "any allowed characters known to be non-printable
      // should also be escaped. [However,] This isn’t mandatory"
      // Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
      function isPrintable(c) {
        return (
          (0x00020 <= c && c <= 0x00007e) ||
          (0x000a1 <= c && c <= 0x00d7ff && c !== 0x2028 && c !== 0x2029) ||
          (0x0e000 <= c && c <= 0x00fffd && c !== 0xfeff) /* BOM */ ||
          (0x10000 <= c && c <= 0x10ffff)
        )
      }

      // [34] ns-char ::= nb-char - s-white
      // [27] nb-char ::= c-printable - b-char - c-byte-order-mark
      // [26] b-char  ::= b-line-feed | b-carriage-return
      // [24] b-line-feed       ::=     #xA    /* LF */
      // [25] b-carriage-return ::=     #xD    /* CR */
      // [3]  c-byte-order-mark ::=     #xFEFF
      function isNsChar(c) {
        return (
          isPrintable(c) &&
          !isWhitespace(c) &&
          // byte-order-mark
          c !== 0xfeff &&
          // b-char
          c !== CHAR_CARRIAGE_RETURN &&
          c !== CHAR_LINE_FEED
        )
      }

      // Simplified test for values allowed after the first character in plain style.
      function isPlainSafe(c, prev) {
        // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
        // where nb-char ::= c-printable - b-char - c-byte-order-mark.
        return (
          isPrintable(c) &&
          c !== 0xfeff &&
          // - c-flow-indicator
          c !== CHAR_COMMA &&
          c !== CHAR_LEFT_SQUARE_BRACKET &&
          c !== CHAR_RIGHT_SQUARE_BRACKET &&
          c !== CHAR_LEFT_CURLY_BRACKET &&
          c !== CHAR_RIGHT_CURLY_BRACKET &&
          // - ":" - "#"
          // /* An ns-char preceding */ "#"
          c !== CHAR_COLON &&
          (c !== CHAR_SHARP || (prev && isNsChar(prev)))
        )
      }

      // Simplified test for values allowed as the first character in plain style.
      function isPlainSafeFirst(c) {
        // Uses a subset of ns-char - c-indicator
        // where ns-char = nb-char - s-white.
        return (
          isPrintable(c) &&
          c !== 0xfeff &&
          !isWhitespace(c) && // - s-white
          // - (c-indicator ::=
          // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
          c !== CHAR_MINUS &&
          c !== CHAR_QUESTION &&
          c !== CHAR_COLON &&
          c !== CHAR_COMMA &&
          c !== CHAR_LEFT_SQUARE_BRACKET &&
          c !== CHAR_RIGHT_SQUARE_BRACKET &&
          c !== CHAR_LEFT_CURLY_BRACKET &&
          c !== CHAR_RIGHT_CURLY_BRACKET &&
          // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “"”
          c !== CHAR_SHARP &&
          c !== CHAR_AMPERSAND &&
          c !== CHAR_ASTERISK &&
          c !== CHAR_EXCLAMATION &&
          c !== CHAR_VERTICAL_LINE &&
          c !== CHAR_EQUALS &&
          c !== CHAR_GREATER_THAN &&
          c !== CHAR_SINGLE_QUOTE &&
          c !== CHAR_DOUBLE_QUOTE &&
          // | “%” | “@” | “`”)
          c !== CHAR_PERCENT &&
          c !== CHAR_COMMERCIAL_AT &&
          c !== CHAR_GRAVE_ACCENT
        )
      }

      // Determines whether block indentation indicator is required.
      function needIndentIndicator(string) {
        var leadingSpaceRe = /^\n* /
        return leadingSpaceRe.test(string)
      }

      var STYLE_PLAIN = 1,
        STYLE_SINGLE = 2,
        STYLE_LITERAL = 3,
        STYLE_FOLDED = 4,
        STYLE_DOUBLE = 5

      // Determines which scalar styles are possible and returns the preferred style.
      // lineWidth = -1 => no limit.
      // Pre-conditions: str.length > 0.
      // Post-conditions:
      //    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
      //    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
      //    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
      function chooseScalarStyle(
        string,
        singleLineOnly,
        indentPerLevel,
        lineWidth,
        testAmbiguousType
      ) {
        var i
        var char, prev_char
        var hasLineBreak = false
        var hasFoldableLine = false // only checked if shouldTrackWidth
        var shouldTrackWidth = lineWidth !== -1
        var previousLineBreak = -1 // count the first line correctly
        var plain =
          isPlainSafeFirst(string.charCodeAt(0)) &&
          !isWhitespace(string.charCodeAt(string.length - 1))

        if (singleLineOnly) {
          // Case: no block styles.
          // Check for disallowed characters to rule out plain and single.
          for (i = 0; i < string.length; i++) {
            char = string.charCodeAt(i)
            if (!isPrintable(char)) {
              return STYLE_DOUBLE
            }
            prev_char = i > 0 ? string.charCodeAt(i - 1) : null
            plain = plain && isPlainSafe(char, prev_char)
          }
        } else {
          // Case: block styles permitted.
          for (i = 0; i < string.length; i++) {
            char = string.charCodeAt(i)
            if (char === CHAR_LINE_FEED) {
              hasLineBreak = true
              // Check if any line can be folded.
              if (shouldTrackWidth) {
                hasFoldableLine =
                  hasFoldableLine ||
                  // Foldable line = too long, and not more-indented.
                  (i - previousLineBreak - 1 > lineWidth &&
                    string[previousLineBreak + 1] !== ' ')
                previousLineBreak = i
              }
            } else if (!isPrintable(char)) {
              return STYLE_DOUBLE
            }
            prev_char = i > 0 ? string.charCodeAt(i - 1) : null
            plain = plain && isPlainSafe(char, prev_char)
          }
          // in case the end is missing a \n
          hasFoldableLine =
            hasFoldableLine ||
            (shouldTrackWidth &&
              i - previousLineBreak - 1 > lineWidth &&
              string[previousLineBreak + 1] !== ' ')
        }
        // Although every style can represent \n without escaping, prefer block styles
        // for multiline, since they're more readable and they don't add empty lines.
        // Also prefer folding a super-long line.
        if (!hasLineBreak && !hasFoldableLine) {
          // Strings interpretable as another type have to be quoted;
          // e.g. the string 'true' vs. the boolean true.
          return plain && !testAmbiguousType(string)
            ? STYLE_PLAIN
            : STYLE_SINGLE
        }
        // Edge case: block indentation indicator can only have one digit.
        if (indentPerLevel > 9 && needIndentIndicator(string)) {
          return STYLE_DOUBLE
        }
        // At this point we know block styles are valid.
        // Prefer literal style unless we want to fold.
        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL
      }

      // Note: line breaking/folding is implemented for only the folded style.
      // NB. We drop the last trailing newline (if any) of a returned block scalar
      //  since the dumper adds its own newline. This always works:
      //    • No ending newline => unaffected; already using strip "-" chomping.
      //    • Ending newline    => removed then restored.
      //  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
      function writeScalar(state, string, level, iskey) {
        state.dump = (function () {
          if (string.length === 0) {
            return "''"
          }
          if (
            !state.noCompatMode &&
            DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1
          ) {
            return "'" + string + "'"
          }

          var indent = state.indent * Math.max(1, level) // no 0-indent scalars
          // As indentation gets deeper, let the width decrease monotonically
          // to the lower bound min(state.lineWidth, 40).
          // Note that this implies
          //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
          //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
          // This behaves better than a constant minimum width which disallows narrower options,
          // or an indent threshold which causes the width to suddenly increase.
          var lineWidth =
            state.lineWidth === -1
              ? -1
              : Math.max(
                  Math.min(state.lineWidth, 40),
                  state.lineWidth - indent
                )

          // Without knowing if keys are implicit/explicit, assume implicit for safety.
          var singleLineOnly =
            iskey ||
            // No block styles in flow mode.
            (state.flowLevel > -1 && level >= state.flowLevel)
          function testAmbiguity(string) {
            return testImplicitResolving(state, string)
          }

          switch (
            chooseScalarStyle(
              string,
              singleLineOnly,
              state.indent,
              lineWidth,
              testAmbiguity
            )
          ) {
            case STYLE_PLAIN:
              return string
            case STYLE_SINGLE:
              return "'" + string.replace(/'/g, "''") + "'"
            case STYLE_LITERAL:
              return (
                '|' +
                blockHeader(string, state.indent) +
                dropEndingNewline(indentString(string, indent))
              )
            case STYLE_FOLDED:
              return (
                '>' +
                blockHeader(string, state.indent) +
                dropEndingNewline(
                  indentString(foldString(string, lineWidth), indent)
                )
              )
            case STYLE_DOUBLE:
              return '"' + escapeString(string, lineWidth) + '"'
            default:
              throw new YAMLException('impossible error: invalid scalar style')
          }
        })()
      }

      // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
      function blockHeader(string, indentPerLevel) {
        var indentIndicator = needIndentIndicator(string)
          ? String(indentPerLevel)
          : ''

        // note the special case: the string '\n' counts as a "trailing" empty line.
        var clip = string[string.length - 1] === '\n'
        var keep =
          clip && (string[string.length - 2] === '\n' || string === '\n')
        var chomp = keep ? '+' : clip ? '' : '-'

        return indentIndicator + chomp + '\n'
      }

      // (See the note for writeScalar.)
      function dropEndingNewline(string) {
        return string[string.length - 1] === '\n' ? string.slice(0, -1) : string
      }

      // Note: a long line without a suitable break point will exceed the width limit.
      // Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
      function foldString(string, width) {
        // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
        // unless they're before or after a more-indented line, or at the very
        // beginning or end, in which case $k$ maps to $k$.
        // Therefore, parse each chunk as newline(s) followed by a content line.
        var lineRe = /(\n+)([^\n]*)/g

        // first line (possibly an empty line)
        var result = (function () {
          var nextLF = string.indexOf('\n')
          nextLF = nextLF !== -1 ? nextLF : string.length
          lineRe.lastIndex = nextLF
          return foldLine(string.slice(0, nextLF), width)
        })()
        // If we haven't reached the first content line yet, don't add an extra \n.
        var prevMoreIndented = string[0] === '\n' || string[0] === ' '
        var moreIndented

        // rest of the lines
        var match
        while ((match = lineRe.exec(string))) {
          var prefix = match[1],
            line = match[2]
          moreIndented = line[0] === ' '
          result +=
            prefix +
            (!prevMoreIndented && !moreIndented && line !== '' ? '\n' : '') +
            foldLine(line, width)
          prevMoreIndented = moreIndented
        }

        return result
      }

      // Greedy line breaking.
      // Picks the longest line under the limit each time,
      // otherwise settles for the shortest line over the limit.
      // NB. More-indented lines *cannot* be folded, as that would add an extra \n.
      function foldLine(line, width) {
        if (line === '' || line[0] === ' ') return line

        // Since a more-indented line adds a \n, breaks can't be followed by a space.
        var breakRe = / [^ ]/g // note: the match index will always be <= length-2.
        var match
        // start is an inclusive index. end, curr, and next are exclusive.
        var start = 0,
          end,
          curr = 0,
          next = 0
        var result = ''

        // Invariants: 0 <= start <= length-1.
        //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
        // Inside the loop:
        //   A match implies length >= 2, so curr and next are <= length-2.
        while ((match = breakRe.exec(line))) {
          next = match.index
          // maintain invariant: curr - start <= width
          if (next - start > width) {
            end = curr > start ? curr : next // derive end <= length-2
            result += '\n' + line.slice(start, end)
            // skip the space that was output as \n
            start = end + 1 // derive start <= length-1
          }
          curr = next
        }

        // By the invariants, start <= length-1, so there is something left over.
        // It is either the whole string or a part starting from non-whitespace.
        result += '\n'
        // Insert a break if the remainder is too long and there is a break available.
        if (line.length - start > width && curr > start) {
          result += line.slice(start, curr) + '\n' + line.slice(curr + 1)
        } else {
          result += line.slice(start)
        }

        return result.slice(1) // drop extra \n joiner
      }

      // Escapes a double-quoted string.
      function escapeString(string) {
        var result = ''
        var char, nextChar
        var escapeSeq

        for (var i = 0; i < string.length; i++) {
          char = string.charCodeAt(i)
          // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
          if (char >= 0xd800 && char <= 0xdbff /* high surrogate */) {
            nextChar = string.charCodeAt(i + 1)
            if (nextChar >= 0xdc00 && nextChar <= 0xdfff /* low surrogate */) {
              // Combine the surrogate pair and store it escaped.
              result += encodeHex(
                (char - 0xd800) * 0x400 + nextChar - 0xdc00 + 0x10000
              )
              // Advance index one extra since we already used that char here.
              i++
              continue
            }
          }
          escapeSeq = ESCAPE_SEQUENCES[char]
          result +=
            !escapeSeq && isPrintable(char)
              ? string[i]
              : escapeSeq || encodeHex(char)
        }

        return result
      }

      function writeFlowSequence(state, level, object) {
        var _result = '',
          _tag = state.tag,
          index,
          length

        for (index = 0, length = object.length; index < length; index += 1) {
          // Write only valid elements.
          if (writeNode(state, level, object[index], false, false)) {
            if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '')
            _result += state.dump
          }
        }

        state.tag = _tag
        state.dump = '[' + _result + ']'
      }

      function writeBlockSequence(state, level, object, compact) {
        var _result = '',
          _tag = state.tag,
          index,
          length

        for (index = 0, length = object.length; index < length; index += 1) {
          // Write only valid elements.
          if (writeNode(state, level + 1, object[index], true, true)) {
            if (!compact || index !== 0) {
              _result += generateNextLine(state, level)
            }

            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
              _result += '-'
            } else {
              _result += '- '
            }

            _result += state.dump
          }
        }

        state.tag = _tag
        state.dump = _result || '[]' // Empty sequence if no valid values.
      }

      function writeFlowMapping(state, level, object) {
        var _result = '',
          _tag = state.tag,
          objectKeyList = Object.keys(object),
          index,
          length,
          objectKey,
          objectValue,
          pairBuffer

        for (
          index = 0, length = objectKeyList.length;
          index < length;
          index += 1
        ) {
          pairBuffer = ''
          if (index !== 0) pairBuffer += ', '

          if (state.condenseFlow) pairBuffer += '"'

          objectKey = objectKeyList[index]
          objectValue = object[objectKey]

          if (!writeNode(state, level, objectKey, false, false)) {
            continue // Skip this pair because of invalid key;
          }

          if (state.dump.length > 1024) pairBuffer += '? '

          pairBuffer +=
            state.dump +
            (state.condenseFlow ? '"' : '') +
            ':' +
            (state.condenseFlow ? '' : ' ')

          if (!writeNode(state, level, objectValue, false, false)) {
            continue // Skip this pair because of invalid value.
          }

          pairBuffer += state.dump

          // Both key and value are valid.
          _result += pairBuffer
        }

        state.tag = _tag
        state.dump = '{' + _result + '}'
      }

      function writeBlockMapping(state, level, object, compact) {
        var _result = '',
          _tag = state.tag,
          objectKeyList = Object.keys(object),
          index,
          length,
          objectKey,
          objectValue,
          explicitPair,
          pairBuffer

        // Allow sorting keys so that the output file is deterministic
        if (state.sortKeys === true) {
          // Default sorting
          objectKeyList.sort()
        } else if (typeof state.sortKeys === 'function') {
          // Custom sort function
          objectKeyList.sort(state.sortKeys)
        } else if (state.sortKeys) {
          // Something is wrong
          throw new YAMLException('sortKeys must be a boolean or a function')
        }

        for (
          index = 0, length = objectKeyList.length;
          index < length;
          index += 1
        ) {
          pairBuffer = ''

          if (!compact || index !== 0) {
            pairBuffer += generateNextLine(state, level)
          }

          objectKey = objectKeyList[index]
          objectValue = object[objectKey]

          if (!writeNode(state, level + 1, objectKey, true, true, true)) {
            continue // Skip this pair because of invalid key.
          }

          explicitPair =
            (state.tag !== null && state.tag !== '?') ||
            (state.dump && state.dump.length > 1024)

          if (explicitPair) {
            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
              pairBuffer += '?'
            } else {
              pairBuffer += '? '
            }
          }

          pairBuffer += state.dump

          if (explicitPair) {
            pairBuffer += generateNextLine(state, level)
          }

          if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
            continue // Skip this pair because of invalid value.
          }

          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += ':'
          } else {
            pairBuffer += ': '
          }

          pairBuffer += state.dump

          // Both key and value are valid.
          _result += pairBuffer
        }

        state.tag = _tag
        state.dump = _result || '{}' // Empty mapping if no valid pairs.
      }

      function detectType(state, object, explicit) {
        var _result, typeList, index, length, type, style

        typeList = explicit ? state.explicitTypes : state.implicitTypes

        for (index = 0, length = typeList.length; index < length; index += 1) {
          type = typeList[index]

          if (
            (type.instanceOf || type.predicate) &&
            (!type.instanceOf ||
              (typeof object === 'object' &&
                object instanceof type.instanceOf)) &&
            (!type.predicate || type.predicate(object))
          ) {
            state.tag = explicit ? type.tag : '?'

            if (type.represent) {
              style = state.styleMap[type.tag] || type.defaultStyle

              if (_toString.call(type.represent) === '[object Function]') {
                _result = type.represent(object, style)
              } else if (_hasOwnProperty.call(type.represent, style)) {
                _result = type.represent[style](object, style)
              } else {
                throw new YAMLException(
                  '!<' +
                    type.tag +
                    '> tag resolver accepts not "' +
                    style +
                    '" style'
                )
              }

              state.dump = _result
            }

            return true
          }
        }

        return false
      }

      // Serializes `object` and writes it to global `result`.
      // Returns true on success, or false on invalid object.
      //
      function writeNode(state, level, object, block, compact, iskey) {
        state.tag = null
        state.dump = object

        if (!detectType(state, object, false)) {
          detectType(state, object, true)
        }

        var type = _toString.call(state.dump)

        if (block) {
          block = state.flowLevel < 0 || state.flowLevel > level
        }

        var objectOrArray =
            type === '[object Object]' || type === '[object Array]',
          duplicateIndex,
          duplicate

        if (objectOrArray) {
          duplicateIndex = state.duplicates.indexOf(object)
          duplicate = duplicateIndex !== -1
        }

        if (
          (state.tag !== null && state.tag !== '?') ||
          duplicate ||
          (state.indent !== 2 && level > 0)
        ) {
          compact = false
        }

        if (duplicate && state.usedDuplicates[duplicateIndex]) {
          state.dump = '*ref_' + duplicateIndex
        } else {
          if (
            objectOrArray &&
            duplicate &&
            !state.usedDuplicates[duplicateIndex]
          ) {
            state.usedDuplicates[duplicateIndex] = true
          }
          if (type === '[object Object]') {
            if (block && Object.keys(state.dump).length !== 0) {
              writeBlockMapping(state, level, state.dump, compact)
              if (duplicate) {
                state.dump = '&ref_' + duplicateIndex + state.dump
              }
            } else {
              writeFlowMapping(state, level, state.dump)
              if (duplicate) {
                state.dump = '&ref_' + duplicateIndex + ' ' + state.dump
              }
            }
          } else if (type === '[object Array]') {
            var arrayLevel =
              state.noArrayIndent && level > 0 ? level - 1 : level
            if (block && state.dump.length !== 0) {
              writeBlockSequence(state, arrayLevel, state.dump, compact)
              if (duplicate) {
                state.dump = '&ref_' + duplicateIndex + state.dump
              }
            } else {
              writeFlowSequence(state, arrayLevel, state.dump)
              if (duplicate) {
                state.dump = '&ref_' + duplicateIndex + ' ' + state.dump
              }
            }
          } else if (type === '[object String]') {
            if (state.tag !== '?') {
              writeScalar(state, state.dump, level, iskey)
            }
          } else {
            if (state.skipInvalid) return false
            throw new YAMLException(
              'unacceptable kind of an object to dump ' + type
            )
          }

          if (state.tag !== null && state.tag !== '?') {
            state.dump = '!<' + state.tag + '> ' + state.dump
          }
        }

        return true
      }

      function getDuplicateReferences(object, state) {
        var objects = [],
          duplicatesIndexes = [],
          index,
          length

        inspectNode(object, objects, duplicatesIndexes)

        for (
          index = 0, length = duplicatesIndexes.length;
          index < length;
          index += 1
        ) {
          state.duplicates.push(objects[duplicatesIndexes[index]])
        }
        state.usedDuplicates = new Array(length)
      }

      function inspectNode(object, objects, duplicatesIndexes) {
        var objectKeyList, index, length

        if (object !== null && typeof object === 'object') {
          index = objects.indexOf(object)
          if (index !== -1) {
            if (duplicatesIndexes.indexOf(index) === -1) {
              duplicatesIndexes.push(index)
            }
          } else {
            objects.push(object)

            if (Array.isArray(object)) {
              for (
                index = 0, length = object.length;
                index < length;
                index += 1
              ) {
                inspectNode(object[index], objects, duplicatesIndexes)
              }
            } else {
              objectKeyList = Object.keys(object)

              for (
                index = 0, length = objectKeyList.length;
                index < length;
                index += 1
              ) {
                inspectNode(
                  object[objectKeyList[index]],
                  objects,
                  duplicatesIndexes
                )
              }
            }
          }
        }
      }

      function dump(input, options) {
        options = options || {}

        var state = new State(options)

        if (!state.noRefs) getDuplicateReferences(input, state)

        if (writeNode(state, 0, input, true, true)) return state.dump + '\n'

        return ''
      }

      function safeDump(input, options) {
        return dump(
          input,
          common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options)
        )
      }

      module.exports.dump = dump
      module.exports.safeDump = safeDump

      /***/
    },

    /***/ 4665: /***/ module => {
      'use strict'
      // YAML error class. http://stackoverflow.com/questions/8458984
      //

      function YAMLException(reason, mark) {
        // Super constructor
        Error.call(this)

        this.name = 'YAMLException'
        this.reason = reason
        this.mark = mark
        this.message =
          (this.reason || '(unknown reason)') +
          (this.mark ? ' ' + this.mark.toString() : '')

        // Include stack trace in error object
        if (Error.captureStackTrace) {
          // Chrome and NodeJS
          Error.captureStackTrace(this, this.constructor)
        } else {
          // FF, IE 10+ and Safari 6+. Fallback for others
          this.stack = new Error().stack || ''
        }
      }

      // Inherit from Error
      YAMLException.prototype = Object.create(Error.prototype)
      YAMLException.prototype.constructor = YAMLException

      YAMLException.prototype.toString = function toString(compact) {
        var result = this.name + ': '

        result += this.reason || '(unknown reason)'

        if (!compact && this.mark) {
          result += ' ' + this.mark.toString()
        }

        return result
      }

      module.exports = YAMLException

      /***/
    },

    /***/ 3794: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      /*eslint-disable max-len,no-use-before-define*/

      var common = __nccwpck_require__(3209)
      var YAMLException = __nccwpck_require__(4665)
      var Mark = __nccwpck_require__(2813)
      var DEFAULT_SAFE_SCHEMA = __nccwpck_require__(7920)
      var DEFAULT_FULL_SCHEMA = __nccwpck_require__(9219)

      var _hasOwnProperty = Object.prototype.hasOwnProperty

      var CONTEXT_FLOW_IN = 1
      var CONTEXT_FLOW_OUT = 2
      var CONTEXT_BLOCK_IN = 3
      var CONTEXT_BLOCK_OUT = 4

      var CHOMPING_CLIP = 1
      var CHOMPING_STRIP = 2
      var CHOMPING_KEEP = 3

      var PATTERN_NON_PRINTABLE =
        /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/
      var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/
      var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/
      var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i
      var PATTERN_TAG_URI =
        /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i

      function _class(obj) {
        return Object.prototype.toString.call(obj)
      }

      function is_EOL(c) {
        return c === 0x0a /* LF */ || c === 0x0d /* CR */
      }

      function is_WHITE_SPACE(c) {
        return c === 0x09 /* Tab */ || c === 0x20 /* Space */
      }

      function is_WS_OR_EOL(c) {
        return (
          c === 0x09 /* Tab */ ||
          c === 0x20 /* Space */ ||
          c === 0x0a /* LF */ ||
          c === 0x0d /* CR */
        )
      }

      function is_FLOW_INDICATOR(c) {
        return (
          c === 0x2c /* , */ ||
          c === 0x5b /* [ */ ||
          c === 0x5d /* ] */ ||
          c === 0x7b /* { */ ||
          c === 0x7d /* } */
        )
      }

      function fromHexCode(c) {
        var lc

        if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
          return c - 0x30
        }

        /*eslint-disable no-bitwise*/
        lc = c | 0x20

        if (0x61 /* a */ <= lc && lc <= 0x66 /* f */) {
          return lc - 0x61 + 10
        }

        return -1
      }

      function escapedHexLen(c) {
        if (c === 0x78 /* x */) {
          return 2
        }
        if (c === 0x75 /* u */) {
          return 4
        }
        if (c === 0x55 /* U */) {
          return 8
        }
        return 0
      }

      function fromDecimalCode(c) {
        if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
          return c - 0x30
        }

        return -1
      }

      function simpleEscapeSequence(c) {
        /* eslint-disable indent */
        return c === 0x30 /* 0 */
          ? '\x00'
          : c === 0x61 /* a */
          ? '\x07'
          : c === 0x62 /* b */
          ? '\x08'
          : c === 0x74 /* t */
          ? '\x09'
          : c === 0x09 /* Tab */
          ? '\x09'
          : c === 0x6e /* n */
          ? '\x0A'
          : c === 0x76 /* v */
          ? '\x0B'
          : c === 0x66 /* f */
          ? '\x0C'
          : c === 0x72 /* r */
          ? '\x0D'
          : c === 0x65 /* e */
          ? '\x1B'
          : c === 0x20 /* Space */
          ? ' '
          : c === 0x22 /* " */
          ? '\x22'
          : c === 0x2f /* / */
          ? '/'
          : c === 0x5c /* \ */
          ? '\x5C'
          : c === 0x4e /* N */
          ? '\x85'
          : c === 0x5f /* _ */
          ? '\xA0'
          : c === 0x4c /* L */
          ? '\u2028'
          : c === 0x50 /* P */
          ? '\u2029'
          : ''
      }

      function charFromCodepoint(c) {
        if (c <= 0xffff) {
          return String.fromCharCode(c)
        }
        // Encode UTF-16 surrogate pair
        // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
        return String.fromCharCode(
          ((c - 0x010000) >> 10) + 0xd800,
          ((c - 0x010000) & 0x03ff) + 0xdc00
        )
      }

      var simpleEscapeCheck = new Array(256) // integer, for fast access
      var simpleEscapeMap = new Array(256)
      for (var i = 0; i < 256; i++) {
        simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0
        simpleEscapeMap[i] = simpleEscapeSequence(i)
      }

      function State(input, options) {
        this.input = input

        this.filename = options['filename'] || null
        this.schema = options['schema'] || DEFAULT_FULL_SCHEMA
        this.onWarning = options['onWarning'] || null
        this.legacy = options['legacy'] || false
        this.json = options['json'] || false
        this.listener = options['listener'] || null

        this.implicitTypes = this.schema.compiledImplicit
        this.typeMap = this.schema.compiledTypeMap

        this.length = input.length
        this.position = 0
        this.line = 0
        this.lineStart = 0
        this.lineIndent = 0

        this.documents = []

        /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/
      }

      function generateError(state, message) {
        return new YAMLException(
          message,
          new Mark(
            state.filename,
            state.input,
            state.position,
            state.line,
            state.position - state.lineStart
          )
        )
      }

      function throwError(state, message) {
        throw generateError(state, message)
      }

      function throwWarning(state, message) {
        if (state.onWarning) {
          state.onWarning.call(null, generateError(state, message))
        }
      }

      var directiveHandlers = {
        YAML: function handleYamlDirective(state, name, args) {
          var match, major, minor

          if (state.version !== null) {
            throwError(state, 'duplication of %YAML directive')
          }

          if (args.length !== 1) {
            throwError(state, 'YAML directive accepts exactly one argument')
          }

          match = /^([0-9]+)\.([0-9]+)$/.exec(args[0])

          if (match === null) {
            throwError(state, 'ill-formed argument of the YAML directive')
          }

          major = parseInt(match[1], 10)
          minor = parseInt(match[2], 10)

          if (major !== 1) {
            throwError(state, 'unacceptable YAML version of the document')
          }

          state.version = args[0]
          state.checkLineBreaks = minor < 2

          if (minor !== 1 && minor !== 2) {
            throwWarning(state, 'unsupported YAML version of the document')
          }
        },

        TAG: function handleTagDirective(state, name, args) {
          var handle, prefix

          if (args.length !== 2) {
            throwError(state, 'TAG directive accepts exactly two arguments')
          }

          handle = args[0]
          prefix = args[1]

          if (!PATTERN_TAG_HANDLE.test(handle)) {
            throwError(
              state,
              'ill-formed tag handle (first argument) of the TAG directive'
            )
          }

          if (_hasOwnProperty.call(state.tagMap, handle)) {
            throwError(
              state,
              'there is a previously declared suffix for "' +
                handle +
                '" tag handle'
            )
          }

          if (!PATTERN_TAG_URI.test(prefix)) {
            throwError(
              state,
              'ill-formed tag prefix (second argument) of the TAG directive'
            )
          }

          state.tagMap[handle] = prefix
        },
      }

      function captureSegment(state, start, end, checkJson) {
        var _position, _length, _character, _result

        if (start < end) {
          _result = state.input.slice(start, end)

          if (checkJson) {
            for (
              _position = 0, _length = _result.length;
              _position < _length;
              _position += 1
            ) {
              _character = _result.charCodeAt(_position)
              if (
                !(
                  _character === 0x09 ||
                  (0x20 <= _character && _character <= 0x10ffff)
                )
              ) {
                throwError(state, 'expected valid JSON character')
              }
            }
          } else if (PATTERN_NON_PRINTABLE.test(_result)) {
            throwError(state, 'the stream contains non-printable characters')
          }

          state.result += _result
        }
      }

      function mergeMappings(state, destination, source, overridableKeys) {
        var sourceKeys, key, index, quantity

        if (!common.isObject(source)) {
          throwError(
            state,
            'cannot merge mappings; the provided source object is unacceptable'
          )
        }

        sourceKeys = Object.keys(source)

        for (
          index = 0, quantity = sourceKeys.length;
          index < quantity;
          index += 1
        ) {
          key = sourceKeys[index]

          if (!_hasOwnProperty.call(destination, key)) {
            destination[key] = source[key]
            overridableKeys[key] = true
          }
        }
      }

      function storeMappingPair(
        state,
        _result,
        overridableKeys,
        keyTag,
        keyNode,
        valueNode,
        startLine,
        startPos
      ) {
        var index, quantity

        // The output is a plain object here, so keys can only be strings.
        // We need to convert keyNode to a string, but doing so can hang the process
        // (deeply nested arrays that explode exponentially using aliases).
        if (Array.isArray(keyNode)) {
          keyNode = Array.prototype.slice.call(keyNode)

          for (
            index = 0, quantity = keyNode.length;
            index < quantity;
            index += 1
          ) {
            if (Array.isArray(keyNode[index])) {
              throwError(state, 'nested arrays are not supported inside keys')
            }

            if (
              typeof keyNode === 'object' &&
              _class(keyNode[index]) === '[object Object]'
            ) {
              keyNode[index] = '[object Object]'
            }
          }
        }

        // Avoid code execution in load() via toString property
        // (still use its own toString for arrays, timestamps,
        // and whatever user schema extensions happen to have @@toStringTag)
        if (
          typeof keyNode === 'object' &&
          _class(keyNode) === '[object Object]'
        ) {
          keyNode = '[object Object]'
        }

        keyNode = String(keyNode)

        if (_result === null) {
          _result = {}
        }

        if (keyTag === 'tag:yaml.org,2002:merge') {
          if (Array.isArray(valueNode)) {
            for (
              index = 0, quantity = valueNode.length;
              index < quantity;
              index += 1
            ) {
              mergeMappings(state, _result, valueNode[index], overridableKeys)
            }
          } else {
            mergeMappings(state, _result, valueNode, overridableKeys)
          }
        } else {
          if (
            !state.json &&
            !_hasOwnProperty.call(overridableKeys, keyNode) &&
            _hasOwnProperty.call(_result, keyNode)
          ) {
            state.line = startLine || state.line
            state.position = startPos || state.position
            throwError(state, 'duplicated mapping key')
          }
          _result[keyNode] = valueNode
          delete overridableKeys[keyNode]
        }

        return _result
      }

      function readLineBreak(state) {
        var ch

        ch = state.input.charCodeAt(state.position)

        if (ch === 0x0a /* LF */) {
          state.position++
        } else if (ch === 0x0d /* CR */) {
          state.position++
          if (state.input.charCodeAt(state.position) === 0x0a /* LF */) {
            state.position++
          }
        } else {
          throwError(state, 'a line break is expected')
        }

        state.line += 1
        state.lineStart = state.position
      }

      function skipSeparationSpace(state, allowComments, checkIndent) {
        var lineBreaks = 0,
          ch = state.input.charCodeAt(state.position)

        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position)
          }

          if (allowComments && ch === 0x23 /* # */) {
            do {
              ch = state.input.charCodeAt(++state.position)
            } while (ch !== 0x0a /* LF */ && ch !== 0x0d /* CR */ && ch !== 0)
          }

          if (is_EOL(ch)) {
            readLineBreak(state)

            ch = state.input.charCodeAt(state.position)
            lineBreaks++
            state.lineIndent = 0

            while (ch === 0x20 /* Space */) {
              state.lineIndent++
              ch = state.input.charCodeAt(++state.position)
            }
          } else {
            break
          }
        }

        if (
          checkIndent !== -1 &&
          lineBreaks !== 0 &&
          state.lineIndent < checkIndent
        ) {
          throwWarning(state, 'deficient indentation')
        }

        return lineBreaks
      }

      function testDocumentSeparator(state) {
        var _position = state.position,
          ch

        ch = state.input.charCodeAt(_position)

        // Condition state.position === state.lineStart is tested
        // in parent on each call, for efficiency. No needs to test here again.
        if (
          (ch === 0x2d /* - */ || ch === 0x2e) /* . */ &&
          ch === state.input.charCodeAt(_position + 1) &&
          ch === state.input.charCodeAt(_position + 2)
        ) {
          _position += 3

          ch = state.input.charCodeAt(_position)

          if (ch === 0 || is_WS_OR_EOL(ch)) {
            return true
          }
        }

        return false
      }

      function writeFoldedLines(state, count) {
        if (count === 1) {
          state.result += ' '
        } else if (count > 1) {
          state.result += common.repeat('\n', count - 1)
        }
      }

      function readPlainScalar(state, nodeIndent, withinFlowCollection) {
        var preceding,
          following,
          captureStart,
          captureEnd,
          hasPendingContent,
          _line,
          _lineStart,
          _lineIndent,
          _kind = state.kind,
          _result = state.result,
          ch

        ch = state.input.charCodeAt(state.position)

        if (
          is_WS_OR_EOL(ch) ||
          is_FLOW_INDICATOR(ch) ||
          ch === 0x23 /* # */ ||
          ch === 0x26 /* & */ ||
          ch === 0x2a /* * */ ||
          ch === 0x21 /* ! */ ||
          ch === 0x7c /* | */ ||
          ch === 0x3e /* > */ ||
          ch === 0x27 /* ' */ ||
          ch === 0x22 /* " */ ||
          ch === 0x25 /* % */ ||
          ch === 0x40 /* @ */ ||
          ch === 0x60 /* ` */
        ) {
          return false
        }

        if (ch === 0x3f /* ? */ || ch === 0x2d /* - */) {
          following = state.input.charCodeAt(state.position + 1)

          if (
            is_WS_OR_EOL(following) ||
            (withinFlowCollection && is_FLOW_INDICATOR(following))
          ) {
            return false
          }
        }

        state.kind = 'scalar'
        state.result = ''
        captureStart = captureEnd = state.position
        hasPendingContent = false

        while (ch !== 0) {
          if (ch === 0x3a /* : */) {
            following = state.input.charCodeAt(state.position + 1)

            if (
              is_WS_OR_EOL(following) ||
              (withinFlowCollection && is_FLOW_INDICATOR(following))
            ) {
              break
            }
          } else if (ch === 0x23 /* # */) {
            preceding = state.input.charCodeAt(state.position - 1)

            if (is_WS_OR_EOL(preceding)) {
              break
            }
          } else if (
            (state.position === state.lineStart &&
              testDocumentSeparator(state)) ||
            (withinFlowCollection && is_FLOW_INDICATOR(ch))
          ) {
            break
          } else if (is_EOL(ch)) {
            _line = state.line
            _lineStart = state.lineStart
            _lineIndent = state.lineIndent
            skipSeparationSpace(state, false, -1)

            if (state.lineIndent >= nodeIndent) {
              hasPendingContent = true
              ch = state.input.charCodeAt(state.position)
              continue
            } else {
              state.position = captureEnd
              state.line = _line
              state.lineStart = _lineStart
              state.lineIndent = _lineIndent
              break
            }
          }

          if (hasPendingContent) {
            captureSegment(state, captureStart, captureEnd, false)
            writeFoldedLines(state, state.line - _line)
            captureStart = captureEnd = state.position
            hasPendingContent = false
          }

          if (!is_WHITE_SPACE(ch)) {
            captureEnd = state.position + 1
          }

          ch = state.input.charCodeAt(++state.position)
        }

        captureSegment(state, captureStart, captureEnd, false)

        if (state.result) {
          return true
        }

        state.kind = _kind
        state.result = _result
        return false
      }

      function readSingleQuotedScalar(state, nodeIndent) {
        var ch, captureStart, captureEnd

        ch = state.input.charCodeAt(state.position)

        if (ch !== 0x27 /* ' */) {
          return false
        }

        state.kind = 'scalar'
        state.result = ''
        state.position++
        captureStart = captureEnd = state.position

        while ((ch = state.input.charCodeAt(state.position)) !== 0) {
          if (ch === 0x27 /* ' */) {
            captureSegment(state, captureStart, state.position, true)
            ch = state.input.charCodeAt(++state.position)

            if (ch === 0x27 /* ' */) {
              captureStart = state.position
              state.position++
              captureEnd = state.position
            } else {
              return true
            }
          } else if (is_EOL(ch)) {
            captureSegment(state, captureStart, captureEnd, true)
            writeFoldedLines(
              state,
              skipSeparationSpace(state, false, nodeIndent)
            )
            captureStart = captureEnd = state.position
          } else if (
            state.position === state.lineStart &&
            testDocumentSeparator(state)
          ) {
            throwError(
              state,
              'unexpected end of the document within a single quoted scalar'
            )
          } else {
            state.position++
            captureEnd = state.position
          }
        }

        throwError(
          state,
          'unexpected end of the stream within a single quoted scalar'
        )
      }

      function readDoubleQuotedScalar(state, nodeIndent) {
        var captureStart, captureEnd, hexLength, hexResult, tmp, ch

        ch = state.input.charCodeAt(state.position)

        if (ch !== 0x22 /* " */) {
          return false
        }

        state.kind = 'scalar'
        state.result = ''
        state.position++
        captureStart = captureEnd = state.position

        while ((ch = state.input.charCodeAt(state.position)) !== 0) {
          if (ch === 0x22 /* " */) {
            captureSegment(state, captureStart, state.position, true)
            state.position++
            return true
          } else if (ch === 0x5c /* \ */) {
            captureSegment(state, captureStart, state.position, true)
            ch = state.input.charCodeAt(++state.position)

            if (is_EOL(ch)) {
              skipSeparationSpace(state, false, nodeIndent)

              // TODO: rework to inline fn with no type cast?
            } else if (ch < 256 && simpleEscapeCheck[ch]) {
              state.result += simpleEscapeMap[ch]
              state.position++
            } else if ((tmp = escapedHexLen(ch)) > 0) {
              hexLength = tmp
              hexResult = 0

              for (; hexLength > 0; hexLength--) {
                ch = state.input.charCodeAt(++state.position)

                if ((tmp = fromHexCode(ch)) >= 0) {
                  hexResult = (hexResult << 4) + tmp
                } else {
                  throwError(state, 'expected hexadecimal character')
                }
              }

              state.result += charFromCodepoint(hexResult)

              state.position++
            } else {
              throwError(state, 'unknown escape sequence')
            }

            captureStart = captureEnd = state.position
          } else if (is_EOL(ch)) {
            captureSegment(state, captureStart, captureEnd, true)
            writeFoldedLines(
              state,
              skipSeparationSpace(state, false, nodeIndent)
            )
            captureStart = captureEnd = state.position
          } else if (
            state.position === state.lineStart &&
            testDocumentSeparator(state)
          ) {
            throwError(
              state,
              'unexpected end of the document within a double quoted scalar'
            )
          } else {
            state.position++
            captureEnd = state.position
          }
        }

        throwError(
          state,
          'unexpected end of the stream within a double quoted scalar'
        )
      }

      function readFlowCollection(state, nodeIndent) {
        var readNext = true,
          _line,
          _tag = state.tag,
          _result,
          _anchor = state.anchor,
          following,
          terminator,
          isPair,
          isExplicitPair,
          isMapping,
          overridableKeys = {},
          keyNode,
          keyTag,
          valueNode,
          ch

        ch = state.input.charCodeAt(state.position)

        if (ch === 0x5b /* [ */) {
          terminator = 0x5d /* ] */
          isMapping = false
          _result = []
        } else if (ch === 0x7b /* { */) {
          terminator = 0x7d /* } */
          isMapping = true
          _result = {}
        } else {
          return false
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = _result
        }

        ch = state.input.charCodeAt(++state.position)

        while (ch !== 0) {
          skipSeparationSpace(state, true, nodeIndent)

          ch = state.input.charCodeAt(state.position)

          if (ch === terminator) {
            state.position++
            state.tag = _tag
            state.anchor = _anchor
            state.kind = isMapping ? 'mapping' : 'sequence'
            state.result = _result
            return true
          } else if (!readNext) {
            throwError(state, 'missed comma between flow collection entries')
          }

          keyTag = keyNode = valueNode = null
          isPair = isExplicitPair = false

          if (ch === 0x3f /* ? */) {
            following = state.input.charCodeAt(state.position + 1)

            if (is_WS_OR_EOL(following)) {
              isPair = isExplicitPair = true
              state.position++
              skipSeparationSpace(state, true, nodeIndent)
            }
          }

          _line = state.line
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true)
          keyTag = state.tag
          keyNode = state.result
          skipSeparationSpace(state, true, nodeIndent)

          ch = state.input.charCodeAt(state.position)

          if ((isExplicitPair || state.line === _line) && ch === 0x3a /* : */) {
            isPair = true
            ch = state.input.charCodeAt(++state.position)
            skipSeparationSpace(state, true, nodeIndent)
            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true)
            valueNode = state.result
          }

          if (isMapping) {
            storeMappingPair(
              state,
              _result,
              overridableKeys,
              keyTag,
              keyNode,
              valueNode
            )
          } else if (isPair) {
            _result.push(
              storeMappingPair(
                state,
                null,
                overridableKeys,
                keyTag,
                keyNode,
                valueNode
              )
            )
          } else {
            _result.push(keyNode)
          }

          skipSeparationSpace(state, true, nodeIndent)

          ch = state.input.charCodeAt(state.position)

          if (ch === 0x2c /* , */) {
            readNext = true
            ch = state.input.charCodeAt(++state.position)
          } else {
            readNext = false
          }
        }

        throwError(
          state,
          'unexpected end of the stream within a flow collection'
        )
      }

      function readBlockScalar(state, nodeIndent) {
        var captureStart,
          folding,
          chomping = CHOMPING_CLIP,
          didReadContent = false,
          detectedIndent = false,
          textIndent = nodeIndent,
          emptyLines = 0,
          atMoreIndented = false,
          tmp,
          ch

        ch = state.input.charCodeAt(state.position)

        if (ch === 0x7c /* | */) {
          folding = false
        } else if (ch === 0x3e /* > */) {
          folding = true
        } else {
          return false
        }

        state.kind = 'scalar'
        state.result = ''

        while (ch !== 0) {
          ch = state.input.charCodeAt(++state.position)

          if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {
            if (CHOMPING_CLIP === chomping) {
              chomping = ch === 0x2b /* + */ ? CHOMPING_KEEP : CHOMPING_STRIP
            } else {
              throwError(state, 'repeat of a chomping mode identifier')
            }
          } else if ((tmp = fromDecimalCode(ch)) >= 0) {
            if (tmp === 0) {
              throwError(
                state,
                'bad explicit indentation width of a block scalar; it cannot be less than one'
              )
            } else if (!detectedIndent) {
              textIndent = nodeIndent + tmp - 1
              detectedIndent = true
            } else {
              throwError(state, 'repeat of an indentation width identifier')
            }
          } else {
            break
          }
        }

        if (is_WHITE_SPACE(ch)) {
          do {
            ch = state.input.charCodeAt(++state.position)
          } while (is_WHITE_SPACE(ch))

          if (ch === 0x23 /* # */) {
            do {
              ch = state.input.charCodeAt(++state.position)
            } while (!is_EOL(ch) && ch !== 0)
          }
        }

        while (ch !== 0) {
          readLineBreak(state)
          state.lineIndent = 0

          ch = state.input.charCodeAt(state.position)

          while (
            (!detectedIndent || state.lineIndent < textIndent) &&
            ch === 0x20 /* Space */
          ) {
            state.lineIndent++
            ch = state.input.charCodeAt(++state.position)
          }

          if (!detectedIndent && state.lineIndent > textIndent) {
            textIndent = state.lineIndent
          }

          if (is_EOL(ch)) {
            emptyLines++
            continue
          }

          // End of the scalar.
          if (state.lineIndent < textIndent) {
            // Perform the chomping.
            if (chomping === CHOMPING_KEEP) {
              state.result += common.repeat(
                '\n',
                didReadContent ? 1 + emptyLines : emptyLines
              )
            } else if (chomping === CHOMPING_CLIP) {
              if (didReadContent) {
                // i.e. only if the scalar is not empty.
                state.result += '\n'
              }
            }

            // Break this `while` cycle and go to the funciton's epilogue.
            break
          }

          // Folded style: use fancy rules to handle line breaks.
          if (folding) {
            // Lines starting with white space characters (more-indented lines) are not folded.
            if (is_WHITE_SPACE(ch)) {
              atMoreIndented = true
              // except for the first content line (cf. Example 8.1)
              state.result += common.repeat(
                '\n',
                didReadContent ? 1 + emptyLines : emptyLines
              )

              // End of more-indented block.
            } else if (atMoreIndented) {
              atMoreIndented = false
              state.result += common.repeat('\n', emptyLines + 1)

              // Just one line break - perceive as the same line.
            } else if (emptyLines === 0) {
              if (didReadContent) {
                // i.e. only if we have already read some scalar content.
                state.result += ' '
              }

              // Several line breaks - perceive as different lines.
            } else {
              state.result += common.repeat('\n', emptyLines)
            }

            // Literal style: just add exact number of line breaks between content lines.
          } else {
            // Keep all line breaks except the header line break.
            state.result += common.repeat(
              '\n',
              didReadContent ? 1 + emptyLines : emptyLines
            )
          }

          didReadContent = true
          detectedIndent = true
          emptyLines = 0
          captureStart = state.position

          while (!is_EOL(ch) && ch !== 0) {
            ch = state.input.charCodeAt(++state.position)
          }

          captureSegment(state, captureStart, state.position, false)
        }

        return true
      }

      function readBlockSequence(state, nodeIndent) {
        var _line,
          _tag = state.tag,
          _anchor = state.anchor,
          _result = [],
          following,
          detected = false,
          ch

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = _result
        }

        ch = state.input.charCodeAt(state.position)

        while (ch !== 0) {
          if (ch !== 0x2d /* - */) {
            break
          }

          following = state.input.charCodeAt(state.position + 1)

          if (!is_WS_OR_EOL(following)) {
            break
          }

          detected = true
          state.position++

          if (skipSeparationSpace(state, true, -1)) {
            if (state.lineIndent <= nodeIndent) {
              _result.push(null)
              ch = state.input.charCodeAt(state.position)
              continue
            }
          }

          _line = state.line
          composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true)
          _result.push(state.result)
          skipSeparationSpace(state, true, -1)

          ch = state.input.charCodeAt(state.position)

          if (
            (state.line === _line || state.lineIndent > nodeIndent) &&
            ch !== 0
          ) {
            throwError(state, 'bad indentation of a sequence entry')
          } else if (state.lineIndent < nodeIndent) {
            break
          }
        }

        if (detected) {
          state.tag = _tag
          state.anchor = _anchor
          state.kind = 'sequence'
          state.result = _result
          return true
        }
        return false
      }

      function readBlockMapping(state, nodeIndent, flowIndent) {
        var following,
          allowCompact,
          _line,
          _pos,
          _tag = state.tag,
          _anchor = state.anchor,
          _result = {},
          overridableKeys = {},
          keyTag = null,
          keyNode = null,
          valueNode = null,
          atExplicitKey = false,
          detected = false,
          ch

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = _result
        }

        ch = state.input.charCodeAt(state.position)

        while (ch !== 0) {
          following = state.input.charCodeAt(state.position + 1)
          _line = state.line // Save the current line.
          _pos = state.position

          //
          // Explicit notation case. There are two separate blocks:
          // first for the key (denoted by "?") and second for the value (denoted by ":")
          //
          if (
            (ch === 0x3f /* ? */ || ch === 0x3a /*: */) &&
            is_WS_OR_EOL(following)
          ) {
            if (ch === 0x3f /* ? */) {
              if (atExplicitKey) {
                storeMappingPair(
                  state,
                  _result,
                  overridableKeys,
                  keyTag,
                  keyNode,
                  null
                )
                keyTag = keyNode = valueNode = null
              }

              detected = true
              atExplicitKey = true
              allowCompact = true
            } else if (atExplicitKey) {
              // i.e. 0x3A/* : */ === character after the explicit key.
              atExplicitKey = false
              allowCompact = true
            } else {
              throwError(
                state,
                'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line'
              )
            }

            state.position += 1
            ch = following

            //
            // Implicit notation case. Flow-style node as the key first, then ":", and the value.
            //
          } else if (
            composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)
          ) {
            if (state.line === _line) {
              ch = state.input.charCodeAt(state.position)

              while (is_WHITE_SPACE(ch)) {
                ch = state.input.charCodeAt(++state.position)
              }

              if (ch === 0x3a /* : */) {
                ch = state.input.charCodeAt(++state.position)

                if (!is_WS_OR_EOL(ch)) {
                  throwError(
                    state,
                    'a whitespace character is expected after the key-value separator within a block mapping'
                  )
                }

                if (atExplicitKey) {
                  storeMappingPair(
                    state,
                    _result,
                    overridableKeys,
                    keyTag,
                    keyNode,
                    null
                  )
                  keyTag = keyNode = valueNode = null
                }

                detected = true
                atExplicitKey = false
                allowCompact = false
                keyTag = state.tag
                keyNode = state.result
              } else if (detected) {
                throwError(
                  state,
                  'can not read an implicit mapping pair; a colon is missed'
                )
              } else {
                state.tag = _tag
                state.anchor = _anchor
                return true // Keep the result of `composeNode`.
              }
            } else if (detected) {
              throwError(
                state,
                'can not read a block mapping entry; a multiline key may not be an implicit key'
              )
            } else {
              state.tag = _tag
              state.anchor = _anchor
              return true // Keep the result of `composeNode`.
            }
          } else {
            break // Reading is done. Go to the epilogue.
          }

          //
          // Common reading code for both explicit and implicit notations.
          //
          if (state.line === _line || state.lineIndent > nodeIndent) {
            if (
              composeNode(
                state,
                nodeIndent,
                CONTEXT_BLOCK_OUT,
                true,
                allowCompact
              )
            ) {
              if (atExplicitKey) {
                keyNode = state.result
              } else {
                valueNode = state.result
              }
            }

            if (!atExplicitKey) {
              storeMappingPair(
                state,
                _result,
                overridableKeys,
                keyTag,
                keyNode,
                valueNode,
                _line,
                _pos
              )
              keyTag = keyNode = valueNode = null
            }

            skipSeparationSpace(state, true, -1)
            ch = state.input.charCodeAt(state.position)
          }

          if (state.lineIndent > nodeIndent && ch !== 0) {
            throwError(state, 'bad indentation of a mapping entry')
          } else if (state.lineIndent < nodeIndent) {
            break
          }
        }

        //
        // Epilogue.
        //

        // Special case: last mapping's node contains only the key in explicit notation.
        if (atExplicitKey) {
          storeMappingPair(
            state,
            _result,
            overridableKeys,
            keyTag,
            keyNode,
            null
          )
        }

        // Expose the resulting mapping.
        if (detected) {
          state.tag = _tag
          state.anchor = _anchor
          state.kind = 'mapping'
          state.result = _result
        }

        return detected
      }

      function readTagProperty(state) {
        var _position,
          isVerbatim = false,
          isNamed = false,
          tagHandle,
          tagName,
          ch

        ch = state.input.charCodeAt(state.position)

        if (ch !== 0x21 /* ! */) return false

        if (state.tag !== null) {
          throwError(state, 'duplication of a tag property')
        }

        ch = state.input.charCodeAt(++state.position)

        if (ch === 0x3c /* < */) {
          isVerbatim = true
          ch = state.input.charCodeAt(++state.position)
        } else if (ch === 0x21 /* ! */) {
          isNamed = true
          tagHandle = '!!'
          ch = state.input.charCodeAt(++state.position)
        } else {
          tagHandle = '!'
        }

        _position = state.position

        if (isVerbatim) {
          do {
            ch = state.input.charCodeAt(++state.position)
          } while (ch !== 0 && ch !== 0x3e /* > */)

          if (state.position < state.length) {
            tagName = state.input.slice(_position, state.position)
            ch = state.input.charCodeAt(++state.position)
          } else {
            throwError(
              state,
              'unexpected end of the stream within a verbatim tag'
            )
          }
        } else {
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            if (ch === 0x21 /* ! */) {
              if (!isNamed) {
                tagHandle = state.input.slice(_position - 1, state.position + 1)

                if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                  throwError(
                    state,
                    'named tag handle cannot contain such characters'
                  )
                }

                isNamed = true
                _position = state.position + 1
              } else {
                throwError(state, 'tag suffix cannot contain exclamation marks')
              }
            }

            ch = state.input.charCodeAt(++state.position)
          }

          tagName = state.input.slice(_position, state.position)

          if (PATTERN_FLOW_INDICATORS.test(tagName)) {
            throwError(
              state,
              'tag suffix cannot contain flow indicator characters'
            )
          }
        }

        if (tagName && !PATTERN_TAG_URI.test(tagName)) {
          throwError(
            state,
            'tag name cannot contain such characters: ' + tagName
          )
        }

        if (isVerbatim) {
          state.tag = tagName
        } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
          state.tag = state.tagMap[tagHandle] + tagName
        } else if (tagHandle === '!') {
          state.tag = '!' + tagName
        } else if (tagHandle === '!!') {
          state.tag = 'tag:yaml.org,2002:' + tagName
        } else {
          throwError(state, 'undeclared tag handle "' + tagHandle + '"')
        }

        return true
      }

      function readAnchorProperty(state) {
        var _position, ch

        ch = state.input.charCodeAt(state.position)

        if (ch !== 0x26 /* & */) return false

        if (state.anchor !== null) {
          throwError(state, 'duplication of an anchor property')
        }

        ch = state.input.charCodeAt(++state.position)
        _position = state.position

        while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
          ch = state.input.charCodeAt(++state.position)
        }

        if (state.position === _position) {
          throwError(
            state,
            'name of an anchor node must contain at least one character'
          )
        }

        state.anchor = state.input.slice(_position, state.position)
        return true
      }

      function readAlias(state) {
        var _position, alias, ch

        ch = state.input.charCodeAt(state.position)

        if (ch !== 0x2a /* * */) return false

        ch = state.input.charCodeAt(++state.position)
        _position = state.position

        while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
          ch = state.input.charCodeAt(++state.position)
        }

        if (state.position === _position) {
          throwError(
            state,
            'name of an alias node must contain at least one character'
          )
        }

        alias = state.input.slice(_position, state.position)

        if (!_hasOwnProperty.call(state.anchorMap, alias)) {
          throwError(state, 'unidentified alias "' + alias + '"')
        }

        state.result = state.anchorMap[alias]
        skipSeparationSpace(state, true, -1)
        return true
      }

      function composeNode(
        state,
        parentIndent,
        nodeContext,
        allowToSeek,
        allowCompact
      ) {
        var allowBlockStyles,
          allowBlockScalars,
          allowBlockCollections,
          indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
          atNewLine = false,
          hasContent = false,
          typeIndex,
          typeQuantity,
          type,
          flowIndent,
          blockIndent

        if (state.listener !== null) {
          state.listener('open', state)
        }

        state.tag = null
        state.anchor = null
        state.kind = null
        state.result = null

        allowBlockStyles =
          allowBlockScalars =
          allowBlockCollections =
            CONTEXT_BLOCK_OUT === nodeContext ||
            CONTEXT_BLOCK_IN === nodeContext

        if (allowToSeek) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true

            if (state.lineIndent > parentIndent) {
              indentStatus = 1
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1
            }
          }
        }

        if (indentStatus === 1) {
          while (readTagProperty(state) || readAnchorProperty(state)) {
            if (skipSeparationSpace(state, true, -1)) {
              atNewLine = true
              allowBlockCollections = allowBlockStyles

              if (state.lineIndent > parentIndent) {
                indentStatus = 1
              } else if (state.lineIndent === parentIndent) {
                indentStatus = 0
              } else if (state.lineIndent < parentIndent) {
                indentStatus = -1
              }
            } else {
              allowBlockCollections = false
            }
          }
        }

        if (allowBlockCollections) {
          allowBlockCollections = atNewLine || allowCompact
        }

        if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
          if (
            CONTEXT_FLOW_IN === nodeContext ||
            CONTEXT_FLOW_OUT === nodeContext
          ) {
            flowIndent = parentIndent
          } else {
            flowIndent = parentIndent + 1
          }

          blockIndent = state.position - state.lineStart

          if (indentStatus === 1) {
            if (
              (allowBlockCollections &&
                (readBlockSequence(state, blockIndent) ||
                  readBlockMapping(state, blockIndent, flowIndent))) ||
              readFlowCollection(state, flowIndent)
            ) {
              hasContent = true
            } else {
              if (
                (allowBlockScalars && readBlockScalar(state, flowIndent)) ||
                readSingleQuotedScalar(state, flowIndent) ||
                readDoubleQuotedScalar(state, flowIndent)
              ) {
                hasContent = true
              } else if (readAlias(state)) {
                hasContent = true

                if (state.tag !== null || state.anchor !== null) {
                  throwError(state, 'alias node should not have any properties')
                }
              } else if (
                readPlainScalar(
                  state,
                  flowIndent,
                  CONTEXT_FLOW_IN === nodeContext
                )
              ) {
                hasContent = true

                if (state.tag === null) {
                  state.tag = '?'
                }
              }

              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result
              }
            }
          } else if (indentStatus === 0) {
            // Special case: block sequences are allowed to have same indentation level as the parent.
            // http://www.yaml.org/spec/1.2/spec.html#id2799784
            hasContent =
              allowBlockCollections && readBlockSequence(state, blockIndent)
          }
        }

        if (state.tag !== null && state.tag !== '!') {
          if (state.tag === '?') {
            // Implicit resolving is not allowed for non-scalar types, and '?'
            // non-specific tag is only automatically assigned to plain scalars.
            //
            // We only need to check kind conformity in case user explicitly assigns '?'
            // tag, for example like this: "!<?> [0]"
            //
            if (state.result !== null && state.kind !== 'scalar') {
              throwError(
                state,
                'unacceptable node kind for !<?> tag; it should be "scalar", not "' +
                  state.kind +
                  '"'
              )
            }

            for (
              typeIndex = 0, typeQuantity = state.implicitTypes.length;
              typeIndex < typeQuantity;
              typeIndex += 1
            ) {
              type = state.implicitTypes[typeIndex]

              if (type.resolve(state.result)) {
                // `state.result` updated in resolver if matched
                state.result = type.construct(state.result)
                state.tag = type.tag
                if (state.anchor !== null) {
                  state.anchorMap[state.anchor] = state.result
                }
                break
              }
            }
          } else if (
            _hasOwnProperty.call(
              state.typeMap[state.kind || 'fallback'],
              state.tag
            )
          ) {
            type = state.typeMap[state.kind || 'fallback'][state.tag]

            if (state.result !== null && type.kind !== state.kind) {
              throwError(
                state,
                'unacceptable node kind for !<' +
                  state.tag +
                  '> tag; it should be "' +
                  type.kind +
                  '", not "' +
                  state.kind +
                  '"'
              )
            }

            if (!type.resolve(state.result)) {
              // `state.result` updated in resolver if matched
              throwError(
                state,
                'cannot resolve a node with !<' + state.tag + '> explicit tag'
              )
            } else {
              state.result = type.construct(state.result)
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result
              }
            }
          } else {
            throwError(state, 'unknown tag !<' + state.tag + '>')
          }
        }

        if (state.listener !== null) {
          state.listener('close', state)
        }
        return state.tag !== null || state.anchor !== null || hasContent
      }

      function readDocument(state) {
        var documentStart = state.position,
          _position,
          directiveName,
          directiveArgs,
          hasDirectives = false,
          ch

        state.version = null
        state.checkLineBreaks = state.legacy
        state.tagMap = {}
        state.anchorMap = {}

        while ((ch = state.input.charCodeAt(state.position)) !== 0) {
          skipSeparationSpace(state, true, -1)

          ch = state.input.charCodeAt(state.position)

          if (state.lineIndent > 0 || ch !== 0x25 /* % */) {
            break
          }

          hasDirectives = true
          ch = state.input.charCodeAt(++state.position)
          _position = state.position

          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position)
          }

          directiveName = state.input.slice(_position, state.position)
          directiveArgs = []

          if (directiveName.length < 1) {
            throwError(
              state,
              'directive name must not be less than one character in length'
            )
          }

          while (ch !== 0) {
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position)
            }

            if (ch === 0x23 /* # */) {
              do {
                ch = state.input.charCodeAt(++state.position)
              } while (ch !== 0 && !is_EOL(ch))
              break
            }

            if (is_EOL(ch)) break

            _position = state.position

            while (ch !== 0 && !is_WS_OR_EOL(ch)) {
              ch = state.input.charCodeAt(++state.position)
            }

            directiveArgs.push(state.input.slice(_position, state.position))
          }

          if (ch !== 0) readLineBreak(state)

          if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
            directiveHandlers[directiveName](
              state,
              directiveName,
              directiveArgs
            )
          } else {
            throwWarning(
              state,
              'unknown document directive "' + directiveName + '"'
            )
          }
        }

        skipSeparationSpace(state, true, -1)

        if (
          state.lineIndent === 0 &&
          state.input.charCodeAt(state.position) === 0x2d /* - */ &&
          state.input.charCodeAt(state.position + 1) === 0x2d /* - */ &&
          state.input.charCodeAt(state.position + 2) === 0x2d /* - */
        ) {
          state.position += 3
          skipSeparationSpace(state, true, -1)
        } else if (hasDirectives) {
          throwError(state, 'directives end mark is expected')
        }

        composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true)
        skipSeparationSpace(state, true, -1)

        if (
          state.checkLineBreaks &&
          PATTERN_NON_ASCII_LINE_BREAKS.test(
            state.input.slice(documentStart, state.position)
          )
        ) {
          throwWarning(
            state,
            'non-ASCII line breaks are interpreted as content'
          )
        }

        state.documents.push(state.result)

        if (
          state.position === state.lineStart &&
          testDocumentSeparator(state)
        ) {
          if (state.input.charCodeAt(state.position) === 0x2e /* . */) {
            state.position += 3
            skipSeparationSpace(state, true, -1)
          }
          return
        }

        if (state.position < state.length - 1) {
          throwError(
            state,
            'end of the stream or a document separator is expected'
          )
        } else {
          return
        }
      }

      function loadDocuments(input, options) {
        input = String(input)
        options = options || {}

        if (input.length !== 0) {
          // Add tailing `\n` if not exists
          if (
            input.charCodeAt(input.length - 1) !== 0x0a /* LF */ &&
            input.charCodeAt(input.length - 1) !== 0x0d /* CR */
          ) {
            input += '\n'
          }

          // Strip BOM
          if (input.charCodeAt(0) === 0xfeff) {
            input = input.slice(1)
          }
        }

        var state = new State(input, options)

        var nullpos = input.indexOf('\0')

        if (nullpos !== -1) {
          state.position = nullpos
          throwError(state, 'null byte is not allowed in input')
        }

        // Use 0 as string terminator. That significantly simplifies bounds check.
        state.input += '\0'

        while (state.input.charCodeAt(state.position) === 0x20 /* Space */) {
          state.lineIndent += 1
          state.position += 1
        }

        while (state.position < state.length - 1) {
          readDocument(state)
        }

        return state.documents
      }

      function loadAll(input, iterator, options) {
        if (
          iterator !== null &&
          typeof iterator === 'object' &&
          typeof options === 'undefined'
        ) {
          options = iterator
          iterator = null
        }

        var documents = loadDocuments(input, options)

        if (typeof iterator !== 'function') {
          return documents
        }

        for (
          var index = 0, length = documents.length;
          index < length;
          index += 1
        ) {
          iterator(documents[index])
        }
      }

      function load(input, options) {
        var documents = loadDocuments(input, options)

        if (documents.length === 0) {
          /*eslint-disable no-undefined*/
          return undefined
        } else if (documents.length === 1) {
          return documents[0]
        }
        throw new YAMLException(
          'expected a single document in the stream, but found more'
        )
      }

      function safeLoadAll(input, iterator, options) {
        if (
          typeof iterator === 'object' &&
          iterator !== null &&
          typeof options === 'undefined'
        ) {
          options = iterator
          iterator = null
        }

        return loadAll(
          input,
          iterator,
          common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options)
        )
      }

      function safeLoad(input, options) {
        return load(
          input,
          common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options)
        )
      }

      module.exports.loadAll = loadAll
      module.exports.load = load
      module.exports.safeLoadAll = safeLoadAll
      module.exports.safeLoad = safeLoad

      /***/
    },

    /***/ 2813: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var common = __nccwpck_require__(3209)

      function Mark(name, buffer, position, line, column) {
        this.name = name
        this.buffer = buffer
        this.position = position
        this.line = line
        this.column = column
      }

      Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
        var head, start, tail, end, snippet

        if (!this.buffer) return null

        indent = indent || 4
        maxLength = maxLength || 75

        head = ''
        start = this.position

        while (
          start > 0 &&
          '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) ===
            -1
        ) {
          start -= 1
          if (this.position - start > maxLength / 2 - 1) {
            head = ' ... '
            start += 5
            break
          }
        }

        tail = ''
        end = this.position

        while (
          end < this.buffer.length &&
          '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1
        ) {
          end += 1
          if (end - this.position > maxLength / 2 - 1) {
            tail = ' ... '
            end -= 5
            break
          }
        }

        snippet = this.buffer.slice(start, end)

        return (
          common.repeat(' ', indent) +
          head +
          snippet +
          tail +
          '\n' +
          common.repeat(' ', indent + this.position - start + head.length) +
          '^'
        )
      }

      Mark.prototype.toString = function toString(compact) {
        var snippet,
          where = ''

        if (this.name) {
          where += 'in "' + this.name + '" '
        }

        where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1)

        if (!compact) {
          snippet = this.getSnippet()

          if (snippet) {
            where += ':\n' + snippet
          }
        }

        return where
      }

      module.exports = Mark

      /***/
    },

    /***/ 2434: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      /*eslint-disable max-len*/

      var common = __nccwpck_require__(3209)
      var YAMLException = __nccwpck_require__(4665)
      var Type = __nccwpck_require__(8971)

      function compileList(schema, name, result) {
        var exclude = []

        schema.include.forEach(function (includedSchema) {
          result = compileList(includedSchema, name, result)
        })

        schema[name].forEach(function (currentType) {
          result.forEach(function (previousType, previousIndex) {
            if (
              previousType.tag === currentType.tag &&
              previousType.kind === currentType.kind
            ) {
              exclude.push(previousIndex)
            }
          })

          result.push(currentType)
        })

        return result.filter(function (type, index) {
          return exclude.indexOf(index) === -1
        })
      }

      function compileMap(/* lists... */) {
        var result = {
            scalar: {},
            sequence: {},
            mapping: {},
            fallback: {},
          },
          index,
          length

        function collectType(type) {
          result[type.kind][type.tag] = result['fallback'][type.tag] = type
        }

        for (index = 0, length = arguments.length; index < length; index += 1) {
          arguments[index].forEach(collectType)
        }
        return result
      }

      function Schema(definition) {
        this.include = definition.include || []
        this.implicit = definition.implicit || []
        this.explicit = definition.explicit || []

        this.implicit.forEach(function (type) {
          if (type.loadKind && type.loadKind !== 'scalar') {
            throw new YAMLException(
              'There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.'
            )
          }
        })

        this.compiledImplicit = compileList(this, 'implicit', [])
        this.compiledExplicit = compileList(this, 'explicit', [])
        this.compiledTypeMap = compileMap(
          this.compiledImplicit,
          this.compiledExplicit
        )
      }

      Schema.DEFAULT = null

      Schema.create = function createSchema() {
        var schemas, types

        switch (arguments.length) {
          case 1:
            schemas = Schema.DEFAULT
            types = arguments[0]
            break

          case 2:
            schemas = arguments[0]
            types = arguments[1]
            break

          default:
            throw new YAMLException(
              'Wrong number of arguments for Schema.create function'
            )
        }

        schemas = common.toArray(schemas)
        types = common.toArray(types)

        if (
          !schemas.every(function (schema) {
            return schema instanceof Schema
          })
        ) {
          throw new YAMLException(
            'Specified list of super schemas (or a single Schema object) contains a non-Schema object.'
          )
        }

        if (
          !types.every(function (type) {
            return type instanceof Type
          })
        ) {
          throw new YAMLException(
            'Specified list of YAML types (or a single Type object) contains a non-Type object.'
          )
        }

        return new Schema({
          include: schemas,
          explicit: types,
        })
      }

      module.exports = Schema

      /***/
    },

    /***/ 5737: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'
      // Standard YAML's Core schema.
      // http://www.yaml.org/spec/1.2/spec.html#id2804923
      //
      // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
      // So, Core schema has no distinctions from JSON schema is JS-YAML.

      var Schema = __nccwpck_require__(2434)

      module.exports = new Schema({
        include: [__nccwpck_require__(8129)],
      })

      /***/
    },

    /***/ 9219: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'
      // JS-YAML's default schema for `load` function.
      // It is not described in the YAML specification.
      //
      // This schema is based on JS-YAML's default safe schema and includes
      // JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
      //
      // Also this schema is used as default base schema at `Schema.create` function.

      var Schema = __nccwpck_require__(2434)

      module.exports = Schema.DEFAULT = new Schema({
        include: [__nccwpck_require__(7920)],
        explicit: [
          __nccwpck_require__(1744),
          __nccwpck_require__(7717),
          __nccwpck_require__(5050),
        ],
      })

      /***/
    },

    /***/ 7920: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'
      // JS-YAML's default schema for `safeLoad` function.
      // It is not described in the YAML specification.
      //
      // This schema is based on standard YAML's Core schema and includes most of
      // extra types described at YAML tag repository. (http://yaml.org/type/)

      var Schema = __nccwpck_require__(2434)

      module.exports = new Schema({
        include: [__nccwpck_require__(5737)],
        implicit: [__nccwpck_require__(9159), __nccwpck_require__(4983)],
        explicit: [
          __nccwpck_require__(5326),
          __nccwpck_require__(2856),
          __nccwpck_require__(6672),
          __nccwpck_require__(582),
        ],
      })

      /***/
    },

    /***/ 2617: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'
      // Standard YAML's Failsafe schema.
      // http://www.yaml.org/spec/1.2/spec.html#id2802346

      var Schema = __nccwpck_require__(2434)

      module.exports = new Schema({
        explicit: [
          __nccwpck_require__(9930),
          __nccwpck_require__(2318),
          __nccwpck_require__(9184),
        ],
      })

      /***/
    },

    /***/ 8129: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'
      // Standard YAML's JSON schema.
      // http://www.yaml.org/spec/1.2/spec.html#id2803231
      //
      // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
      // So, this schema is not such strict as defined in the YAML specification.
      // It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.

      var Schema = __nccwpck_require__(2434)

      module.exports = new Schema({
        include: [__nccwpck_require__(2617)],
        implicit: [
          __nccwpck_require__(2454),
          __nccwpck_require__(8334),
          __nccwpck_require__(2916),
          __nccwpck_require__(260),
        ],
      })

      /***/
    },

    /***/ 8971: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var YAMLException = __nccwpck_require__(4665)

      var TYPE_CONSTRUCTOR_OPTIONS = [
        'kind',
        'resolve',
        'construct',
        'instanceOf',
        'predicate',
        'represent',
        'defaultStyle',
        'styleAliases',
      ]

      var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping']

      function compileStyleAliases(map) {
        var result = {}

        if (map !== null) {
          Object.keys(map).forEach(function (style) {
            map[style].forEach(function (alias) {
              result[String(alias)] = style
            })
          })
        }

        return result
      }

      function Type(tag, options) {
        options = options || {}

        Object.keys(options).forEach(function (name) {
          if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
            throw new YAMLException(
              'Unknown option "' +
                name +
                '" is met in definition of "' +
                tag +
                '" YAML type.'
            )
          }
        })

        // TODO: Add tag format check.
        this.tag = tag
        this.kind = options['kind'] || null
        this.resolve =
          options['resolve'] ||
          function () {
            return true
          }
        this.construct =
          options['construct'] ||
          function (data) {
            return data
          }
        this.instanceOf = options['instanceOf'] || null
        this.predicate = options['predicate'] || null
        this.represent = options['represent'] || null
        this.defaultStyle = options['defaultStyle'] || null
        this.styleAliases = compileStyleAliases(options['styleAliases'] || null)

        if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
          throw new YAMLException(
            'Unknown kind "' +
              this.kind +
              '" is specified for "' +
              tag +
              '" YAML type.'
          )
        }
      }

      module.exports = Type

      /***/
    },

    /***/ 5326: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      /*eslint-disable no-bitwise*/

      var NodeBuffer

      try {
        // A trick for browserified version, to not include `Buffer` shim
        var _require = require
        NodeBuffer = _require('buffer').Buffer
      } catch (__) {}

      var Type = __nccwpck_require__(8971)

      // [ 64, 65, 66 ] -> [ padding, CR, LF ]
      var BASE64_MAP =
        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r'

      function resolveYamlBinary(data) {
        if (data === null) return false

        var code,
          idx,
          bitlen = 0,
          max = data.length,
          map = BASE64_MAP

        // Convert one by one.
        for (idx = 0; idx < max; idx++) {
          code = map.indexOf(data.charAt(idx))

          // Skip CR/LF
          if (code > 64) continue

          // Fail on illegal characters
          if (code < 0) return false

          bitlen += 6
        }

        // If there are any bits left, source was corrupted
        return bitlen % 8 === 0
      }

      function constructYamlBinary(data) {
        var idx,
          tailbits,
          input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
          max = input.length,
          map = BASE64_MAP,
          bits = 0,
          result = []

        // Collect by 6*4 bits (3 bytes)

        for (idx = 0; idx < max; idx++) {
          if (idx % 4 === 0 && idx) {
            result.push((bits >> 16) & 0xff)
            result.push((bits >> 8) & 0xff)
            result.push(bits & 0xff)
          }

          bits = (bits << 6) | map.indexOf(input.charAt(idx))
        }

        // Dump tail

        tailbits = (max % 4) * 6

        if (tailbits === 0) {
          result.push((bits >> 16) & 0xff)
          result.push((bits >> 8) & 0xff)
          result.push(bits & 0xff)
        } else if (tailbits === 18) {
          result.push((bits >> 10) & 0xff)
          result.push((bits >> 2) & 0xff)
        } else if (tailbits === 12) {
          result.push((bits >> 4) & 0xff)
        }

        // Wrap into Buffer for NodeJS and leave Array for browser
        if (NodeBuffer) {
          // Support node 6.+ Buffer API when available
          return NodeBuffer.from
            ? NodeBuffer.from(result)
            : new NodeBuffer(result)
        }

        return result
      }

      function representYamlBinary(object /*, style*/) {
        var result = '',
          bits = 0,
          idx,
          tail,
          max = object.length,
          map = BASE64_MAP

        // Convert every three bytes to 4 ASCII characters.

        for (idx = 0; idx < max; idx++) {
          if (idx % 3 === 0 && idx) {
            result += map[(bits >> 18) & 0x3f]
            result += map[(bits >> 12) & 0x3f]
            result += map[(bits >> 6) & 0x3f]
            result += map[bits & 0x3f]
          }

          bits = (bits << 8) + object[idx]
        }

        // Dump tail

        tail = max % 3

        if (tail === 0) {
          result += map[(bits >> 18) & 0x3f]
          result += map[(bits >> 12) & 0x3f]
          result += map[(bits >> 6) & 0x3f]
          result += map[bits & 0x3f]
        } else if (tail === 2) {
          result += map[(bits >> 10) & 0x3f]
          result += map[(bits >> 4) & 0x3f]
          result += map[(bits << 2) & 0x3f]
          result += map[64]
        } else if (tail === 1) {
          result += map[(bits >> 2) & 0x3f]
          result += map[(bits << 4) & 0x3f]
          result += map[64]
          result += map[64]
        }

        return result
      }

      function isBinary(object) {
        return NodeBuffer && NodeBuffer.isBuffer(object)
      }

      module.exports = new Type('tag:yaml.org,2002:binary', {
        kind: 'scalar',
        resolve: resolveYamlBinary,
        construct: constructYamlBinary,
        predicate: isBinary,
        represent: representYamlBinary,
      })

      /***/
    },

    /***/ 8334: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(8971)

      function resolveYamlBoolean(data) {
        if (data === null) return false

        var max = data.length

        return (
          (max === 4 &&
            (data === 'true' || data === 'True' || data === 'TRUE')) ||
          (max === 5 &&
            (data === 'false' || data === 'False' || data === 'FALSE'))
        )
      }

      function constructYamlBoolean(data) {
        return data === 'true' || data === 'True' || data === 'TRUE'
      }

      function isBoolean(object) {
        return Object.prototype.toString.call(object) === '[object Boolean]'
      }

      module.exports = new Type('tag:yaml.org,2002:bool', {
        kind: 'scalar',
        resolve: resolveYamlBoolean,
        construct: constructYamlBoolean,
        predicate: isBoolean,
        represent: {
          lowercase: function (object) {
            return object ? 'true' : 'false'
          },
          uppercase: function (object) {
            return object ? 'TRUE' : 'FALSE'
          },
          camelcase: function (object) {
            return object ? 'True' : 'False'
          },
        },
        defaultStyle: 'lowercase',
      })

      /***/
    },

    /***/ 260: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var common = __nccwpck_require__(3209)
      var Type = __nccwpck_require__(8971)

      var YAML_FLOAT_PATTERN = new RegExp(
        // 2.5e4, 2.5 and integers
        '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
          // .2e4, .2
          // special case, seems not from spec
          '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
          // 20:59
          '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
          // .inf
          '|[-+]?\\.(?:inf|Inf|INF)' +
          // .nan
          '|\\.(?:nan|NaN|NAN))$'
      )

      function resolveYamlFloat(data) {
        if (data === null) return false

        if (
          !YAML_FLOAT_PATTERN.test(data) ||
          // Quick hack to not allow integers end with `_`
          // Probably should update regexp & check speed
          data[data.length - 1] === '_'
        ) {
          return false
        }

        return true
      }

      function constructYamlFloat(data) {
        var value, sign, base, digits

        value = data.replace(/_/g, '').toLowerCase()
        sign = value[0] === '-' ? -1 : 1
        digits = []

        if ('+-'.indexOf(value[0]) >= 0) {
          value = value.slice(1)
        }

        if (value === '.inf') {
          return sign === 1
            ? Number.POSITIVE_INFINITY
            : Number.NEGATIVE_INFINITY
        } else if (value === '.nan') {
          return NaN
        } else if (value.indexOf(':') >= 0) {
          value.split(':').forEach(function (v) {
            digits.unshift(parseFloat(v, 10))
          })

          value = 0.0
          base = 1

          digits.forEach(function (d) {
            value += d * base
            base *= 60
          })

          return sign * value
        }
        return sign * parseFloat(value, 10)
      }

      var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/

      function representYamlFloat(object, style) {
        var res

        if (isNaN(object)) {
          switch (style) {
            case 'lowercase':
              return '.nan'
            case 'uppercase':
              return '.NAN'
            case 'camelcase':
              return '.NaN'
          }
        } else if (Number.POSITIVE_INFINITY === object) {
          switch (style) {
            case 'lowercase':
              return '.inf'
            case 'uppercase':
              return '.INF'
            case 'camelcase':
              return '.Inf'
          }
        } else if (Number.NEGATIVE_INFINITY === object) {
          switch (style) {
            case 'lowercase':
              return '-.inf'
            case 'uppercase':
              return '-.INF'
            case 'camelcase':
              return '-.Inf'
          }
        } else if (common.isNegativeZero(object)) {
          return '-0.0'
        }

        res = object.toString(10)

        // JS stringifier can build scientific format without dots: 5e-100,
        // while YAML requres dot: 5.e-100. Fix it with simple hack

        return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res
      }

      function isFloat(object) {
        return (
          Object.prototype.toString.call(object) === '[object Number]' &&
          (object % 1 !== 0 || common.isNegativeZero(object))
        )
      }

      module.exports = new Type('tag:yaml.org,2002:float', {
        kind: 'scalar',
        resolve: resolveYamlFloat,
        construct: constructYamlFloat,
        predicate: isFloat,
        represent: representYamlFloat,
        defaultStyle: 'lowercase',
      })

      /***/
    },

    /***/ 2916: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var common = __nccwpck_require__(3209)
      var Type = __nccwpck_require__(8971)

      function isHexCode(c) {
        return (
          (0x30 /* 0 */ <= c && c <= 0x39) /* 9 */ ||
          (0x41 /* A */ <= c && c <= 0x46) /* F */ ||
          (0x61 /* a */ <= c && c <= 0x66) /* f */
        )
      }

      function isOctCode(c) {
        return 0x30 /* 0 */ <= c && c <= 0x37 /* 7 */
      }

      function isDecCode(c) {
        return 0x30 /* 0 */ <= c && c <= 0x39 /* 9 */
      }

      function resolveYamlInteger(data) {
        if (data === null) return false

        var max = data.length,
          index = 0,
          hasDigits = false,
          ch

        if (!max) return false

        ch = data[index]

        // sign
        if (ch === '-' || ch === '+') {
          ch = data[++index]
        }

        if (ch === '0') {
          // 0
          if (index + 1 === max) return true
          ch = data[++index]

          // base 2, base 8, base 16

          if (ch === 'b') {
            // base 2
            index++

            for (; index < max; index++) {
              ch = data[index]
              if (ch === '_') continue
              if (ch !== '0' && ch !== '1') return false
              hasDigits = true
            }
            return hasDigits && ch !== '_'
          }

          if (ch === 'x') {
            // base 16
            index++

            for (; index < max; index++) {
              ch = data[index]
              if (ch === '_') continue
              if (!isHexCode(data.charCodeAt(index))) return false
              hasDigits = true
            }
            return hasDigits && ch !== '_'
          }

          // base 8
          for (; index < max; index++) {
            ch = data[index]
            if (ch === '_') continue
            if (!isOctCode(data.charCodeAt(index))) return false
            hasDigits = true
          }
          return hasDigits && ch !== '_'
        }

        // base 10 (except 0) or base 60

        // value should not start with `_`;
        if (ch === '_') return false

        for (; index < max; index++) {
          ch = data[index]
          if (ch === '_') continue
          if (ch === ':') break
          if (!isDecCode(data.charCodeAt(index))) {
            return false
          }
          hasDigits = true
        }

        // Should have digits and should not end with `_`
        if (!hasDigits || ch === '_') return false

        // if !base60 - done;
        if (ch !== ':') return true

        // base60 almost not used, no needs to optimize
        return /^(:[0-5]?[0-9])+$/.test(data.slice(index))
      }

      function constructYamlInteger(data) {
        var value = data,
          sign = 1,
          ch,
          base,
          digits = []

        if (value.indexOf('_') !== -1) {
          value = value.replace(/_/g, '')
        }

        ch = value[0]

        if (ch === '-' || ch === '+') {
          if (ch === '-') sign = -1
          value = value.slice(1)
          ch = value[0]
        }

        if (value === '0') return 0

        if (ch === '0') {
          if (value[1] === 'b') return sign * parseInt(value.slice(2), 2)
          if (value[1] === 'x') return sign * parseInt(value, 16)
          return sign * parseInt(value, 8)
        }

        if (value.indexOf(':') !== -1) {
          value.split(':').forEach(function (v) {
            digits.unshift(parseInt(v, 10))
          })

          value = 0
          base = 1

          digits.forEach(function (d) {
            value += d * base
            base *= 60
          })

          return sign * value
        }

        return sign * parseInt(value, 10)
      }

      function isInteger(object) {
        return (
          Object.prototype.toString.call(object) === '[object Number]' &&
          object % 1 === 0 &&
          !common.isNegativeZero(object)
        )
      }

      module.exports = new Type('tag:yaml.org,2002:int', {
        kind: 'scalar',
        resolve: resolveYamlInteger,
        construct: constructYamlInteger,
        predicate: isInteger,
        represent: {
          binary: function (obj) {
            return obj >= 0
              ? '0b' + obj.toString(2)
              : '-0b' + obj.toString(2).slice(1)
          },
          octal: function (obj) {
            return obj >= 0
              ? '0' + obj.toString(8)
              : '-0' + obj.toString(8).slice(1)
          },
          decimal: function (obj) {
            return obj.toString(10)
          },
          /* eslint-disable max-len */
          hexadecimal: function (obj) {
            return obj >= 0
              ? '0x' + obj.toString(16).toUpperCase()
              : '-0x' + obj.toString(16).toUpperCase().slice(1)
          },
        },
        defaultStyle: 'decimal',
        styleAliases: {
          binary: [2, 'bin'],
          octal: [8, 'oct'],
          decimal: [10, 'dec'],
          hexadecimal: [16, 'hex'],
        },
      })

      /***/
    },

    /***/ 5050: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var esprima

      // Browserified version does not have esprima
      //
      // 1. For node.js just require module as deps
      // 2. For browser try to require mudule via external AMD system.
      //    If not found - try to fallback to window.esprima. If not
      //    found too - then fail to parse.
      //
      try {
        // workaround to exclude package from browserify list.
        var _require = require
        esprima = _require('esprima')
      } catch (_) {
        /* eslint-disable no-redeclare */
        /* global window */
        if (typeof window !== 'undefined') esprima = window.esprima
      }

      var Type = __nccwpck_require__(8971)

      function resolveJavascriptFunction(data) {
        if (data === null) return false

        try {
          var source = '(' + data + ')',
            ast = esprima.parse(source, { range: true })

          if (
            ast.type !== 'Program' ||
            ast.body.length !== 1 ||
            ast.body[0].type !== 'ExpressionStatement' ||
            (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
              ast.body[0].expression.type !== 'FunctionExpression')
          ) {
            return false
          }

          return true
        } catch (err) {
          return false
        }
      }

      function constructJavascriptFunction(data) {
        /*jslint evil:true*/

        var source = '(' + data + ')',
          ast = esprima.parse(source, { range: true }),
          params = [],
          body

        if (
          ast.type !== 'Program' ||
          ast.body.length !== 1 ||
          ast.body[0].type !== 'ExpressionStatement' ||
          (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
            ast.body[0].expression.type !== 'FunctionExpression')
        ) {
          throw new Error('Failed to resolve function')
        }

        ast.body[0].expression.params.forEach(function (param) {
          params.push(param.name)
        })

        body = ast.body[0].expression.body.range

        // Esprima's ranges include the first '{' and the last '}' characters on
        // function expressions. So cut them out.
        if (ast.body[0].expression.body.type === 'BlockStatement') {
          /*eslint-disable no-new-func*/
          return new Function(params, source.slice(body[0] + 1, body[1] - 1))
        }
        // ES6 arrow functions can omit the BlockStatement. In that case, just return
        // the body.
        /*eslint-disable no-new-func*/
        return new Function(params, 'return ' + source.slice(body[0], body[1]))
      }

      function representJavascriptFunction(object /*, style*/) {
        return object.toString()
      }

      function isFunction(object) {
        return Object.prototype.toString.call(object) === '[object Function]'
      }

      module.exports = new Type('tag:yaml.org,2002:js/function', {
        kind: 'scalar',
        resolve: resolveJavascriptFunction,
        construct: constructJavascriptFunction,
        predicate: isFunction,
        represent: representJavascriptFunction,
      })

      /***/
    },

    /***/ 7717: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(8971)

      function resolveJavascriptRegExp(data) {
        if (data === null) return false
        if (data.length === 0) return false

        var regexp = data,
          tail = /\/([gim]*)$/.exec(data),
          modifiers = ''

        // if regexp starts with '/' it can have modifiers and must be properly closed
        // `/foo/gim` - modifiers tail can be maximum 3 chars
        if (regexp[0] === '/') {
          if (tail) modifiers = tail[1]

          if (modifiers.length > 3) return false
          // if expression starts with /, is should be properly terminated
          if (regexp[regexp.length - modifiers.length - 1] !== '/') return false
        }

        return true
      }

      function constructJavascriptRegExp(data) {
        var regexp = data,
          tail = /\/([gim]*)$/.exec(data),
          modifiers = ''

        // `/foo/gim` - tail can be maximum 4 chars
        if (regexp[0] === '/') {
          if (tail) modifiers = tail[1]
          regexp = regexp.slice(1, regexp.length - modifiers.length - 1)
        }

        return new RegExp(regexp, modifiers)
      }

      function representJavascriptRegExp(object /*, style*/) {
        var result = '/' + object.source + '/'

        if (object.global) result += 'g'
        if (object.multiline) result += 'm'
        if (object.ignoreCase) result += 'i'

        return result
      }

      function isRegExp(object) {
        return Object.prototype.toString.call(object) === '[object RegExp]'
      }

      module.exports = new Type('tag:yaml.org,2002:js/regexp', {
        kind: 'scalar',
        resolve: resolveJavascriptRegExp,
        construct: constructJavascriptRegExp,
        predicate: isRegExp,
        represent: representJavascriptRegExp,
      })

      /***/
    },

    /***/ 1744: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(8971)

      function resolveJavascriptUndefined() {
        return true
      }

      function constructJavascriptUndefined() {
        /*eslint-disable no-undefined*/
        return undefined
      }

      function representJavascriptUndefined() {
        return ''
      }

      function isUndefined(object) {
        return typeof object === 'undefined'
      }

      module.exports = new Type('tag:yaml.org,2002:js/undefined', {
        kind: 'scalar',
        resolve: resolveJavascriptUndefined,
        construct: constructJavascriptUndefined,
        predicate: isUndefined,
        represent: representJavascriptUndefined,
      })

      /***/
    },

    /***/ 9184: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(8971)

      module.exports = new Type('tag:yaml.org,2002:map', {
        kind: 'mapping',
        construct: function (data) {
          return data !== null ? data : {}
        },
      })

      /***/
    },

    /***/ 4983: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(8971)

      function resolveYamlMerge(data) {
        return data === '<<' || data === null
      }

      module.exports = new Type('tag:yaml.org,2002:merge', {
        kind: 'scalar',
        resolve: resolveYamlMerge,
      })

      /***/
    },

    /***/ 2454: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(8971)

      function resolveYamlNull(data) {
        if (data === null) return true

        var max = data.length

        return (
          (max === 1 && data === '~') ||
          (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'))
        )
      }

      function constructYamlNull() {
        return null
      }

      function isNull(object) {
        return object === null
      }

      module.exports = new Type('tag:yaml.org,2002:null', {
        kind: 'scalar',
        resolve: resolveYamlNull,
        construct: constructYamlNull,
        predicate: isNull,
        represent: {
          canonical: function () {
            return '~'
          },
          lowercase: function () {
            return 'null'
          },
          uppercase: function () {
            return 'NULL'
          },
          camelcase: function () {
            return 'Null'
          },
        },
        defaultStyle: 'lowercase',
      })

      /***/
    },

    /***/ 2856: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(8971)

      var _hasOwnProperty = Object.prototype.hasOwnProperty
      var _toString = Object.prototype.toString

      function resolveYamlOmap(data) {
        if (data === null) return true

        var objectKeys = [],
          index,
          length,
          pair,
          pairKey,
          pairHasKey,
          object = data

        for (index = 0, length = object.length; index < length; index += 1) {
          pair = object[index]
          pairHasKey = false

          if (_toString.call(pair) !== '[object Object]') return false

          for (pairKey in pair) {
            if (_hasOwnProperty.call(pair, pairKey)) {
              if (!pairHasKey) pairHasKey = true
              else return false
            }
          }

          if (!pairHasKey) return false

          if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey)
          else return false
        }

        return true
      }

      function constructYamlOmap(data) {
        return data !== null ? data : []
      }

      module.exports = new Type('tag:yaml.org,2002:omap', {
        kind: 'sequence',
        resolve: resolveYamlOmap,
        construct: constructYamlOmap,
      })

      /***/
    },

    /***/ 6672: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(8971)

      var _toString = Object.prototype.toString

      function resolveYamlPairs(data) {
        if (data === null) return true

        var index,
          length,
          pair,
          keys,
          result,
          object = data

        result = new Array(object.length)

        for (index = 0, length = object.length; index < length; index += 1) {
          pair = object[index]

          if (_toString.call(pair) !== '[object Object]') return false

          keys = Object.keys(pair)

          if (keys.length !== 1) return false

          result[index] = [keys[0], pair[keys[0]]]
        }

        return true
      }

      function constructYamlPairs(data) {
        if (data === null) return []

        var index,
          length,
          pair,
          keys,
          result,
          object = data

        result = new Array(object.length)

        for (index = 0, length = object.length; index < length; index += 1) {
          pair = object[index]

          keys = Object.keys(pair)

          result[index] = [keys[0], pair[keys[0]]]
        }

        return result
      }

      module.exports = new Type('tag:yaml.org,2002:pairs', {
        kind: 'sequence',
        resolve: resolveYamlPairs,
        construct: constructYamlPairs,
      })

      /***/
    },

    /***/ 2318: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(8971)

      module.exports = new Type('tag:yaml.org,2002:seq', {
        kind: 'sequence',
        construct: function (data) {
          return data !== null ? data : []
        },
      })

      /***/
    },

    /***/ 582: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(8971)

      var _hasOwnProperty = Object.prototype.hasOwnProperty

      function resolveYamlSet(data) {
        if (data === null) return true

        var key,
          object = data

        for (key in object) {
          if (_hasOwnProperty.call(object, key)) {
            if (object[key] !== null) return false
          }
        }

        return true
      }

      function constructYamlSet(data) {
        return data !== null ? data : {}
      }

      module.exports = new Type('tag:yaml.org,2002:set', {
        kind: 'mapping',
        resolve: resolveYamlSet,
        construct: constructYamlSet,
      })

      /***/
    },

    /***/ 9930: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(8971)

      module.exports = new Type('tag:yaml.org,2002:str', {
        kind: 'scalar',
        construct: function (data) {
          return data !== null ? data : ''
        },
      })

      /***/
    },

    /***/ 9159: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(8971)

      var YAML_DATE_REGEXP = new RegExp(
        '^([0-9][0-9][0-9][0-9])' + // [1] year
          '-([0-9][0-9])' + // [2] month
          '-([0-9][0-9])$'
      ) // [3] day

      var YAML_TIMESTAMP_REGEXP = new RegExp(
        '^([0-9][0-9][0-9][0-9])' + // [1] year
          '-([0-9][0-9]?)' + // [2] month
          '-([0-9][0-9]?)' + // [3] day
          '(?:[Tt]|[ \\t]+)' + // ...
          '([0-9][0-9]?)' + // [4] hour
          ':([0-9][0-9])' + // [5] minute
          ':([0-9][0-9])' + // [6] second
          '(?:\\.([0-9]*))?' + // [7] fraction
          '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
          '(?::([0-9][0-9]))?))?$'
      ) // [11] tz_minute

      function resolveYamlTimestamp(data) {
        if (data === null) return false
        if (YAML_DATE_REGEXP.exec(data) !== null) return true
        if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true
        return false
      }

      function constructYamlTimestamp(data) {
        var match,
          year,
          month,
          day,
          hour,
          minute,
          second,
          fraction = 0,
          delta = null,
          tz_hour,
          tz_minute,
          date

        match = YAML_DATE_REGEXP.exec(data)
        if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data)

        if (match === null) throw new Error('Date resolve error')

        // match: [1] year [2] month [3] day

        year = +match[1]
        month = +match[2] - 1 // JS month starts with 0
        day = +match[3]

        if (!match[4]) {
          // no hour
          return new Date(Date.UTC(year, month, day))
        }

        // match: [4] hour [5] minute [6] second [7] fraction

        hour = +match[4]
        minute = +match[5]
        second = +match[6]

        if (match[7]) {
          fraction = match[7].slice(0, 3)
          while (fraction.length < 3) {
            // milli-seconds
            fraction += '0'
          }
          fraction = +fraction
        }

        // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

        if (match[9]) {
          tz_hour = +match[10]
          tz_minute = +(match[11] || 0)
          delta = (tz_hour * 60 + tz_minute) * 60000 // delta in mili-seconds
          if (match[9] === '-') delta = -delta
        }

        date = new Date(
          Date.UTC(year, month, day, hour, minute, second, fraction)
        )

        if (delta) date.setTime(date.getTime() - delta)

        return date
      }

      function representYamlTimestamp(object /*, style*/) {
        return object.toISOString()
      }

      module.exports = new Type('tag:yaml.org,2002:timestamp', {
        kind: 'scalar',
        resolve: resolveYamlTimestamp,
        construct: constructYamlTimestamp,
        instanceOf: Date,
        represent: representYamlTimestamp,
      })

      /***/
    },

    /***/ 8512: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })

      var fs = __nccwpck_require__(5630)
      var path = __nccwpck_require__(1017)
      var getPackages = __nccwpck_require__(8166)
      var errors = __nccwpck_require__(6740)

      function _interopDefault(e) {
        return e && e.__esModule ? e : { default: e }
      }

      var path__default = /*#__PURE__*/ _interopDefault(path)

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true,
          })
        } else {
          obj[key] = value
        }

        return obj
      }

      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object)

        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object)
          if (enumerableOnly)
            symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable
            })
          keys.push.apply(keys, symbols)
        }

        return keys
      }

      function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {}

          if (i % 2) {
            ownKeys(Object(source), true).forEach(function (key) {
              _defineProperty(target, key, source[key])
            })
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(
              target,
              Object.getOwnPropertyDescriptors(source)
            )
          } else {
            ownKeys(Object(source)).forEach(function (key) {
              Object.defineProperty(
                target,
                key,
                Object.getOwnPropertyDescriptor(source, key)
              )
            })
          }
        }

        return target
      }

      async function readPreState(cwd) {
        let preStatePath = path__default['default'].resolve(
          cwd,
          '.changeset',
          'pre.json'
        ) // TODO: verify that the pre state isn't broken

        let preState

        try {
          let contents = await fs.readFile(preStatePath, 'utf8')

          try {
            preState = JSON.parse(contents)
          } catch (err) {
            if (err instanceof SyntaxError) {
              console.error('error parsing json:', contents)
            }

            throw err
          }
        } catch (err) {
          if (err.code !== 'ENOENT') {
            throw err
          }
        }

        return preState
      }
      async function exitPre(cwd) {
        let preStatePath = path__default['default'].resolve(
          cwd,
          '.changeset',
          'pre.json'
        ) // TODO: verify that the pre state isn't broken

        let preState = await readPreState(cwd)

        if (preState === undefined) {
          throw new errors.PreExitButNotInPreModeError()
        }

        await fs.outputFile(
          preStatePath,
          JSON.stringify(
            _objectSpread2(
              _objectSpread2({}, preState),
              {},
              {
                mode: 'exit',
              }
            ),
            null,
            2
          ) + '\n'
        )
      }
      async function enterPre(cwd, tag) {
        var _preState$changesets

        let packages = await getPackages.getPackages(cwd)
        let preStatePath = path__default['default'].resolve(
          packages.root.dir,
          '.changeset',
          'pre.json'
        )
        let preState = await readPreState(packages.root.dir) // can't reenter if pre mode still exists, but we should allow exited pre mode to be reentered

        if (
          (preState === null || preState === void 0
            ? void 0
            : preState.mode) === 'pre'
        ) {
          throw new errors.PreEnterButInPreModeError()
        }

        let newPreState = {
          mode: 'pre',
          tag,
          initialVersions: {},
          changesets:
            (_preState$changesets =
              preState === null || preState === void 0
                ? void 0
                : preState.changesets) !== null &&
            _preState$changesets !== void 0
              ? _preState$changesets
              : [],
        }

        for (let pkg of packages.packages) {
          newPreState.initialVersions[pkg.packageJson.name] =
            pkg.packageJson.version
        }

        await fs.outputFile(
          preStatePath,
          JSON.stringify(newPreState, null, 2) + '\n'
        )
      }

      exports.enterPre = enterPre
      exports.exitPre = exitPre
      exports.readPreState = readPreState

      /***/
    },

    /***/ 5272: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      if (process.env.NODE_ENV === 'production') {
        module.exports = __nccwpck_require__(925)
      } else {
        module.exports = __nccwpck_require__(8512)
      }

      /***/
    },

    /***/ 925: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: !0,
      })

      var fs = __nccwpck_require__(5630),
        path = __nccwpck_require__(1017),
        getPackages = __nccwpck_require__(8166),
        errors = __nccwpck_require__(6740)

      function _interopDefault(e) {
        return e && e.__esModule
          ? e
          : {
              default: e,
            }
      }

      var path__default = _interopDefault(path)

      function _defineProperty(obj, key, value) {
        return (
          key in obj
            ? Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (obj[key] = value),
          obj
        )
      }

      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object)
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object)
          enumerableOnly &&
            (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable
            })),
            keys.push.apply(keys, symbols)
        }
        return keys
      }

      function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = null != arguments[i] ? arguments[i] : {}
          i % 2
            ? ownKeys(Object(source), !0).forEach(function (key) {
                _defineProperty(target, key, source[key])
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(
                target,
                Object.getOwnPropertyDescriptors(source)
              )
            : ownKeys(Object(source)).forEach(function (key) {
                Object.defineProperty(
                  target,
                  key,
                  Object.getOwnPropertyDescriptor(source, key)
                )
              })
        }
        return target
      }

      async function readPreState(cwd) {
        let preState,
          preStatePath = path__default.default.resolve(
            cwd,
            '.changeset',
            'pre.json'
          )
        try {
          let contents = await fs.readFile(preStatePath, 'utf8')
          try {
            preState = JSON.parse(contents)
          } catch (err) {
            throw (
              (err instanceof SyntaxError &&
                console.error('error parsing json:', contents),
              err)
            )
          }
        } catch (err) {
          if ('ENOENT' !== err.code) throw err
        }
        return preState
      }

      async function exitPre(cwd) {
        let preStatePath = path__default.default.resolve(
            cwd,
            '.changeset',
            'pre.json'
          ),
          preState = await readPreState(cwd)
        if (void 0 === preState) throw new errors.PreExitButNotInPreModeError()
        await fs.outputFile(
          preStatePath,
          JSON.stringify(
            _objectSpread2(
              _objectSpread2({}, preState),
              {},
              {
                mode: 'exit',
              }
            ),
            null,
            2
          ) + '\n'
        )
      }

      async function enterPre(cwd, tag) {
        var _preState$changesets
        let packages = await getPackages.getPackages(cwd),
          preStatePath = path__default.default.resolve(
            packages.root.dir,
            '.changeset',
            'pre.json'
          ),
          preState = await readPreState(packages.root.dir)
        if ('pre' === (null == preState ? void 0 : preState.mode))
          throw new errors.PreEnterButInPreModeError()
        let newPreState = {
          mode: 'pre',
          tag: tag,
          initialVersions: {},
          changesets:
            null !==
              (_preState$changesets =
                null == preState ? void 0 : preState.changesets) &&
            void 0 !== _preState$changesets
              ? _preState$changesets
              : [],
        }
        for (let pkg of packages.packages)
          newPreState.initialVersions[pkg.packageJson.name] =
            pkg.packageJson.version
        await fs.outputFile(
          preStatePath,
          JSON.stringify(newPreState, null, 2) + '\n'
        )
      }

      ;(exports.enterPre = enterPre),
        (exports.exitPre = exitPre),
        (exports.readPreState = readPreState)

      /***/
    },

    /***/ 4106: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })

      var fs = __nccwpck_require__(5630)
      var path = __nccwpck_require__(1017)
      var parse = __nccwpck_require__(9758)
      var git = __nccwpck_require__(3318)
      var chalk = __nccwpck_require__(6869)
      var pFilter = __nccwpck_require__(5886)
      var logger = __nccwpck_require__(6010)

      function _interopDefault(e) {
        return e && e.__esModule ? e : { default: e }
      }

      var fs__default = /*#__PURE__*/ _interopDefault(fs)
      var path__default = /*#__PURE__*/ _interopDefault(path)
      var parse__default = /*#__PURE__*/ _interopDefault(parse)
      var chalk__default = /*#__PURE__*/ _interopDefault(chalk)
      var pFilter__default = /*#__PURE__*/ _interopDefault(pFilter)

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true,
          })
        } else {
          obj[key] = value
        }

        return obj
      }

      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object)

        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object)
          if (enumerableOnly)
            symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable
            })
          keys.push.apply(keys, symbols)
        }

        return keys
      }

      function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {}

          if (i % 2) {
            ownKeys(Object(source), true).forEach(function (key) {
              _defineProperty(target, key, source[key])
            })
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(
              target,
              Object.getOwnPropertyDescriptors(source)
            )
          } else {
            ownKeys(Object(source)).forEach(function (key) {
              Object.defineProperty(
                target,
                key,
                Object.getOwnPropertyDescriptor(source, key)
              )
            })
          }
        }

        return target
      }

      let importantSeparator = chalk__default['default'].red(
        '===============================IMPORTANT!==============================='
      )
      let importantEnd = chalk__default['default'].red(
        '----------------------------------------------------------------------'
      )

      async function getOldChangesets(changesetBase, dirs) {
        // this needs to support just not dealing with dirs that aren't set up properly
        let changesets = await pFilter__default['default'](dirs, async dir =>
          (
            await fs.lstat(path__default['default'].join(changesetBase, dir))
          ).isDirectory()
        )
        const changesetContents = changesets.map(async changesetDir => {
          const jsonPath = path__default['default'].join(
            changesetBase,
            changesetDir,
            'changes.json'
          )
          const [summary, json] = await Promise.all([
            fs.readFile(
              path__default['default'].join(
                changesetBase,
                changesetDir,
                'changes.md'
              ),
              'utf-8'
            ),
            fs.readJson(jsonPath),
          ])
          return {
            releases: json.releases,
            summary,
            id: changesetDir,
          }
        })
        return Promise.all(changesetContents)
      } // this function only exists while we wait for v1 changesets to be obsoleted
      // and should be deleted before v3

      async function getOldChangesetsAndWarn(changesetBase, dirs) {
        let oldChangesets = await getOldChangesets(changesetBase, dirs)

        if (oldChangesets.length === 0) {
          return []
        }

        logger.warn(importantSeparator)
        logger.warn('There were old changesets from version 1 found')
        logger.warn(
          'These are being applied now but the dependents graph may have changed'
        )
        logger.warn('Make sure you validate all your dependencies')
        logger.warn(
          'In a future major version, we will no longer apply these old changesets, and will instead throw here'
        )
        logger.warn(importantEnd)
        return oldChangesets
      }

      async function filterChangesetsSinceRef(
        changesets,
        changesetBase,
        sinceRef
      ) {
        const newChangesets = await git.getChangedChangesetFilesSinceRef({
          cwd: changesetBase,
          ref: sinceRef,
        })
        const newHashes = newChangesets.map(c => c.split('/')[1])
        return changesets.filter(dir => newHashes.includes(dir))
      }

      async function getChangesets(cwd, sinceRef) {
        let changesetBase = path__default['default'].join(cwd, '.changeset')
        let contents

        try {
          contents = await fs__default['default'].readdir(changesetBase)
        } catch (err) {
          if (err.code === 'ENOENT') {
            throw new Error('There is no .changeset directory in this project')
          }

          throw err
        }

        if (sinceRef !== undefined) {
          contents = await filterChangesetsSinceRef(
            contents,
            changesetBase,
            sinceRef
          )
        }

        let oldChangesetsPromise = getOldChangesetsAndWarn(
          changesetBase,
          contents
        )
        let changesets = contents.filter(
          file =>
            !file.startsWith('.') &&
            file.endsWith('.md') &&
            file !== 'README.md'
        )
        const changesetContents = changesets.map(async file => {
          const changeset = await fs__default['default'].readFile(
            path__default['default'].join(changesetBase, file),
            'utf-8'
          )
          return _objectSpread2(
            _objectSpread2({}, parse__default['default'](changeset)),
            {},
            {
              id: file.replace('.md', ''),
            }
          )
        })
        return [
          ...(await oldChangesetsPromise),
          ...(await Promise.all(changesetContents)),
        ]
      }

      exports['default'] = getChangesets

      /***/
    },

    /***/ 1878: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      if (process.env.NODE_ENV === 'production') {
        module.exports = __nccwpck_require__(1312)
      } else {
        module.exports = __nccwpck_require__(4106)
      }

      /***/
    },

    /***/ 1312: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: !0,
      })

      var fs = __nccwpck_require__(5630),
        path = __nccwpck_require__(1017),
        parse = __nccwpck_require__(9758),
        git = __nccwpck_require__(3318),
        chalk = __nccwpck_require__(6869),
        pFilter = __nccwpck_require__(5886),
        logger = __nccwpck_require__(6010)

      function _interopDefault(e) {
        return e && e.__esModule
          ? e
          : {
              default: e,
            }
      }

      var fs__default = _interopDefault(fs),
        path__default = _interopDefault(path),
        parse__default = _interopDefault(parse),
        chalk__default = _interopDefault(chalk),
        pFilter__default = _interopDefault(pFilter)

      function _defineProperty(obj, key, value) {
        return (
          key in obj
            ? Object.defineProperty(obj, key, {
                value: value,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (obj[key] = value),
          obj
        )
      }

      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object)
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object)
          enumerableOnly &&
            (symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable
            })),
            keys.push.apply(keys, symbols)
        }
        return keys
      }

      function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = null != arguments[i] ? arguments[i] : {}
          i % 2
            ? ownKeys(Object(source), !0).forEach(function (key) {
                _defineProperty(target, key, source[key])
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(
                target,
                Object.getOwnPropertyDescriptors(source)
              )
            : ownKeys(Object(source)).forEach(function (key) {
                Object.defineProperty(
                  target,
                  key,
                  Object.getOwnPropertyDescriptor(source, key)
                )
              })
        }
        return target
      }

      let importantSeparator = chalk__default.default.red(
          '===============================IMPORTANT!==============================='
        ),
        importantEnd = chalk__default.default.red(
          '----------------------------------------------------------------------'
        )

      async function getOldChangesets(changesetBase, dirs) {
        const changesetContents = (
          await pFilter__default.default(dirs, async dir =>
            (
              await fs.lstat(path__default.default.join(changesetBase, dir))
            ).isDirectory()
          )
        ).map(async changesetDir => {
          const jsonPath = path__default.default.join(
              changesetBase,
              changesetDir,
              'changes.json'
            ),
            [summary, json] = await Promise.all([
              fs.readFile(
                path__default.default.join(
                  changesetBase,
                  changesetDir,
                  'changes.md'
                ),
                'utf-8'
              ),
              fs.readJson(jsonPath),
            ])
          return {
            releases: json.releases,
            summary: summary,
            id: changesetDir,
          }
        })
        return Promise.all(changesetContents)
      }

      async function getOldChangesetsAndWarn(changesetBase, dirs) {
        let oldChangesets = await getOldChangesets(changesetBase, dirs)
        return 0 === oldChangesets.length
          ? []
          : (logger.warn(importantSeparator),
            logger.warn('There were old changesets from version 1 found'),
            logger.warn(
              'These are being applied now but the dependents graph may have changed'
            ),
            logger.warn('Make sure you validate all your dependencies'),
            logger.warn(
              'In a future major version, we will no longer apply these old changesets, and will instead throw here'
            ),
            logger.warn(importantEnd),
            oldChangesets)
      }

      async function filterChangesetsSinceRef(
        changesets,
        changesetBase,
        sinceRef
      ) {
        const newHashes = (
          await git.getChangedChangesetFilesSinceRef({
            cwd: changesetBase,
            ref: sinceRef,
          })
        ).map(c => c.split('/')[1])
        return changesets.filter(dir => newHashes.includes(dir))
      }

      async function getChangesets(cwd, sinceRef) {
        let contents,
          changesetBase = path__default.default.join(cwd, '.changeset')
        try {
          contents = await fs__default.default.readdir(changesetBase)
        } catch (err) {
          if ('ENOENT' === err.code)
            throw new Error('There is no .changeset directory in this project')
          throw err
        }
        void 0 !== sinceRef &&
          (contents = await filterChangesetsSinceRef(
            contents,
            changesetBase,
            sinceRef
          ))
        let oldChangesetsPromise = getOldChangesetsAndWarn(
          changesetBase,
          contents
        )
        const changesetContents = contents
          .filter(
            file =>
              !file.startsWith('.') &&
              file.endsWith('.md') &&
              'README.md' !== file
          )
          .map(async file => {
            const changeset = await fs__default.default.readFile(
              path__default.default.join(changesetBase, file),
              'utf-8'
            )
            return _objectSpread2(
              _objectSpread2({}, parse__default.default(changeset)),
              {},
              {
                id: file.replace('.md', ''),
              }
            )
          })
        return [
          ...(await oldChangesetsPromise),
          ...(await Promise.all(changesetContents)),
        ]
      }

      exports['default'] = getChangesets

      /***/
    },

    /***/ 352: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })

      var spawn = __nccwpck_require__(4374)
      var fs = __nccwpck_require__(7147)
      var path = __nccwpck_require__(1017)
      var getPackages = __nccwpck_require__(8166)
      var errors = __nccwpck_require__(6740)
      var isSubdir = __nccwpck_require__(8760)
      var micromatch = __nccwpck_require__(6228)

      function _interopDefault(e) {
        return e && e.__esModule ? e : { default: e }
      }

      var spawn__default = /*#__PURE__*/ _interopDefault(spawn)
      var fs__default = /*#__PURE__*/ _interopDefault(fs)
      var path__default = /*#__PURE__*/ _interopDefault(path)
      var isSubdir__default = /*#__PURE__*/ _interopDefault(isSubdir)
      var micromatch__default = /*#__PURE__*/ _interopDefault(micromatch)

      async function add(pathToFile, cwd) {
        const gitCmd = await spawn__default['default'](
          'git',
          ['add', pathToFile],
          {
            cwd,
          }
        )

        if (gitCmd.code !== 0) {
          console.log(pathToFile, gitCmd.stderr.toString())
        }

        return gitCmd.code === 0
      }
      async function commit(message, cwd) {
        const gitCmd = await spawn__default['default'](
          'git',
          ['commit', '-m', message, '--allow-empty'],
          {
            cwd,
          }
        )
        return gitCmd.code === 0
      }
      async function getAllTags(cwd) {
        const gitCmd = await spawn__default['default']('git', ['tag'], {
          cwd,
        })

        if (gitCmd.code !== 0) {
          throw new Error(gitCmd.stderr.toString())
        }

        const tags = gitCmd.stdout.toString().trim().split('\n')
        return new Set(tags)
      } // used to create a single tag at a time for the current head only

      async function tag(tagStr, cwd) {
        // NOTE: it's important we use the -m flag to create annotated tag otherwise 'git push --follow-tags' won't actually push
        // the tags
        const gitCmd = await spawn__default['default'](
          'git',
          ['tag', tagStr, '-m', tagStr],
          {
            cwd,
          }
        )
        return gitCmd.code === 0
      } // Find the commit where we diverged from `ref` at using `git merge-base`

      async function getDivergedCommit(cwd, ref) {
        const cmd = await spawn__default['default'](
          'git',
          ['merge-base', ref, 'HEAD'],
          {
            cwd,
          }
        )

        if (cmd.code !== 0) {
          throw new Error(
            `Failed to find where HEAD diverged from ${ref}. Does ${ref} exist?`
          )
        }

        return cmd.stdout.toString().trim()
      }
      /**
       * Get the SHAs for the commits that added files, including automatically
       * extending a shallow clone if necessary to determine any commits.
       * @param gitPaths - Paths to fetch
       * @param options - `cwd` and `short`
       */

      async function getCommitsThatAddFiles(gitPaths, { cwd, short = false }) {
        // Maps gitPath to commit SHA
        const map = new Map() // Paths we haven't completed processing on yet

        let remaining = gitPaths

        do {
          // Fetch commit information for all paths we don't have yet
          const commitInfos = await Promise.all(
            remaining.map(async gitPath => {
              const [commitSha, parentSha] = (
                await spawn__default['default'](
                  'git',
                  [
                    'log',
                    '--diff-filter=A',
                    '--max-count=1',
                    short ? '--pretty=format:%h:%p' : '--pretty=format:%H:%p',
                    gitPath,
                  ],
                  {
                    cwd,
                  }
                )
              ).stdout
                .toString()
                .split(':')
              return {
                path: gitPath,
                commitSha,
                parentSha,
              }
            })
          ) // To collect commits without parents (usually because they're absent from
          // a shallow clone).

          let commitsWithMissingParents = []

          for (const info of commitInfos) {
            if (info.commitSha) {
              if (info.parentSha) {
                // We have found the parent of the commit that added the file.
                // Therefore we know that the commit is legitimate and isn't simply the boundary of a shallow clone.
                map.set(info.path, info.commitSha)
              } else {
                commitsWithMissingParents.push(info)
              }
            }
          }

          if (commitsWithMissingParents.length === 0) {
            break
          } // The commits we've found may be the real commits or they may be the boundary of
          // a shallow clone.
          // Can we deepen the clone?

          if (
            await isRepoShallow({
              cwd,
            })
          ) {
            // Yes.
            await deepenCloneBy({
              by: 50,
              cwd,
            })
            remaining = commitsWithMissingParents.map(p => p.path)
          } else {
            // It's not a shallow clone, so all the commit SHAs we have are legitimate.
            for (const unresolved of commitsWithMissingParents) {
              map.set(unresolved.path, unresolved.commitSha)
            }

            break
          }
        } while (true)

        return gitPaths.map(p => map.get(p))
      }
      async function isRepoShallow({ cwd }) {
        const isShallowRepoOutput = (
          await spawn__default['default'](
            'git',
            ['rev-parse', '--is-shallow-repository'],
            {
              cwd,
            }
          )
        ).stdout
          .toString()
          .trim()

        if (isShallowRepoOutput === '--is-shallow-repository') {
          // We have an old version of Git (<2.15) which doesn't support `rev-parse --is-shallow-repository`
          // In that case, we'll test for the existence of .git/shallow.
          // Firstly, find the .git folder for the repo; note that this will be relative to the repo dir
          const gitDir = (
            await spawn__default['default']('git', ['rev-parse', '--git-dir'], {
              cwd,
            })
          ).stdout
            .toString()
            .trim()
          const fullGitDir = path__default['default'].resolve(cwd, gitDir) // Check for the existence of <gitDir>/shallow

          return fs__default['default'].existsSync(
            path__default['default'].join(fullGitDir, 'shallow')
          )
        } else {
          // We have a newer Git which supports `rev-parse --is-shallow-repository`. We'll use
          // the output of that instead of messing with .git/shallow in case that changes in the future.
          return isShallowRepoOutput === 'true'
        }
      }
      async function deepenCloneBy({ by, cwd }) {
        await spawn__default['default']('git', ['fetch', `--deepen=${by}`], {
          cwd,
        })
      }

      async function getRepoRoot({ cwd }) {
        const { stdout, code, stderr } = await spawn__default['default'](
          'git',
          ['rev-parse', '--show-toplevel'],
          {
            cwd,
          }
        )

        if (code !== 0) {
          throw new Error(stderr.toString())
        }

        return stdout.toString().trim().replace(/\n|\r/g, '')
      }

      async function getChangedFilesSince({ cwd, ref, fullPath = false }) {
        const divergedAt = await getDivergedCommit(cwd, ref) // Now we can find which files we added

        const cmd = await spawn__default['default'](
          'git',
          ['diff', '--name-only', divergedAt],
          {
            cwd,
          }
        )

        if (cmd.code !== 0) {
          throw new Error(
            `Failed to diff against ${divergedAt}. Is ${divergedAt} a valid ref?`
          )
        }

        const files = cmd.stdout
          .toString()
          .trim()
          .split('\n')
          .filter(a => a)
        if (!fullPath) return files
        const repoRoot = await getRepoRoot({
          cwd,
        })
        return files.map(file =>
          path__default['default'].resolve(repoRoot, file)
        )
      } // below are less generic functions that we use in combination with other things we are doing

      async function getChangedChangesetFilesSinceRef({ cwd, ref }) {
        try {
          const divergedAt = await getDivergedCommit(cwd, ref) // Now we can find which files we added

          const cmd = await spawn__default['default'](
            'git',
            ['diff', '--name-only', '--diff-filter=d', divergedAt],
            {
              cwd,
            }
          )
          let tester = /.changeset\/[^/]+\.md$/
          const files = cmd.stdout
            .toString()
            .trim()
            .split('\n')
            .filter(file => tester.test(file))
          return files
        } catch (err) {
          if (err instanceof errors.GitError) return []
          throw err
        }
      }
      async function getChangedPackagesSinceRef({
        cwd,
        ref,
        changedFilePatterns = ['**'],
      }) {
        const changedFiles = await getChangedFilesSince({
          ref,
          cwd,
          fullPath: true,
        })
        return [...(await getPackages.getPackages(cwd)).packages] // sort packages by length of dir, so that we can check for subdirs first
          .sort((pkgA, pkgB) => pkgB.dir.length - pkgA.dir.length)
          .filter(pkg => {
            const changedPackageFiles = []

            for (let i = changedFiles.length - 1; i >= 0; i--) {
              const file = changedFiles[i]

              if (isSubdir__default['default'](pkg.dir, file)) {
                changedFiles.splice(i, 1)
                const relativeFile = file.slice(pkg.dir.length + 1)
                changedPackageFiles.push(relativeFile)
              }
            }

            return (
              changedPackageFiles.length > 0 &&
              micromatch__default['default'](
                changedPackageFiles,
                changedFilePatterns
              ).length > 0
            )
          })
      }
      async function tagExists(tagStr, cwd) {
        const gitCmd = await spawn__default['default'](
          'git',
          ['tag', '-l', tagStr],
          {
            cwd,
          }
        )
        const output = gitCmd.stdout.toString().trim()
        const tagExists = !!output
        return tagExists
      }
      async function getCurrentCommitId({ cwd, short = false }) {
        return (
          await spawn__default['default'](
            'git',
            ['rev-parse', short && '--short', 'HEAD'].filter(Boolean),
            {
              cwd,
            }
          )
        ).stdout
          .toString()
          .trim()
      }
      async function remoteTagExists(tagStr) {
        const gitCmd = await spawn__default['default']('git', [
          'ls-remote',
          '--tags',
          'origin',
          '-l',
          tagStr,
        ])
        const output = gitCmd.stdout.toString().trim()
        const tagExists = !!output
        return tagExists
      }

      exports.add = add
      exports.commit = commit
      exports.deepenCloneBy = deepenCloneBy
      exports.getAllTags = getAllTags
      exports.getChangedChangesetFilesSinceRef =
        getChangedChangesetFilesSinceRef
      exports.getChangedFilesSince = getChangedFilesSince
      exports.getChangedPackagesSinceRef = getChangedPackagesSinceRef
      exports.getCommitsThatAddFiles = getCommitsThatAddFiles
      exports.getCurrentCommitId = getCurrentCommitId
      exports.getDivergedCommit = getDivergedCommit
      exports.isRepoShallow = isRepoShallow
      exports.remoteTagExists = remoteTagExists
      exports.tag = tag
      exports.tagExists = tagExists

      /***/
    },

    /***/ 3318: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      if (process.env.NODE_ENV === 'production') {
        module.exports = __nccwpck_require__(8399)
      } else {
        module.exports = __nccwpck_require__(352)
      }

      /***/
    },

    /***/ 8399: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: !0,
      })

      var spawn = __nccwpck_require__(4374),
        fs = __nccwpck_require__(7147),
        path = __nccwpck_require__(1017),
        getPackages = __nccwpck_require__(8166),
        errors = __nccwpck_require__(6740),
        isSubdir = __nccwpck_require__(8760),
        micromatch = __nccwpck_require__(6228)

      function _interopDefault(e) {
        return e && e.__esModule
          ? e
          : {
              default: e,
            }
      }

      var spawn__default = _interopDefault(spawn),
        fs__default = _interopDefault(fs),
        path__default = _interopDefault(path),
        isSubdir__default = _interopDefault(isSubdir),
        micromatch__default = _interopDefault(micromatch)

      async function add(pathToFile, cwd) {
        const gitCmd = await spawn__default.default(
          'git',
          ['add', pathToFile],
          {
            cwd: cwd,
          }
        )
        return (
          0 !== gitCmd.code &&
            console.log(pathToFile, gitCmd.stderr.toString()),
          0 === gitCmd.code
        )
      }

      async function commit(message, cwd) {
        return (
          0 ===
          (
            await spawn__default.default(
              'git',
              ['commit', '-m', message, '--allow-empty'],
              {
                cwd: cwd,
              }
            )
          ).code
        )
      }

      async function getAllTags(cwd) {
        const gitCmd = await spawn__default.default('git', ['tag'], {
          cwd: cwd,
        })
        if (0 !== gitCmd.code) throw new Error(gitCmd.stderr.toString())
        const tags = gitCmd.stdout.toString().trim().split('\n')
        return new Set(tags)
      }

      async function tag(tagStr, cwd) {
        return (
          0 ===
          (
            await spawn__default.default('git', ['tag', tagStr, '-m', tagStr], {
              cwd: cwd,
            })
          ).code
        )
      }

      async function getDivergedCommit(cwd, ref) {
        const cmd = await spawn__default.default(
          'git',
          ['merge-base', ref, 'HEAD'],
          {
            cwd: cwd,
          }
        )
        if (0 !== cmd.code)
          throw new Error(
            `Failed to find where HEAD diverged from ${ref}. Does ${ref} exist?`
          )
        return cmd.stdout.toString().trim()
      }

      async function getCommitsThatAddFiles(
        gitPaths,
        { cwd: cwd, short: short = !1 }
      ) {
        const map = new Map()
        let remaining = gitPaths
        for (;;) {
          const commitInfos = await Promise.all(
            remaining.map(async gitPath => {
              const [commitSha, parentSha] = (
                await spawn__default.default(
                  'git',
                  [
                    'log',
                    '--diff-filter=A',
                    '--max-count=1',
                    short ? '--pretty=format:%h:%p' : '--pretty=format:%H:%p',
                    gitPath,
                  ],
                  {
                    cwd: cwd,
                  }
                )
              ).stdout
                .toString()
                .split(':')
              return {
                path: gitPath,
                commitSha: commitSha,
                parentSha: parentSha,
              }
            })
          )
          let commitsWithMissingParents = []
          for (const info of commitInfos)
            info.commitSha &&
              (info.parentSha
                ? map.set(info.path, info.commitSha)
                : commitsWithMissingParents.push(info))
          if (0 === commitsWithMissingParents.length) break
          if (
            !(await isRepoShallow({
              cwd: cwd,
            }))
          ) {
            for (const unresolved of commitsWithMissingParents)
              map.set(unresolved.path, unresolved.commitSha)
            break
          }
          await deepenCloneBy({
            by: 50,
            cwd: cwd,
          }),
            (remaining = commitsWithMissingParents.map(p => p.path))
        }
        return gitPaths.map(p => map.get(p))
      }

      async function isRepoShallow({ cwd: cwd }) {
        const isShallowRepoOutput = (
          await spawn__default.default(
            'git',
            ['rev-parse', '--is-shallow-repository'],
            {
              cwd: cwd,
            }
          )
        ).stdout
          .toString()
          .trim()
        if ('--is-shallow-repository' === isShallowRepoOutput) {
          const gitDir = (
              await spawn__default.default('git', ['rev-parse', '--git-dir'], {
                cwd: cwd,
              })
            ).stdout
              .toString()
              .trim(),
            fullGitDir = path__default.default.resolve(cwd, gitDir)
          return fs__default.default.existsSync(
            path__default.default.join(fullGitDir, 'shallow')
          )
        }
        return 'true' === isShallowRepoOutput
      }

      async function deepenCloneBy({ by: by, cwd: cwd }) {
        await spawn__default.default('git', ['fetch', '--deepen=' + by], {
          cwd: cwd,
        })
      }

      async function getRepoRoot({ cwd: cwd }) {
        const {
          stdout: stdout,
          code: code,
          stderr: stderr,
        } = await spawn__default.default(
          'git',
          ['rev-parse', '--show-toplevel'],
          {
            cwd: cwd,
          }
        )
        if (0 !== code) throw new Error(stderr.toString())
        return stdout.toString().trim().replace(/\n|\r/g, '')
      }

      async function getChangedFilesSince({
        cwd: cwd,
        ref: ref,
        fullPath: fullPath = !1,
      }) {
        const divergedAt = await getDivergedCommit(cwd, ref),
          cmd = await spawn__default.default(
            'git',
            ['diff', '--name-only', divergedAt],
            {
              cwd: cwd,
            }
          )
        if (0 !== cmd.code)
          throw new Error(
            `Failed to diff against ${divergedAt}. Is ${divergedAt} a valid ref?`
          )
        const files = cmd.stdout
          .toString()
          .trim()
          .split('\n')
          .filter(a => a)
        if (!fullPath) return files
        const repoRoot = await getRepoRoot({
          cwd: cwd,
        })
        return files.map(file => path__default.default.resolve(repoRoot, file))
      }

      async function getChangedChangesetFilesSinceRef({ cwd: cwd, ref: ref }) {
        try {
          const divergedAt = await getDivergedCommit(cwd, ref),
            cmd = await spawn__default.default(
              'git',
              ['diff', '--name-only', '--diff-filter=d', divergedAt],
              {
                cwd: cwd,
              }
            )
          let tester = /.changeset\/[^/]+\.md$/
          return cmd.stdout
            .toString()
            .trim()
            .split('\n')
            .filter(file => tester.test(file))
        } catch (err) {
          if (err instanceof errors.GitError) return []
          throw err
        }
      }

      async function getChangedPackagesSinceRef({
        cwd: cwd,
        ref: ref,
        changedFilePatterns: changedFilePatterns = ['**'],
      }) {
        const changedFiles = await getChangedFilesSince({
          ref: ref,
          cwd: cwd,
          fullPath: !0,
        })
        return [...(await getPackages.getPackages(cwd)).packages]
          .sort((pkgA, pkgB) => pkgB.dir.length - pkgA.dir.length)
          .filter(pkg => {
            const changedPackageFiles = []
            for (let i = changedFiles.length - 1; i >= 0; i--) {
              const file = changedFiles[i]
              if (isSubdir__default.default(pkg.dir, file)) {
                changedFiles.splice(i, 1)
                const relativeFile = file.slice(pkg.dir.length + 1)
                changedPackageFiles.push(relativeFile)
              }
            }
            return (
              changedPackageFiles.length > 0 &&
              micromatch__default.default(
                changedPackageFiles,
                changedFilePatterns
              ).length > 0
            )
          })
      }

      async function tagExists(tagStr, cwd) {
        return !!(
          await spawn__default.default('git', ['tag', '-l', tagStr], {
            cwd: cwd,
          })
        ).stdout
          .toString()
          .trim()
      }

      async function getCurrentCommitId({ cwd: cwd, short: short = !1 }) {
        return (
          await spawn__default.default(
            'git',
            ['rev-parse', short && '--short', 'HEAD'].filter(Boolean),
            {
              cwd: cwd,
            }
          )
        ).stdout
          .toString()
          .trim()
      }

      async function remoteTagExists(tagStr) {
        return !!(
          await spawn__default.default('git', [
            'ls-remote',
            '--tags',
            'origin',
            '-l',
            tagStr,
          ])
        ).stdout
          .toString()
          .trim()
      }

      ;(exports.add = add),
        (exports.commit = commit),
        (exports.deepenCloneBy = deepenCloneBy),
        (exports.getAllTags = getAllTags),
        (exports.getChangedChangesetFilesSinceRef =
          getChangedChangesetFilesSinceRef),
        (exports.getChangedFilesSince = getChangedFilesSince),
        (exports.getChangedPackagesSinceRef = getChangedPackagesSinceRef),
        (exports.getCommitsThatAddFiles = getCommitsThatAddFiles),
        (exports.getCurrentCommitId = getCurrentCommitId),
        (exports.getDivergedCommit = getDivergedCommit),
        (exports.isRepoShallow = isRepoShallow),
        (exports.remoteTagExists = remoteTagExists),
        (exports.tag = tag),
        (exports.tagExists = tagExists)

      /***/
    },

    /***/ 5901: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'
      /* module decorator */ module = __nccwpck_require__.nmd(module)

      const colorConvert = __nccwpck_require__(303)

      const wrapAnsi16 = (fn, offset) =>
        function () {
          const code = fn.apply(colorConvert, arguments)
          return `\u001B[${code + offset}m`
        }

      const wrapAnsi256 = (fn, offset) =>
        function () {
          const code = fn.apply(colorConvert, arguments)
          return `\u001B[${38 + offset};5;${code}m`
        }

      const wrapAnsi16m = (fn, offset) =>
        function () {
          const rgb = fn.apply(colorConvert, arguments)
          return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`
        }

      function assembleStyles() {
        const codes = new Map()
        const styles = {
          modifier: {
            reset: [0, 0],
            // 21 isn't widely supported and 22 does the same thing
            bold: [1, 22],
            dim: [2, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            hidden: [8, 28],
            strikethrough: [9, 29],
          },
          color: {
            black: [30, 39],
            red: [31, 39],
            green: [32, 39],
            yellow: [33, 39],
            blue: [34, 39],
            magenta: [35, 39],
            cyan: [36, 39],
            white: [37, 39],
            gray: [90, 39],

            // Bright color
            redBright: [91, 39],
            greenBright: [92, 39],
            yellowBright: [93, 39],
            blueBright: [94, 39],
            magentaBright: [95, 39],
            cyanBright: [96, 39],
            whiteBright: [97, 39],
          },
          bgColor: {
            bgBlack: [40, 49],
            bgRed: [41, 49],
            bgGreen: [42, 49],
            bgYellow: [43, 49],
            bgBlue: [44, 49],
            bgMagenta: [45, 49],
            bgCyan: [46, 49],
            bgWhite: [47, 49],

            // Bright color
            bgBlackBright: [100, 49],
            bgRedBright: [101, 49],
            bgGreenBright: [102, 49],
            bgYellowBright: [103, 49],
            bgBlueBright: [104, 49],
            bgMagentaBright: [105, 49],
            bgCyanBright: [106, 49],
            bgWhiteBright: [107, 49],
          },
        }

        // Fix humans
        styles.color.grey = styles.color.gray

        for (const groupName of Object.keys(styles)) {
          const group = styles[groupName]

          for (const styleName of Object.keys(group)) {
            const style = group[styleName]

            styles[styleName] = {
              open: `\u001B[${style[0]}m`,
              close: `\u001B[${style[1]}m`,
            }

            group[styleName] = styles[styleName]

            codes.set(style[0], style[1])
          }

          Object.defineProperty(styles, groupName, {
            value: group,
            enumerable: false,
          })

          Object.defineProperty(styles, 'codes', {
            value: codes,
            enumerable: false,
          })
        }

        const ansi2ansi = n => n
        const rgb2rgb = (r, g, b) => [r, g, b]

        styles.color.close = '\u001B[39m'
        styles.bgColor.close = '\u001B[49m'

        styles.color.ansi = {
          ansi: wrapAnsi16(ansi2ansi, 0),
        }
        styles.color.ansi256 = {
          ansi256: wrapAnsi256(ansi2ansi, 0),
        }
        styles.color.ansi16m = {
          rgb: wrapAnsi16m(rgb2rgb, 0),
        }

        styles.bgColor.ansi = {
          ansi: wrapAnsi16(ansi2ansi, 10),
        }
        styles.bgColor.ansi256 = {
          ansi256: wrapAnsi256(ansi2ansi, 10),
        }
        styles.bgColor.ansi16m = {
          rgb: wrapAnsi16m(rgb2rgb, 10),
        }

        for (let key of Object.keys(colorConvert)) {
          if (typeof colorConvert[key] !== 'object') {
            continue
          }

          const suite = colorConvert[key]

          if (key === 'ansi16') {
            key = 'ansi'
          }

          if ('ansi16' in suite) {
            styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0)
            styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10)
          }

          if ('ansi256' in suite) {
            styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0)
            styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10)
          }

          if ('rgb' in suite) {
            styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0)
            styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10)
          }
        }

        return styles
      }

      // Make the export immutable
      Object.defineProperty(module, 'exports', {
        enumerable: true,
        get: assembleStyles,
      })

      /***/
    },

    /***/ 6869: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const escapeStringRegexp = __nccwpck_require__(8691)
      const ansiStyles = __nccwpck_require__(5901)
      const stdoutColor = __nccwpck_require__(944).stdout

      const template = __nccwpck_require__(1772)

      const isSimpleWindowsTerm =
        process.platform === 'win32' &&
        !(process.env.TERM || '').toLowerCase().startsWith('xterm')

      // `supportsColor.level` → `ansiStyles.color[name]` mapping
      const levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m']

      // `color-convert` models to exclude from the Chalk API due to conflicts and such
      const skipModels = new Set(['gray'])

      const styles = Object.create(null)

      function applyOptions(obj, options) {
        options = options || {}

        // Detect level if not set manually
        const scLevel = stdoutColor ? stdoutColor.level : 0
        obj.level = options.level === undefined ? scLevel : options.level
        obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0
      }

      function Chalk(options) {
        // We check for this.template here since calling `chalk.constructor()`
        // by itself will have a `this` of a previously constructed chalk object
        if (!this || !(this instanceof Chalk) || this.template) {
          const chalk = {}
          applyOptions(chalk, options)

          chalk.template = function () {
            const args = [].slice.call(arguments)
            return chalkTag.apply(null, [chalk.template].concat(args))
          }

          Object.setPrototypeOf(chalk, Chalk.prototype)
          Object.setPrototypeOf(chalk.template, chalk)

          chalk.template.constructor = Chalk

          return chalk.template
        }

        applyOptions(this, options)
      }

      // Use bright blue on Windows as the normal blue color is illegible
      if (isSimpleWindowsTerm) {
        ansiStyles.blue.open = '\u001B[94m'
      }

      for (const key of Object.keys(ansiStyles)) {
        ansiStyles[key].closeRe = new RegExp(
          escapeStringRegexp(ansiStyles[key].close),
          'g'
        )

        styles[key] = {
          get() {
            const codes = ansiStyles[key]
            return build.call(
              this,
              this._styles ? this._styles.concat(codes) : [codes],
              this._empty,
              key
            )
          },
        }
      }

      styles.visible = {
        get() {
          return build.call(this, this._styles || [], true, 'visible')
        },
      }

      ansiStyles.color.closeRe = new RegExp(
        escapeStringRegexp(ansiStyles.color.close),
        'g'
      )
      for (const model of Object.keys(ansiStyles.color.ansi)) {
        if (skipModels.has(model)) {
          continue
        }

        styles[model] = {
          get() {
            const level = this.level
            return function () {
              const open = ansiStyles.color[levelMapping[level]][model].apply(
                null,
                arguments
              )
              const codes = {
                open,
                close: ansiStyles.color.close,
                closeRe: ansiStyles.color.closeRe,
              }
              return build.call(
                this,
                this._styles ? this._styles.concat(codes) : [codes],
                this._empty,
                model
              )
            }
          },
        }
      }

      ansiStyles.bgColor.closeRe = new RegExp(
        escapeStringRegexp(ansiStyles.bgColor.close),
        'g'
      )
      for (const model of Object.keys(ansiStyles.bgColor.ansi)) {
        if (skipModels.has(model)) {
          continue
        }

        const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1)
        styles[bgModel] = {
          get() {
            const level = this.level
            return function () {
              const open = ansiStyles.bgColor[levelMapping[level]][model].apply(
                null,
                arguments
              )
              const codes = {
                open,
                close: ansiStyles.bgColor.close,
                closeRe: ansiStyles.bgColor.closeRe,
              }
              return build.call(
                this,
                this._styles ? this._styles.concat(codes) : [codes],
                this._empty,
                model
              )
            }
          },
        }
      }

      const proto = Object.defineProperties(() => {}, styles)

      function build(_styles, _empty, key) {
        const builder = function () {
          return applyStyle.apply(builder, arguments)
        }

        builder._styles = _styles
        builder._empty = _empty

        const self = this

        Object.defineProperty(builder, 'level', {
          enumerable: true,
          get() {
            return self.level
          },
          set(level) {
            self.level = level
          },
        })

        Object.defineProperty(builder, 'enabled', {
          enumerable: true,
          get() {
            return self.enabled
          },
          set(enabled) {
            self.enabled = enabled
          },
        })

        // See below for fix regarding invisible grey/dim combination on Windows
        builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey'

        // `__proto__` is used because we must return a function, but there is
        // no way to create a function with a different prototype
        builder.__proto__ = proto // eslint-disable-line no-proto

        return builder
      }

      function applyStyle() {
        // Support varags, but simply cast to string in case there's only one arg
        const args = arguments
        const argsLen = args.length
        let str = String(arguments[0])

        if (argsLen === 0) {
          return ''
        }

        if (argsLen > 1) {
          // Don't slice `arguments`, it prevents V8 optimizations
          for (let a = 1; a < argsLen; a++) {
            str += ' ' + args[a]
          }
        }

        if (!this.enabled || this.level <= 0 || !str) {
          return this._empty ? '' : str
        }

        // Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
        // see https://github.com/chalk/chalk/issues/58
        // If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
        const originalDim = ansiStyles.dim.open
        if (isSimpleWindowsTerm && this.hasGrey) {
          ansiStyles.dim.open = ''
        }

        for (const code of this._styles.slice().reverse()) {
          // Replace any instances already present with a re-opening code
          // otherwise only the part of the string until said closing code
          // will be colored, and the rest will simply be 'plain'.
          str = code.open + str.replace(code.closeRe, code.open) + code.close

          // Close the styling before a linebreak and reopen
          // after next line to fix a bleed issue on macOS
          // https://github.com/chalk/chalk/pull/92
          str = str.replace(/\r?\n/g, `${code.close}$&${code.open}`)
        }

        // Reset the original `dim` if we changed it to work around the Windows dimmed gray issue
        ansiStyles.dim.open = originalDim

        return str
      }

      function chalkTag(chalk, strings) {
        if (!Array.isArray(strings)) {
          // If chalk() was called by itself or with a string,
          // return the string itself as a string.
          return [].slice.call(arguments, 1).join(' ')
        }

        const args = [].slice.call(arguments, 2)
        const parts = [strings.raw[0]]

        for (let i = 1; i < strings.length; i++) {
          parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'))
          parts.push(String(strings.raw[i]))
        }

        return template(chalk, parts.join(''))
      }

      Object.defineProperties(Chalk.prototype, styles)

      module.exports = Chalk() // eslint-disable-line new-cap
      module.exports.supportsColor = stdoutColor
      module.exports['default'] = module.exports // For TypeScript

      /***/
    },

    /***/ 1772: /***/ module => {
      'use strict'

      const TEMPLATE_REGEX =
        /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi
      const STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g
      const STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/
      const ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi

      const ESCAPES = new Map([
        ['n', '\n'],
        ['r', '\r'],
        ['t', '\t'],
        ['b', '\b'],
        ['f', '\f'],
        ['v', '\v'],
        ['0', '\0'],
        ['\\', '\\'],
        ['e', '\u001B'],
        ['a', '\u0007'],
      ])

      function unescape(c) {
        if (
          (c[0] === 'u' && c.length === 5) ||
          (c[0] === 'x' && c.length === 3)
        ) {
          return String.fromCharCode(parseInt(c.slice(1), 16))
        }

        return ESCAPES.get(c) || c
      }

      function parseArguments(name, args) {
        const results = []
        const chunks = args.trim().split(/\s*,\s*/g)
        let matches

        for (const chunk of chunks) {
          if (!isNaN(chunk)) {
            results.push(Number(chunk))
          } else if ((matches = chunk.match(STRING_REGEX))) {
            results.push(
              matches[2].replace(ESCAPE_REGEX, (m, escape, chr) =>
                escape ? unescape(escape) : chr
              )
            )
          } else {
            throw new Error(
              `Invalid Chalk template style argument: ${chunk} (in style '${name}')`
            )
          }
        }

        return results
      }

      function parseStyle(style) {
        STYLE_REGEX.lastIndex = 0

        const results = []
        let matches

        while ((matches = STYLE_REGEX.exec(style)) !== null) {
          const name = matches[1]

          if (matches[2]) {
            const args = parseArguments(name, matches[2])
            results.push([name].concat(args))
          } else {
            results.push([name])
          }
        }

        return results
      }

      function buildStyle(chalk, styles) {
        const enabled = {}

        for (const layer of styles) {
          for (const style of layer.styles) {
            enabled[style[0]] = layer.inverse ? null : style.slice(1)
          }
        }

        let current = chalk
        for (const styleName of Object.keys(enabled)) {
          if (Array.isArray(enabled[styleName])) {
            if (!(styleName in current)) {
              throw new Error(`Unknown Chalk style: ${styleName}`)
            }

            if (enabled[styleName].length > 0) {
              current = current[styleName].apply(current, enabled[styleName])
            } else {
              current = current[styleName]
            }
          }
        }

        return current
      }

      module.exports = (chalk, tmp) => {
        const styles = []
        const chunks = []
        let chunk = []

        // eslint-disable-next-line max-params
        tmp.replace(
          TEMPLATE_REGEX,
          (m, escapeChar, inverse, style, close, chr) => {
            if (escapeChar) {
              chunk.push(unescape(escapeChar))
            } else if (style) {
              const str = chunk.join('')
              chunk = []
              chunks.push(
                styles.length === 0 ? str : buildStyle(chalk, styles)(str)
              )
              styles.push({ inverse, styles: parseStyle(style) })
            } else if (close) {
              if (styles.length === 0) {
                throw new Error('Found extraneous } in Chalk template literal')
              }

              chunks.push(buildStyle(chalk, styles)(chunk.join('')))
              chunk = []
              styles.pop()
            } else {
              chunk.push(chr)
            }
          }
        )

        chunks.push(chunk.join(''))

        if (styles.length > 0) {
          const errMsg = `Chalk template literal is missing ${
            styles.length
          } closing bracket${styles.length === 1 ? '' : 's'} (\`}\`)`
          throw new Error(errMsg)
        }

        return chunks.join('')
      }

      /***/
    },

    /***/ 8686: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      /* MIT license */
      var cssKeywords = __nccwpck_require__(3843)

      // NOTE: conversions should only return primitive values (i.e. arrays, or
      //       values that give correct `typeof` results).
      //       do not use box values types (i.e. Number(), String(), etc.)

      var reverseKeywords = {}
      for (var key in cssKeywords) {
        if (cssKeywords.hasOwnProperty(key)) {
          reverseKeywords[cssKeywords[key]] = key
        }
      }

      var convert = (module.exports = {
        rgb: { channels: 3, labels: 'rgb' },
        hsl: { channels: 3, labels: 'hsl' },
        hsv: { channels: 3, labels: 'hsv' },
        hwb: { channels: 3, labels: 'hwb' },
        cmyk: { channels: 4, labels: 'cmyk' },
        xyz: { channels: 3, labels: 'xyz' },
        lab: { channels: 3, labels: 'lab' },
        lch: { channels: 3, labels: 'lch' },
        hex: { channels: 1, labels: ['hex'] },
        keyword: { channels: 1, labels: ['keyword'] },
        ansi16: { channels: 1, labels: ['ansi16'] },
        ansi256: { channels: 1, labels: ['ansi256'] },
        hcg: { channels: 3, labels: ['h', 'c', 'g'] },
        apple: { channels: 3, labels: ['r16', 'g16', 'b16'] },
        gray: { channels: 1, labels: ['gray'] },
      })

      // hide .channels and .labels properties
      for (var model in convert) {
        if (convert.hasOwnProperty(model)) {
          if (!('channels' in convert[model])) {
            throw new Error('missing channels property: ' + model)
          }

          if (!('labels' in convert[model])) {
            throw new Error('missing channel labels property: ' + model)
          }

          if (convert[model].labels.length !== convert[model].channels) {
            throw new Error('channel and label counts mismatch: ' + model)
          }

          var channels = convert[model].channels
          var labels = convert[model].labels
          delete convert[model].channels
          delete convert[model].labels
          Object.defineProperty(convert[model], 'channels', { value: channels })
          Object.defineProperty(convert[model], 'labels', { value: labels })
        }
      }

      convert.rgb.hsl = function (rgb) {
        var r = rgb[0] / 255
        var g = rgb[1] / 255
        var b = rgb[2] / 255
        var min = Math.min(r, g, b)
        var max = Math.max(r, g, b)
        var delta = max - min
        var h
        var s
        var l

        if (max === min) {
          h = 0
        } else if (r === max) {
          h = (g - b) / delta
        } else if (g === max) {
          h = 2 + (b - r) / delta
        } else if (b === max) {
          h = 4 + (r - g) / delta
        }

        h = Math.min(h * 60, 360)

        if (h < 0) {
          h += 360
        }

        l = (min + max) / 2

        if (max === min) {
          s = 0
        } else if (l <= 0.5) {
          s = delta / (max + min)
        } else {
          s = delta / (2 - max - min)
        }

        return [h, s * 100, l * 100]
      }

      convert.rgb.hsv = function (rgb) {
        var rdif
        var gdif
        var bdif
        var h
        var s

        var r = rgb[0] / 255
        var g = rgb[1] / 255
        var b = rgb[2] / 255
        var v = Math.max(r, g, b)
        var diff = v - Math.min(r, g, b)
        var diffc = function (c) {
          return (v - c) / 6 / diff + 1 / 2
        }

        if (diff === 0) {
          h = s = 0
        } else {
          s = diff / v
          rdif = diffc(r)
          gdif = diffc(g)
          bdif = diffc(b)

          if (r === v) {
            h = bdif - gdif
          } else if (g === v) {
            h = 1 / 3 + rdif - bdif
          } else if (b === v) {
            h = 2 / 3 + gdif - rdif
          }
          if (h < 0) {
            h += 1
          } else if (h > 1) {
            h -= 1
          }
        }

        return [h * 360, s * 100, v * 100]
      }

      convert.rgb.hwb = function (rgb) {
        var r = rgb[0]
        var g = rgb[1]
        var b = rgb[2]
        var h = convert.rgb.hsl(rgb)[0]
        var w = (1 / 255) * Math.min(r, Math.min(g, b))

        b = 1 - (1 / 255) * Math.max(r, Math.max(g, b))

        return [h, w * 100, b * 100]
      }

      convert.rgb.cmyk = function (rgb) {
        var r = rgb[0] / 255
        var g = rgb[1] / 255
        var b = rgb[2] / 255
        var c
        var m
        var y
        var k

        k = Math.min(1 - r, 1 - g, 1 - b)
        c = (1 - r - k) / (1 - k) || 0
        m = (1 - g - k) / (1 - k) || 0
        y = (1 - b - k) / (1 - k) || 0

        return [c * 100, m * 100, y * 100, k * 100]
      }

      /**
       * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
       * */
      function comparativeDistance(x, y) {
        return (
          Math.pow(x[0] - y[0], 2) +
          Math.pow(x[1] - y[1], 2) +
          Math.pow(x[2] - y[2], 2)
        )
      }

      convert.rgb.keyword = function (rgb) {
        var reversed = reverseKeywords[rgb]
        if (reversed) {
          return reversed
        }

        var currentClosestDistance = Infinity
        var currentClosestKeyword

        for (var keyword in cssKeywords) {
          if (cssKeywords.hasOwnProperty(keyword)) {
            var value = cssKeywords[keyword]

            // Compute comparative distance
            var distance = comparativeDistance(rgb, value)

            // Check if its less, if so set as closest
            if (distance < currentClosestDistance) {
              currentClosestDistance = distance
              currentClosestKeyword = keyword
            }
          }
        }

        return currentClosestKeyword
      }

      convert.keyword.rgb = function (keyword) {
        return cssKeywords[keyword]
      }

      convert.rgb.xyz = function (rgb) {
        var r = rgb[0] / 255
        var g = rgb[1] / 255
        var b = rgb[2] / 255

        // assume sRGB
        r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92
        g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92
        b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92

        var x = r * 0.4124 + g * 0.3576 + b * 0.1805
        var y = r * 0.2126 + g * 0.7152 + b * 0.0722
        var z = r * 0.0193 + g * 0.1192 + b * 0.9505

        return [x * 100, y * 100, z * 100]
      }

      convert.rgb.lab = function (rgb) {
        var xyz = convert.rgb.xyz(rgb)
        var x = xyz[0]
        var y = xyz[1]
        var z = xyz[2]
        var l
        var a
        var b

        x /= 95.047
        y /= 100
        z /= 108.883

        x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116
        y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116
        z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116

        l = 116 * y - 16
        a = 500 * (x - y)
        b = 200 * (y - z)

        return [l, a, b]
      }

      convert.hsl.rgb = function (hsl) {
        var h = hsl[0] / 360
        var s = hsl[1] / 100
        var l = hsl[2] / 100
        var t1
        var t2
        var t3
        var rgb
        var val

        if (s === 0) {
          val = l * 255
          return [val, val, val]
        }

        if (l < 0.5) {
          t2 = l * (1 + s)
        } else {
          t2 = l + s - l * s
        }

        t1 = 2 * l - t2

        rgb = [0, 0, 0]
        for (var i = 0; i < 3; i++) {
          t3 = h + (1 / 3) * -(i - 1)
          if (t3 < 0) {
            t3++
          }
          if (t3 > 1) {
            t3--
          }

          if (6 * t3 < 1) {
            val = t1 + (t2 - t1) * 6 * t3
          } else if (2 * t3 < 1) {
            val = t2
          } else if (3 * t3 < 2) {
            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6
          } else {
            val = t1
          }

          rgb[i] = val * 255
        }

        return rgb
      }

      convert.hsl.hsv = function (hsl) {
        var h = hsl[0]
        var s = hsl[1] / 100
        var l = hsl[2] / 100
        var smin = s
        var lmin = Math.max(l, 0.01)
        var sv
        var v

        l *= 2
        s *= l <= 1 ? l : 2 - l
        smin *= lmin <= 1 ? lmin : 2 - lmin
        v = (l + s) / 2
        sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s)

        return [h, sv * 100, v * 100]
      }

      convert.hsv.rgb = function (hsv) {
        var h = hsv[0] / 60
        var s = hsv[1] / 100
        var v = hsv[2] / 100
        var hi = Math.floor(h) % 6

        var f = h - Math.floor(h)
        var p = 255 * v * (1 - s)
        var q = 255 * v * (1 - s * f)
        var t = 255 * v * (1 - s * (1 - f))
        v *= 255

        switch (hi) {
          case 0:
            return [v, t, p]
          case 1:
            return [q, v, p]
          case 2:
            return [p, v, t]
          case 3:
            return [p, q, v]
          case 4:
            return [t, p, v]
          case 5:
            return [v, p, q]
        }
      }

      convert.hsv.hsl = function (hsv) {
        var h = hsv[0]
        var s = hsv[1] / 100
        var v = hsv[2] / 100
        var vmin = Math.max(v, 0.01)
        var lmin
        var sl
        var l

        l = (2 - s) * v
        lmin = (2 - s) * vmin
        sl = s * vmin
        sl /= lmin <= 1 ? lmin : 2 - lmin
        sl = sl || 0
        l /= 2

        return [h, sl * 100, l * 100]
      }

      // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
      convert.hwb.rgb = function (hwb) {
        var h = hwb[0] / 360
        var wh = hwb[1] / 100
        var bl = hwb[2] / 100
        var ratio = wh + bl
        var i
        var v
        var f
        var n

        // wh + bl cant be > 1
        if (ratio > 1) {
          wh /= ratio
          bl /= ratio
        }

        i = Math.floor(6 * h)
        v = 1 - bl
        f = 6 * h - i

        if ((i & 0x01) !== 0) {
          f = 1 - f
        }

        n = wh + f * (v - wh) // linear interpolation

        var r
        var g
        var b
        switch (i) {
          default:
          case 6:
          case 0:
            r = v
            g = n
            b = wh
            break
          case 1:
            r = n
            g = v
            b = wh
            break
          case 2:
            r = wh
            g = v
            b = n
            break
          case 3:
            r = wh
            g = n
            b = v
            break
          case 4:
            r = n
            g = wh
            b = v
            break
          case 5:
            r = v
            g = wh
            b = n
            break
        }

        return [r * 255, g * 255, b * 255]
      }

      convert.cmyk.rgb = function (cmyk) {
        var c = cmyk[0] / 100
        var m = cmyk[1] / 100
        var y = cmyk[2] / 100
        var k = cmyk[3] / 100
        var r
        var g
        var b

        r = 1 - Math.min(1, c * (1 - k) + k)
        g = 1 - Math.min(1, m * (1 - k) + k)
        b = 1 - Math.min(1, y * (1 - k) + k)

        return [r * 255, g * 255, b * 255]
      }

      convert.xyz.rgb = function (xyz) {
        var x = xyz[0] / 100
        var y = xyz[1] / 100
        var z = xyz[2] / 100
        var r
        var g
        var b

        r = x * 3.2406 + y * -1.5372 + z * -0.4986
        g = x * -0.9689 + y * 1.8758 + z * 0.0415
        b = x * 0.0557 + y * -0.204 + z * 1.057

        // assume sRGB
        r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r * 12.92

        g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g * 12.92

        b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b * 12.92

        r = Math.min(Math.max(0, r), 1)
        g = Math.min(Math.max(0, g), 1)
        b = Math.min(Math.max(0, b), 1)

        return [r * 255, g * 255, b * 255]
      }

      convert.xyz.lab = function (xyz) {
        var x = xyz[0]
        var y = xyz[1]
        var z = xyz[2]
        var l
        var a
        var b

        x /= 95.047
        y /= 100
        z /= 108.883

        x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116
        y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116
        z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116

        l = 116 * y - 16
        a = 500 * (x - y)
        b = 200 * (y - z)

        return [l, a, b]
      }

      convert.lab.xyz = function (lab) {
        var l = lab[0]
        var a = lab[1]
        var b = lab[2]
        var x
        var y
        var z

        y = (l + 16) / 116
        x = a / 500 + y
        z = y - b / 200

        var y2 = Math.pow(y, 3)
        var x2 = Math.pow(x, 3)
        var z2 = Math.pow(z, 3)
        y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787
        x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787
        z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787

        x *= 95.047
        y *= 100
        z *= 108.883

        return [x, y, z]
      }

      convert.lab.lch = function (lab) {
        var l = lab[0]
        var a = lab[1]
        var b = lab[2]
        var hr
        var h
        var c

        hr = Math.atan2(b, a)
        h = (hr * 360) / 2 / Math.PI

        if (h < 0) {
          h += 360
        }

        c = Math.sqrt(a * a + b * b)

        return [l, c, h]
      }

      convert.lch.lab = function (lch) {
        var l = lch[0]
        var c = lch[1]
        var h = lch[2]
        var a
        var b
        var hr

        hr = (h / 360) * 2 * Math.PI
        a = c * Math.cos(hr)
        b = c * Math.sin(hr)

        return [l, a, b]
      }

      convert.rgb.ansi16 = function (args) {
        var r = args[0]
        var g = args[1]
        var b = args[2]
        var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2] // hsv -> ansi16 optimization

        value = Math.round(value / 50)

        if (value === 0) {
          return 30
        }

        var ansi =
          30 +
          ((Math.round(b / 255) << 2) |
            (Math.round(g / 255) << 1) |
            Math.round(r / 255))

        if (value === 2) {
          ansi += 60
        }

        return ansi
      }

      convert.hsv.ansi16 = function (args) {
        // optimization here; we already know the value and don't need to get
        // it converted for us.
        return convert.rgb.ansi16(convert.hsv.rgb(args), args[2])
      }

      convert.rgb.ansi256 = function (args) {
        var r = args[0]
        var g = args[1]
        var b = args[2]

        // we use the extended greyscale palette here, with the exception of
        // black and white. normal palette only has 4 greyscale shades.
        if (r === g && g === b) {
          if (r < 8) {
            return 16
          }

          if (r > 248) {
            return 231
          }

          return Math.round(((r - 8) / 247) * 24) + 232
        }

        var ansi =
          16 +
          36 * Math.round((r / 255) * 5) +
          6 * Math.round((g / 255) * 5) +
          Math.round((b / 255) * 5)

        return ansi
      }

      convert.ansi16.rgb = function (args) {
        var color = args % 10

        // handle greyscale
        if (color === 0 || color === 7) {
          if (args > 50) {
            color += 3.5
          }

          color = (color / 10.5) * 255

          return [color, color, color]
        }

        var mult = (~~(args > 50) + 1) * 0.5
        var r = (color & 1) * mult * 255
        var g = ((color >> 1) & 1) * mult * 255
        var b = ((color >> 2) & 1) * mult * 255

        return [r, g, b]
      }

      convert.ansi256.rgb = function (args) {
        // handle greyscale
        if (args >= 232) {
          var c = (args - 232) * 10 + 8
          return [c, c, c]
        }

        args -= 16

        var rem
        var r = (Math.floor(args / 36) / 5) * 255
        var g = (Math.floor((rem = args % 36) / 6) / 5) * 255
        var b = ((rem % 6) / 5) * 255

        return [r, g, b]
      }

      convert.rgb.hex = function (args) {
        var integer =
          ((Math.round(args[0]) & 0xff) << 16) +
          ((Math.round(args[1]) & 0xff) << 8) +
          (Math.round(args[2]) & 0xff)

        var string = integer.toString(16).toUpperCase()
        return '000000'.substring(string.length) + string
      }

      convert.hex.rgb = function (args) {
        var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i)
        if (!match) {
          return [0, 0, 0]
        }

        var colorString = match[0]

        if (match[0].length === 3) {
          colorString = colorString
            .split('')
            .map(function (char) {
              return char + char
            })
            .join('')
        }

        var integer = parseInt(colorString, 16)
        var r = (integer >> 16) & 0xff
        var g = (integer >> 8) & 0xff
        var b = integer & 0xff

        return [r, g, b]
      }

      convert.rgb.hcg = function (rgb) {
        var r = rgb[0] / 255
        var g = rgb[1] / 255
        var b = rgb[2] / 255
        var max = Math.max(Math.max(r, g), b)
        var min = Math.min(Math.min(r, g), b)
        var chroma = max - min
        var grayscale
        var hue

        if (chroma < 1) {
          grayscale = min / (1 - chroma)
        } else {
          grayscale = 0
        }

        if (chroma <= 0) {
          hue = 0
        } else if (max === r) {
          hue = ((g - b) / chroma) % 6
        } else if (max === g) {
          hue = 2 + (b - r) / chroma
        } else {
          hue = 4 + (r - g) / chroma + 4
        }

        hue /= 6
        hue %= 1

        return [hue * 360, chroma * 100, grayscale * 100]
      }

      convert.hsl.hcg = function (hsl) {
        var s = hsl[1] / 100
        var l = hsl[2] / 100
        var c = 1
        var f = 0

        if (l < 0.5) {
          c = 2.0 * s * l
        } else {
          c = 2.0 * s * (1.0 - l)
        }

        if (c < 1.0) {
          f = (l - 0.5 * c) / (1.0 - c)
        }

        return [hsl[0], c * 100, f * 100]
      }

      convert.hsv.hcg = function (hsv) {
        var s = hsv[1] / 100
        var v = hsv[2] / 100

        var c = s * v
        var f = 0

        if (c < 1.0) {
          f = (v - c) / (1 - c)
        }

        return [hsv[0], c * 100, f * 100]
      }

      convert.hcg.rgb = function (hcg) {
        var h = hcg[0] / 360
        var c = hcg[1] / 100
        var g = hcg[2] / 100

        if (c === 0.0) {
          return [g * 255, g * 255, g * 255]
        }

        var pure = [0, 0, 0]
        var hi = (h % 1) * 6
        var v = hi % 1
        var w = 1 - v
        var mg = 0

        switch (Math.floor(hi)) {
          case 0:
            pure[0] = 1
            pure[1] = v
            pure[2] = 0
            break
          case 1:
            pure[0] = w
            pure[1] = 1
            pure[2] = 0
            break
          case 2:
            pure[0] = 0
            pure[1] = 1
            pure[2] = v
            break
          case 3:
            pure[0] = 0
            pure[1] = w
            pure[2] = 1
            break
          case 4:
            pure[0] = v
            pure[1] = 0
            pure[2] = 1
            break
          default:
            pure[0] = 1
            pure[1] = 0
            pure[2] = w
        }

        mg = (1.0 - c) * g

        return [
          (c * pure[0] + mg) * 255,
          (c * pure[1] + mg) * 255,
          (c * pure[2] + mg) * 255,
        ]
      }

      convert.hcg.hsv = function (hcg) {
        var c = hcg[1] / 100
        var g = hcg[2] / 100

        var v = c + g * (1.0 - c)
        var f = 0

        if (v > 0.0) {
          f = c / v
        }

        return [hcg[0], f * 100, v * 100]
      }

      convert.hcg.hsl = function (hcg) {
        var c = hcg[1] / 100
        var g = hcg[2] / 100

        var l = g * (1.0 - c) + 0.5 * c
        var s = 0

        if (l > 0.0 && l < 0.5) {
          s = c / (2 * l)
        } else if (l >= 0.5 && l < 1.0) {
          s = c / (2 * (1 - l))
        }

        return [hcg[0], s * 100, l * 100]
      }

      convert.hcg.hwb = function (hcg) {
        var c = hcg[1] / 100
        var g = hcg[2] / 100
        var v = c + g * (1.0 - c)
        return [hcg[0], (v - c) * 100, (1 - v) * 100]
      }

      convert.hwb.hcg = function (hwb) {
        var w = hwb[1] / 100
        var b = hwb[2] / 100
        var v = 1 - b
        var c = v - w
        var g = 0

        if (c < 1) {
          g = (v - c) / (1 - c)
        }

        return [hwb[0], c * 100, g * 100]
      }

      convert.apple.rgb = function (apple) {
        return [
          (apple[0] / 65535) * 255,
          (apple[1] / 65535) * 255,
          (apple[2] / 65535) * 255,
        ]
      }

      convert.rgb.apple = function (rgb) {
        return [
          (rgb[0] / 255) * 65535,
          (rgb[1] / 255) * 65535,
          (rgb[2] / 255) * 65535,
        ]
      }

      convert.gray.rgb = function (args) {
        return [
          (args[0] / 100) * 255,
          (args[0] / 100) * 255,
          (args[0] / 100) * 255,
        ]
      }

      convert.gray.hsl = convert.gray.hsv = function (args) {
        return [0, 0, args[0]]
      }

      convert.gray.hwb = function (gray) {
        return [0, 100, gray[0]]
      }

      convert.gray.cmyk = function (gray) {
        return [0, 0, 0, gray[0]]
      }

      convert.gray.lab = function (gray) {
        return [gray[0], 0, 0]
      }

      convert.gray.hex = function (gray) {
        var val = Math.round((gray[0] / 100) * 255) & 0xff
        var integer = (val << 16) + (val << 8) + val

        var string = integer.toString(16).toUpperCase()
        return '000000'.substring(string.length) + string
      }

      convert.rgb.gray = function (rgb) {
        var val = (rgb[0] + rgb[1] + rgb[2]) / 3
        return [(val / 255) * 100]
      }

      /***/
    },

    /***/ 303: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      var conversions = __nccwpck_require__(8686)
      var route = __nccwpck_require__(2583)

      var convert = {}

      var models = Object.keys(conversions)

      function wrapRaw(fn) {
        var wrappedFn = function (args) {
          if (args === undefined || args === null) {
            return args
          }

          if (arguments.length > 1) {
            args = Array.prototype.slice.call(arguments)
          }

          return fn(args)
        }

        // preserve .conversion property if there is one
        if ('conversion' in fn) {
          wrappedFn.conversion = fn.conversion
        }

        return wrappedFn
      }

      function wrapRounded(fn) {
        var wrappedFn = function (args) {
          if (args === undefined || args === null) {
            return args
          }

          if (arguments.length > 1) {
            args = Array.prototype.slice.call(arguments)
          }

          var result = fn(args)

          // we're assuming the result is an array here.
          // see notice in conversions.js; don't use box types
          // in conversion functions.
          if (typeof result === 'object') {
            for (var len = result.length, i = 0; i < len; i++) {
              result[i] = Math.round(result[i])
            }
          }

          return result
        }

        // preserve .conversion property if there is one
        if ('conversion' in fn) {
          wrappedFn.conversion = fn.conversion
        }

        return wrappedFn
      }

      models.forEach(function (fromModel) {
        convert[fromModel] = {}

        Object.defineProperty(convert[fromModel], 'channels', {
          value: conversions[fromModel].channels,
        })
        Object.defineProperty(convert[fromModel], 'labels', {
          value: conversions[fromModel].labels,
        })

        var routes = route(fromModel)
        var routeModels = Object.keys(routes)

        routeModels.forEach(function (toModel) {
          var fn = routes[toModel]

          convert[fromModel][toModel] = wrapRounded(fn)
          convert[fromModel][toModel].raw = wrapRaw(fn)
        })
      })

      module.exports = convert

      /***/
    },

    /***/ 2583: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      var conversions = __nccwpck_require__(8686)

      /*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

      function buildGraph() {
        var graph = {}
        // https://jsperf.com/object-keys-vs-for-in-with-closure/3
        var models = Object.keys(conversions)

        for (var len = models.length, i = 0; i < len; i++) {
          graph[models[i]] = {
            // http://jsperf.com/1-vs-infinity
            // micro-opt, but this is simple.
            distance: -1,
            parent: null,
          }
        }

        return graph
      }

      // https://en.wikipedia.org/wiki/Breadth-first_search
      function deriveBFS(fromModel) {
        var graph = buildGraph()
        var queue = [fromModel] // unshift -> queue -> pop

        graph[fromModel].distance = 0

        while (queue.length) {
          var current = queue.pop()
          var adjacents = Object.keys(conversions[current])

          for (var len = adjacents.length, i = 0; i < len; i++) {
            var adjacent = adjacents[i]
            var node = graph[adjacent]

            if (node.distance === -1) {
              node.distance = graph[current].distance + 1
              node.parent = current
              queue.unshift(adjacent)
            }
          }
        }

        return graph
      }

      function link(from, to) {
        return function (args) {
          return to(from(args))
        }
      }

      function wrapConversion(toModel, graph) {
        var path = [graph[toModel].parent, toModel]
        var fn = conversions[graph[toModel].parent][toModel]

        var cur = graph[toModel].parent
        while (graph[cur].parent) {
          path.unshift(graph[cur].parent)
          fn = link(conversions[graph[cur].parent][cur], fn)
          cur = graph[cur].parent
        }

        fn.conversion = path
        return fn
      }

      module.exports = function (fromModel) {
        var graph = deriveBFS(fromModel)
        var conversion = {}

        var models = Object.keys(graph)
        for (var len = models.length, i = 0; i < len; i++) {
          var toModel = models[i]
          var node = graph[toModel]

          if (node.parent === null) {
            // no possible conversion, or this node is the source model.
            continue
          }

          conversion[toModel] = wrapConversion(toModel, graph)
        }

        return conversion
      }

      /***/
    },

    /***/ 3843: /***/ module => {
      'use strict'

      module.exports = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50],
      }

      /***/
    },

    /***/ 9589: /***/ module => {
      'use strict'

      module.exports = (flag, argv) => {
        argv = argv || process.argv
        const prefix = flag.startsWith('-')
          ? ''
          : flag.length === 1
          ? '-'
          : '--'
        const pos = argv.indexOf(prefix + flag)
        const terminatorPos = argv.indexOf('--')
        return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos)
      }

      /***/
    },

    /***/ 944: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const os = __nccwpck_require__(2037)
      const hasFlag = __nccwpck_require__(9589)

      const env = process.env

      let forceColor
      if (
        hasFlag('no-color') ||
        hasFlag('no-colors') ||
        hasFlag('color=false')
      ) {
        forceColor = false
      } else if (
        hasFlag('color') ||
        hasFlag('colors') ||
        hasFlag('color=true') ||
        hasFlag('color=always')
      ) {
        forceColor = true
      }
      if ('FORCE_COLOR' in env) {
        forceColor =
          env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0
      }

      function translateLevel(level) {
        if (level === 0) {
          return false
        }

        return {
          level,
          hasBasic: true,
          has256: level >= 2,
          has16m: level >= 3,
        }
      }

      function supportsColor(stream) {
        if (forceColor === false) {
          return 0
        }

        if (
          hasFlag('color=16m') ||
          hasFlag('color=full') ||
          hasFlag('color=truecolor')
        ) {
          return 3
        }

        if (hasFlag('color=256')) {
          return 2
        }

        if (stream && !stream.isTTY && forceColor !== true) {
          return 0
        }

        const min = forceColor ? 1 : 0

        if (process.platform === 'win32') {
          // Node.js 7.5.0 is the first version of Node.js to include a patch to
          // libuv that enables 256 color output on Windows. Anything earlier and it
          // won't work. However, here we target Node.js 8 at minimum as it is an LTS
          // release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
          // release that supports 256 colors. Windows 10 build 14931 is the first release
          // that supports 16m/TrueColor.
          const osRelease = os.release().split('.')
          if (
            Number(process.versions.node.split('.')[0]) >= 8 &&
            Number(osRelease[0]) >= 10 &&
            Number(osRelease[2]) >= 10586
          ) {
            return Number(osRelease[2]) >= 14931 ? 3 : 2
          }

          return 1
        }

        if ('CI' in env) {
          if (
            ['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(
              sign => sign in env
            ) ||
            env.CI_NAME === 'codeship'
          ) {
            return 1
          }

          return min
        }

        if ('TEAMCITY_VERSION' in env) {
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION)
            ? 1
            : 0
        }

        if (env.COLORTERM === 'truecolor') {
          return 3
        }

        if ('TERM_PROGRAM' in env) {
          const version = parseInt(
            (env.TERM_PROGRAM_VERSION || '').split('.')[0],
            10
          )

          switch (env.TERM_PROGRAM) {
            case 'iTerm.app':
              return version >= 3 ? 3 : 2
            case 'Apple_Terminal':
              return 2
            // No default
          }
        }

        if (/-256(color)?$/i.test(env.TERM)) {
          return 2
        }

        if (
          /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(
            env.TERM
          )
        ) {
          return 1
        }

        if ('COLORTERM' in env) {
          return 1
        }

        if (env.TERM === 'dumb') {
          return min
        }

        return min
      }

      function getSupportLevel(stream) {
        const level = supportsColor(stream)
        return translateLevel(level)
      }

      module.exports = {
        supportsColor: getSupportLevel,
        stdout: getSupportLevel(process.stdout),
        stderr: getSupportLevel(process.stderr),
      }

      /***/
    },

    /***/ 5473: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })

      function _interopDefault(ex) {
        return ex && typeof ex === 'object' && 'default' in ex
          ? ex['default']
          : ex
      }

      var _regeneratorRuntime = _interopDefault(__nccwpck_require__(2521))
      var _asyncToGenerator = _interopDefault(__nccwpck_require__(9745))
      var _classCallCheck = _interopDefault(__nccwpck_require__(7661))
      var _possibleConstructorReturn = _interopDefault(
        __nccwpck_require__(4277)
      )
      var _getPrototypeOf = _interopDefault(__nccwpck_require__(9041))
      var _inherits = _interopDefault(__nccwpck_require__(5549))
      var _wrapNativeSuper = _interopDefault(__nccwpck_require__(7174))
      var findUp = __nccwpck_require__(9486)
      var findUp__default = _interopDefault(findUp)
      var path = _interopDefault(__nccwpck_require__(1017))
      var fs = _interopDefault(__nccwpck_require__(4586))

      var NoPkgJsonFound =
        /*#__PURE__*/
        (function (_Error) {
          _inherits(NoPkgJsonFound, _Error)

          function NoPkgJsonFound(directory) {
            var _this

            _classCallCheck(this, NoPkgJsonFound)

            _this = _possibleConstructorReturn(
              this,
              _getPrototypeOf(NoPkgJsonFound).call(
                this,
                'No package.json could be found upwards from the directory '.concat(
                  directory
                )
              )
            )
            _this.directory = directory
            return _this
          }

          return NoPkgJsonFound
        })(_wrapNativeSuper(Error))

      function hasWorkspacesConfiguredViaPkgJson(_x, _x2) {
        return _hasWorkspacesConfiguredViaPkgJson.apply(this, arguments)
      }

      function _hasWorkspacesConfiguredViaPkgJson() {
        _hasWorkspacesConfiguredViaPkgJson = _asyncToGenerator(
          /*#__PURE__*/
          _regeneratorRuntime.mark(function _callee(
            directory,
            firstPkgJsonDirRef
          ) {
            var pkgJson
            return _regeneratorRuntime.wrap(
              function _callee$(_context) {
                while (1) {
                  switch ((_context.prev = _context.next)) {
                    case 0:
                      _context.prev = 0
                      _context.next = 3
                      return fs.readJson(path.join(directory, 'package.json'))

                    case 3:
                      pkgJson = _context.sent

                      if (firstPkgJsonDirRef.current === undefined) {
                        firstPkgJsonDirRef.current = directory
                      }

                      if (!(pkgJson.workspaces || pkgJson.bolt)) {
                        _context.next = 7
                        break
                      }

                      return _context.abrupt('return', directory)

                    case 7:
                      _context.next = 13
                      break

                    case 9:
                      _context.prev = 9
                      _context.t0 = _context['catch'](0)

                      if (!(_context.t0.code !== 'ENOENT')) {
                        _context.next = 13
                        break
                      }

                      throw _context.t0

                    case 13:
                    case 'end':
                      return _context.stop()
                  }
                }
              },
              _callee,
              null,
              [[0, 9]]
            )
          })
        )
        return _hasWorkspacesConfiguredViaPkgJson.apply(this, arguments)
      }

      function hasWorkspacesConfiguredViaLerna(_x3) {
        return _hasWorkspacesConfiguredViaLerna.apply(this, arguments)
      }

      function _hasWorkspacesConfiguredViaLerna() {
        _hasWorkspacesConfiguredViaLerna = _asyncToGenerator(
          /*#__PURE__*/
          _regeneratorRuntime.mark(function _callee2(directory) {
            var lernaJson
            return _regeneratorRuntime.wrap(
              function _callee2$(_context2) {
                while (1) {
                  switch ((_context2.prev = _context2.next)) {
                    case 0:
                      _context2.prev = 0
                      _context2.next = 3
                      return fs.readJson(path.join(directory, 'lerna.json'))

                    case 3:
                      lernaJson = _context2.sent

                      if (!(lernaJson.useWorkspaces !== true)) {
                        _context2.next = 6
                        break
                      }

                      return _context2.abrupt('return', directory)

                    case 6:
                      _context2.next = 12
                      break

                    case 8:
                      _context2.prev = 8
                      _context2.t0 = _context2['catch'](0)

                      if (!(_context2.t0.code !== 'ENOENT')) {
                        _context2.next = 12
                        break
                      }

                      throw _context2.t0

                    case 12:
                    case 'end':
                      return _context2.stop()
                  }
                }
              },
              _callee2,
              null,
              [[0, 8]]
            )
          })
        )
        return _hasWorkspacesConfiguredViaLerna.apply(this, arguments)
      }

      function hasWorkspacesConfiguredViaPnpm(_x4) {
        return _hasWorkspacesConfiguredViaPnpm.apply(this, arguments)
      }

      function _hasWorkspacesConfiguredViaPnpm() {
        _hasWorkspacesConfiguredViaPnpm = _asyncToGenerator(
          /*#__PURE__*/
          _regeneratorRuntime.mark(function _callee3(directory) {
            var pnpmWorkspacesFileExists
            return _regeneratorRuntime.wrap(function _callee3$(_context3) {
              while (1) {
                switch ((_context3.prev = _context3.next)) {
                  case 0:
                    _context3.next = 2
                    return fs.exists(
                      path.join(directory, 'pnpm-workspace.yaml')
                    )

                  case 2:
                    pnpmWorkspacesFileExists = _context3.sent

                    if (!pnpmWorkspacesFileExists) {
                      _context3.next = 5
                      break
                    }

                    return _context3.abrupt('return', directory)

                  case 5:
                  case 'end':
                    return _context3.stop()
                }
              }
            }, _callee3)
          })
        )
        return _hasWorkspacesConfiguredViaPnpm.apply(this, arguments)
      }

      function findRoot(_x5) {
        return _findRoot.apply(this, arguments)
      }

      function _findRoot() {
        _findRoot = _asyncToGenerator(
          /*#__PURE__*/
          _regeneratorRuntime.mark(function _callee4(cwd) {
            var firstPkgJsonDirRef, dir
            return _regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch ((_context4.prev = _context4.next)) {
                  case 0:
                    firstPkgJsonDirRef = {
                      current: undefined,
                    }
                    _context4.next = 3
                    return findUp__default(
                      function (directory) {
                        return Promise.all([
                          hasWorkspacesConfiguredViaLerna(directory),
                          hasWorkspacesConfiguredViaPkgJson(
                            directory,
                            firstPkgJsonDirRef
                          ),
                          hasWorkspacesConfiguredViaPnpm(directory),
                        ]).then(function (x) {
                          return x.find(function (dir) {
                            return dir
                          })
                        })
                      },
                      {
                        cwd: cwd,
                        type: 'directory',
                      }
                    )

                  case 3:
                    dir = _context4.sent

                    if (!(firstPkgJsonDirRef.current === undefined)) {
                      _context4.next = 6
                      break
                    }

                    throw new NoPkgJsonFound(cwd)

                  case 6:
                    if (!(dir === undefined)) {
                      _context4.next = 8
                      break
                    }

                    return _context4.abrupt(
                      'return',
                      firstPkgJsonDirRef.current
                    )

                  case 8:
                    return _context4.abrupt('return', dir)

                  case 9:
                  case 'end':
                    return _context4.stop()
                }
              }
            }, _callee4)
          })
        )
        return _findRoot.apply(this, arguments)
      }

      function hasWorkspacesConfiguredViaPkgJsonSync(
        directory,
        firstPkgJsonDirRef
      ) {
        try {
          var pkgJson = fs.readJsonSync(path.join(directory, 'package.json'))

          if (firstPkgJsonDirRef.current === undefined) {
            firstPkgJsonDirRef.current = directory
          }

          if (pkgJson.workspaces || pkgJson.bolt) {
            return directory
          }
        } catch (err) {
          if (err.code !== 'ENOENT') {
            throw err
          }
        }
      }

      function hasWorkspacesConfiguredViaLernaSync(directory) {
        try {
          var lernaJson = fs.readJsonSync(path.join(directory, 'lerna.json'))

          if (lernaJson.useWorkspaces !== true) {
            return directory
          }
        } catch (err) {
          if (err.code !== 'ENOENT') {
            throw err
          }
        }
      }

      function hasWorkspacesConfiguredViaPnpmSync(directory) {
        // @ts-ignore
        var pnpmWorkspacesFileExists = fs.existsSync(
          path.join(directory, 'pnpm-workspace.yaml')
        )

        if (pnpmWorkspacesFileExists) {
          return directory
        }
      }

      function findRootSync(cwd) {
        var firstPkgJsonDirRef = {
          current: undefined,
        }
        var dir = findUp.sync(
          function (directory) {
            return [
              hasWorkspacesConfiguredViaLernaSync(directory),
              hasWorkspacesConfiguredViaPkgJsonSync(
                directory,
                firstPkgJsonDirRef
              ),
              hasWorkspacesConfiguredViaPnpmSync(directory),
            ].find(function (dir) {
              return dir
            })
          },
          {
            cwd: cwd,
            type: 'directory',
          }
        )

        if (firstPkgJsonDirRef.current === undefined) {
          throw new NoPkgJsonFound(cwd)
        }

        if (dir === undefined) {
          return firstPkgJsonDirRef.current
        }

        return dir
      }

      exports.NoPkgJsonFound = NoPkgJsonFound
      exports.findRoot = findRoot
      exports.findRootSync = findRootSync

      /***/
    },

    /***/ 8482: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      if (process.env.NODE_ENV === 'production') {
        module.exports = __nccwpck_require__(6665)
      } else {
        module.exports = __nccwpck_require__(5473)
      }

      /***/
    },

    /***/ 6665: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      function _interopDefault(ex) {
        return ex && 'object' == typeof ex && 'default' in ex ? ex.default : ex
      }

      Object.defineProperty(exports, '__esModule', {
        value: !0,
      })

      var _regeneratorRuntime = _interopDefault(__nccwpck_require__(2521)),
        _asyncToGenerator = _interopDefault(__nccwpck_require__(9745)),
        _classCallCheck = _interopDefault(__nccwpck_require__(7661)),
        _possibleConstructorReturn = _interopDefault(__nccwpck_require__(4277)),
        _getPrototypeOf = _interopDefault(__nccwpck_require__(9041)),
        _inherits = _interopDefault(__nccwpck_require__(5549)),
        _wrapNativeSuper = _interopDefault(__nccwpck_require__(7174)),
        findUp = __nccwpck_require__(9486),
        findUp__default = _interopDefault(findUp),
        path = _interopDefault(__nccwpck_require__(1017)),
        fs = _interopDefault(__nccwpck_require__(4586)),
        NoPkgJsonFound = (function (_Error) {
          function NoPkgJsonFound(directory) {
            var _this
            return (
              _classCallCheck(this, NoPkgJsonFound),
              ((_this = _possibleConstructorReturn(
                this,
                _getPrototypeOf(NoPkgJsonFound).call(
                  this,
                  'No package.json could be found upwards from the directory '.concat(
                    directory
                  )
                )
              )).directory = directory),
              _this
            )
          }
          return _inherits(NoPkgJsonFound, _Error), NoPkgJsonFound
        })(_wrapNativeSuper(Error))

      function hasWorkspacesConfiguredViaPkgJson(_x, _x2) {
        return _hasWorkspacesConfiguredViaPkgJson.apply(this, arguments)
      }

      function _hasWorkspacesConfiguredViaPkgJson() {
        return (_hasWorkspacesConfiguredViaPkgJson = _asyncToGenerator(
          _regeneratorRuntime.mark(function _callee(
            directory,
            firstPkgJsonDirRef
          ) {
            var pkgJson
            return _regeneratorRuntime.wrap(
              function (_context) {
                for (;;)
                  switch ((_context.prev = _context.next)) {
                    case 0:
                      return (
                        (_context.prev = 0),
                        (_context.next = 3),
                        fs.readJson(path.join(directory, 'package.json'))
                      )

                    case 3:
                      if (
                        ((pkgJson = _context.sent),
                        void 0 === firstPkgJsonDirRef.current &&
                          (firstPkgJsonDirRef.current = directory),
                        !pkgJson.workspaces && !pkgJson.bolt)
                      ) {
                        _context.next = 7
                        break
                      }
                      return _context.abrupt('return', directory)

                    case 7:
                      _context.next = 13
                      break

                    case 9:
                      if (
                        ((_context.prev = 9),
                        (_context.t0 = _context.catch(0)),
                        'ENOENT' === _context.t0.code)
                      ) {
                        _context.next = 13
                        break
                      }
                      throw _context.t0

                    case 13:
                    case 'end':
                      return _context.stop()
                  }
              },
              _callee,
              null,
              [[0, 9]]
            )
          })
        )).apply(this, arguments)
      }

      function hasWorkspacesConfiguredViaLerna(_x3) {
        return _hasWorkspacesConfiguredViaLerna.apply(this, arguments)
      }

      function _hasWorkspacesConfiguredViaLerna() {
        return (_hasWorkspacesConfiguredViaLerna = _asyncToGenerator(
          _regeneratorRuntime.mark(function _callee2(directory) {
            return _regeneratorRuntime.wrap(
              function (_context2) {
                for (;;)
                  switch ((_context2.prev = _context2.next)) {
                    case 0:
                      return (
                        (_context2.prev = 0),
                        (_context2.next = 3),
                        fs.readJson(path.join(directory, 'lerna.json'))
                      )

                    case 3:
                      if (!0 === _context2.sent.useWorkspaces) {
                        _context2.next = 6
                        break
                      }
                      return _context2.abrupt('return', directory)

                    case 6:
                      _context2.next = 12
                      break

                    case 8:
                      if (
                        ((_context2.prev = 8),
                        (_context2.t0 = _context2.catch(0)),
                        'ENOENT' === _context2.t0.code)
                      ) {
                        _context2.next = 12
                        break
                      }
                      throw _context2.t0

                    case 12:
                    case 'end':
                      return _context2.stop()
                  }
              },
              _callee2,
              null,
              [[0, 8]]
            )
          })
        )).apply(this, arguments)
      }

      function hasWorkspacesConfiguredViaPnpm(_x4) {
        return _hasWorkspacesConfiguredViaPnpm.apply(this, arguments)
      }

      function _hasWorkspacesConfiguredViaPnpm() {
        return (_hasWorkspacesConfiguredViaPnpm = _asyncToGenerator(
          _regeneratorRuntime.mark(function _callee3(directory) {
            return _regeneratorRuntime.wrap(function (_context3) {
              for (;;)
                switch ((_context3.prev = _context3.next)) {
                  case 0:
                    return (
                      (_context3.next = 2),
                      fs.exists(path.join(directory, 'pnpm-workspace.yaml'))
                    )

                  case 2:
                    if (!_context3.sent) {
                      _context3.next = 5
                      break
                    }
                    return _context3.abrupt('return', directory)

                  case 5:
                  case 'end':
                    return _context3.stop()
                }
            }, _callee3)
          })
        )).apply(this, arguments)
      }

      function findRoot(_x5) {
        return _findRoot.apply(this, arguments)
      }

      function _findRoot() {
        return (_findRoot = _asyncToGenerator(
          _regeneratorRuntime.mark(function _callee4(cwd) {
            var firstPkgJsonDirRef, dir
            return _regeneratorRuntime.wrap(function (_context4) {
              for (;;)
                switch ((_context4.prev = _context4.next)) {
                  case 0:
                    return (
                      (firstPkgJsonDirRef = {
                        current: void 0,
                      }),
                      (_context4.next = 3),
                      findUp__default(
                        function (directory) {
                          return Promise.all([
                            hasWorkspacesConfiguredViaLerna(directory),
                            hasWorkspacesConfiguredViaPkgJson(
                              directory,
                              firstPkgJsonDirRef
                            ),
                            hasWorkspacesConfiguredViaPnpm(directory),
                          ]).then(function (x) {
                            return x.find(function (dir) {
                              return dir
                            })
                          })
                        },
                        {
                          cwd: cwd,
                          type: 'directory',
                        }
                      )
                    )

                  case 3:
                    if (
                      ((dir = _context4.sent),
                      void 0 !== firstPkgJsonDirRef.current)
                    ) {
                      _context4.next = 6
                      break
                    }
                    throw new NoPkgJsonFound(cwd)

                  case 6:
                    if (void 0 !== dir) {
                      _context4.next = 8
                      break
                    }
                    return _context4.abrupt(
                      'return',
                      firstPkgJsonDirRef.current
                    )

                  case 8:
                    return _context4.abrupt('return', dir)

                  case 9:
                  case 'end':
                    return _context4.stop()
                }
            }, _callee4)
          })
        )).apply(this, arguments)
      }

      function hasWorkspacesConfiguredViaPkgJsonSync(
        directory,
        firstPkgJsonDirRef
      ) {
        try {
          var pkgJson = fs.readJsonSync(path.join(directory, 'package.json'))
          if (
            (void 0 === firstPkgJsonDirRef.current &&
              (firstPkgJsonDirRef.current = directory),
            pkgJson.workspaces || pkgJson.bolt)
          )
            return directory
        } catch (err) {
          if ('ENOENT' !== err.code) throw err
        }
      }

      function hasWorkspacesConfiguredViaLernaSync(directory) {
        try {
          if (
            !0 !==
            fs.readJsonSync(path.join(directory, 'lerna.json')).useWorkspaces
          )
            return directory
        } catch (err) {
          if ('ENOENT' !== err.code) throw err
        }
      }

      function hasWorkspacesConfiguredViaPnpmSync(directory) {
        if (fs.existsSync(path.join(directory, 'pnpm-workspace.yaml')))
          return directory
      }

      function findRootSync(cwd) {
        var firstPkgJsonDirRef = {
            current: void 0,
          },
          dir = findUp.sync(
            function (directory) {
              return [
                hasWorkspacesConfiguredViaLernaSync(directory),
                hasWorkspacesConfiguredViaPkgJsonSync(
                  directory,
                  firstPkgJsonDirRef
                ),
                hasWorkspacesConfiguredViaPnpmSync(directory),
              ].find(function (dir) {
                return dir
              })
            },
            {
              cwd: cwd,
              type: 'directory',
            }
          )
        if (void 0 === firstPkgJsonDirRef.current) throw new NoPkgJsonFound(cwd)
        return void 0 === dir ? firstPkgJsonDirRef.current : dir
      }

      ;(exports.NoPkgJsonFound = NoPkgJsonFound),
        (exports.findRoot = findRoot),
        (exports.findRootSync = findRootSync)

      /***/
    },

    /***/ 3825: /***/ module => {
      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          )
        }

        return self
      }

      ;(module.exports = _assertThisInitialized),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 9745: /***/ module => {
      function asyncGeneratorStep(
        gen,
        resolve,
        reject,
        _next,
        _throw,
        key,
        arg
      ) {
        try {
          var info = gen[key](arg)
          var value = info.value
        } catch (error) {
          reject(error)
          return
        }

        if (info.done) {
          resolve(value)
        } else {
          Promise.resolve(value).then(_next, _throw)
        }
      }

      function _asyncToGenerator(fn) {
        return function () {
          var self = this,
            args = arguments
          return new Promise(function (resolve, reject) {
            var gen = fn.apply(self, args)

            function _next(value) {
              asyncGeneratorStep(
                gen,
                resolve,
                reject,
                _next,
                _throw,
                'next',
                value
              )
            }

            function _throw(err) {
              asyncGeneratorStep(
                gen,
                resolve,
                reject,
                _next,
                _throw,
                'throw',
                err
              )
            }

            _next(undefined)
          })
        }
      }

      ;(module.exports = _asyncToGenerator),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 7661: /***/ module => {
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError('Cannot call a class as a function')
        }
      }

      ;(module.exports = _classCallCheck),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 4522: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      var setPrototypeOf = __nccwpck_require__(9411)

      var isNativeReflectConstruct = __nccwpck_require__(2863)

      function _construct(Parent, args, Class) {
        if (isNativeReflectConstruct()) {
          ;(module.exports = _construct = Reflect.construct),
            (module.exports.__esModule = true),
            (module.exports['default'] = module.exports)
        } else {
          ;(module.exports = _construct =
            function _construct(Parent, args, Class) {
              var a = [null]
              a.push.apply(a, args)
              var Constructor = Function.bind.apply(Parent, a)
              var instance = new Constructor()
              if (Class) setPrototypeOf(instance, Class.prototype)
              return instance
            }),
            (module.exports.__esModule = true),
            (module.exports['default'] = module.exports)
        }

        return _construct.apply(null, arguments)
      }

      ;(module.exports = _construct),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 9041: /***/ module => {
      function _getPrototypeOf(o) {
        ;(module.exports = _getPrototypeOf =
          Object.setPrototypeOf
            ? Object.getPrototypeOf
            : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o)
              }),
          (module.exports.__esModule = true),
          (module.exports['default'] = module.exports)
        return _getPrototypeOf(o)
      }

      ;(module.exports = _getPrototypeOf),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 5549: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      var setPrototypeOf = __nccwpck_require__(9411)

      function _inherits(subClass, superClass) {
        if (typeof superClass !== 'function' && superClass !== null) {
          throw new TypeError(
            'Super expression must either be null or a function'
          )
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true,
          },
        })
        Object.defineProperty(subClass, 'prototype', {
          writable: false,
        })
        if (superClass) setPrototypeOf(subClass, superClass)
      }

      ;(module.exports = _inherits),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 3553: /***/ module => {
      function _isNativeFunction(fn) {
        return Function.toString.call(fn).indexOf('[native code]') !== -1
      }

      ;(module.exports = _isNativeFunction),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 2863: /***/ module => {
      function _isNativeReflectConstruct() {
        if (typeof Reflect === 'undefined' || !Reflect.construct) return false
        if (Reflect.construct.sham) return false
        if (typeof Proxy === 'function') return true

        try {
          Boolean.prototype.valueOf.call(
            Reflect.construct(Boolean, [], function () {})
          )
          return true
        } catch (e) {
          return false
        }
      }

      ;(module.exports = _isNativeReflectConstruct),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 4277: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      var _typeof = __nccwpck_require__(6537)['default']

      var assertThisInitialized = __nccwpck_require__(3825)

      function _possibleConstructorReturn(self, call) {
        if (
          call &&
          (_typeof(call) === 'object' || typeof call === 'function')
        ) {
          return call
        } else if (call !== void 0) {
          throw new TypeError(
            'Derived constructors may only return object or undefined'
          )
        }

        return assertThisInitialized(self)
      }

      ;(module.exports = _possibleConstructorReturn),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 9411: /***/ module => {
      function _setPrototypeOf(o, p) {
        ;(module.exports = _setPrototypeOf =
          Object.setPrototypeOf ||
          function _setPrototypeOf(o, p) {
            o.__proto__ = p
            return o
          }),
          (module.exports.__esModule = true),
          (module.exports['default'] = module.exports)
        return _setPrototypeOf(o, p)
      }

      ;(module.exports = _setPrototypeOf),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 6537: /***/ module => {
      function _typeof(obj) {
        '@babel/helpers - typeof'

        return (
          ((module.exports = _typeof =
            'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
              ? function (obj) {
                  return typeof obj
                }
              : function (obj) {
                  return obj &&
                    'function' == typeof Symbol &&
                    obj.constructor === Symbol &&
                    obj !== Symbol.prototype
                    ? 'symbol'
                    : typeof obj
                }),
          (module.exports.__esModule = true),
          (module.exports['default'] = module.exports)),
          _typeof(obj)
        )
      }

      ;(module.exports = _typeof),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 7174: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      var getPrototypeOf = __nccwpck_require__(9041)

      var setPrototypeOf = __nccwpck_require__(9411)

      var isNativeFunction = __nccwpck_require__(3553)

      var construct = __nccwpck_require__(4522)

      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === 'function' ? new Map() : undefined

        ;(module.exports = _wrapNativeSuper =
          function _wrapNativeSuper(Class) {
            if (Class === null || !isNativeFunction(Class)) return Class

            if (typeof Class !== 'function') {
              throw new TypeError(
                'Super expression must either be null or a function'
              )
            }

            if (typeof _cache !== 'undefined') {
              if (_cache.has(Class)) return _cache.get(Class)

              _cache.set(Class, Wrapper)
            }

            function Wrapper() {
              return construct(
                Class,
                arguments,
                getPrototypeOf(this).constructor
              )
            }

            Wrapper.prototype = Object.create(Class.prototype, {
              constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true,
              },
            })
            return setPrototypeOf(Wrapper, Class)
          }),
          (module.exports.__esModule = true),
          (module.exports['default'] = module.exports)
        return _wrapNativeSuper(Class)
      }

      ;(module.exports = _wrapNativeSuper),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 2521: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      module.exports = __nccwpck_require__(4307)

      /***/
    },

    /***/ 3703: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const mkdirpSync = __nccwpck_require__(3264).mkdirsSync
      const utimesSync = __nccwpck_require__(5026).utimesMillisSync
      const stat = __nccwpck_require__(2022)

      function copySync(src, dest, opts) {
        if (typeof opts === 'function') {
          opts = { filter: opts }
        }

        opts = opts || {}
        opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now
        opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber

        // Warn about using preserveTimestamps on 32-bit node
        if (opts.preserveTimestamps && process.arch === 'ia32') {
          console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`)
        }

        const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy')
        stat.checkParentPathsSync(src, srcStat, dest, 'copy')
        return handleFilterAndCopy(destStat, src, dest, opts)
      }

      function handleFilterAndCopy(destStat, src, dest, opts) {
        if (opts.filter && !opts.filter(src, dest)) return
        const destParent = path.dirname(dest)
        if (!fs.existsSync(destParent)) mkdirpSync(destParent)
        return startCopy(destStat, src, dest, opts)
      }

      function startCopy(destStat, src, dest, opts) {
        if (opts.filter && !opts.filter(src, dest)) return
        return getStats(destStat, src, dest, opts)
      }

      function getStats(destStat, src, dest, opts) {
        const statSync = opts.dereference ? fs.statSync : fs.lstatSync
        const srcStat = statSync(src)

        if (srcStat.isDirectory())
          return onDir(srcStat, destStat, src, dest, opts)
        else if (
          srcStat.isFile() ||
          srcStat.isCharacterDevice() ||
          srcStat.isBlockDevice()
        )
          return onFile(srcStat, destStat, src, dest, opts)
        else if (srcStat.isSymbolicLink())
          return onLink(destStat, src, dest, opts)
      }

      function onFile(srcStat, destStat, src, dest, opts) {
        if (!destStat) return copyFile(srcStat, src, dest, opts)
        return mayCopyFile(srcStat, src, dest, opts)
      }

      function mayCopyFile(srcStat, src, dest, opts) {
        if (opts.overwrite) {
          fs.unlinkSync(dest)
          return copyFile(srcStat, src, dest, opts)
        } else if (opts.errorOnExist) {
          throw new Error(`'${dest}' already exists`)
        }
      }

      function copyFile(srcStat, src, dest, opts) {
        if (typeof fs.copyFileSync === 'function') {
          fs.copyFileSync(src, dest)
          fs.chmodSync(dest, srcStat.mode)
          if (opts.preserveTimestamps) {
            return utimesSync(dest, srcStat.atime, srcStat.mtime)
          }
          return
        }
        return copyFileFallback(srcStat, src, dest, opts)
      }

      function copyFileFallback(srcStat, src, dest, opts) {
        const BUF_LENGTH = 64 * 1024
        const _buff = __nccwpck_require__(3502)(BUF_LENGTH)

        const fdr = fs.openSync(src, 'r')
        const fdw = fs.openSync(dest, 'w', srcStat.mode)
        let pos = 0

        while (pos < srcStat.size) {
          const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)
          fs.writeSync(fdw, _buff, 0, bytesRead)
          pos += bytesRead
        }

        if (opts.preserveTimestamps)
          fs.futimesSync(fdw, srcStat.atime, srcStat.mtime)

        fs.closeSync(fdr)
        fs.closeSync(fdw)
      }

      function onDir(srcStat, destStat, src, dest, opts) {
        if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts)
        if (destStat && !destStat.isDirectory()) {
          throw new Error(
            `Cannot overwrite non-directory '${dest}' with directory '${src}'.`
          )
        }
        return copyDir(src, dest, opts)
      }

      function mkDirAndCopy(srcStat, src, dest, opts) {
        fs.mkdirSync(dest)
        copyDir(src, dest, opts)
        return fs.chmodSync(dest, srcStat.mode)
      }

      function copyDir(src, dest, opts) {
        fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))
      }

      function copyDirItem(item, src, dest, opts) {
        const srcItem = path.join(src, item)
        const destItem = path.join(dest, item)
        const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy')
        return startCopy(destStat, srcItem, destItem, opts)
      }

      function onLink(destStat, src, dest, opts) {
        let resolvedSrc = fs.readlinkSync(src)
        if (opts.dereference) {
          resolvedSrc = path.resolve(process.cwd(), resolvedSrc)
        }

        if (!destStat) {
          return fs.symlinkSync(resolvedSrc, dest)
        } else {
          let resolvedDest
          try {
            resolvedDest = fs.readlinkSync(dest)
          } catch (err) {
            // dest exists and is a regular file or directory,
            // Windows may throw UNKNOWN error. If dest already exists,
            // fs throws error anyway, so no need to guard against it here.
            if (err.code === 'EINVAL' || err.code === 'UNKNOWN')
              return fs.symlinkSync(resolvedSrc, dest)
            throw err
          }
          if (opts.dereference) {
            resolvedDest = path.resolve(process.cwd(), resolvedDest)
          }
          if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
            throw new Error(
              `Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`
            )
          }

          // prevent copy if src is a subdir of dest since unlinking
          // dest in this case would result in removing src contents
          // and therefore a broken symlink would be created.
          if (
            fs.statSync(dest).isDirectory() &&
            stat.isSrcSubdir(resolvedDest, resolvedSrc)
          ) {
            throw new Error(
              `Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`
            )
          }
          return copyLink(resolvedSrc, dest)
        }
      }

      function copyLink(resolvedSrc, dest) {
        fs.unlinkSync(dest)
        return fs.symlinkSync(resolvedSrc, dest)
      }

      module.exports = copySync

      /***/
    },

    /***/ 5552: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      module.exports = {
        copySync: __nccwpck_require__(3703),
      }

      /***/
    },

    /***/ 7350: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const mkdirp = __nccwpck_require__(3264).mkdirs
      const pathExists = __nccwpck_require__(1256).pathExists
      const utimes = __nccwpck_require__(5026).utimesMillis
      const stat = __nccwpck_require__(2022)

      function copy(src, dest, opts, cb) {
        if (typeof opts === 'function' && !cb) {
          cb = opts
          opts = {}
        } else if (typeof opts === 'function') {
          opts = { filter: opts }
        }

        cb = cb || function () {}
        opts = opts || {}

        opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now
        opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber

        // Warn about using preserveTimestamps on 32-bit node
        if (opts.preserveTimestamps && process.arch === 'ia32') {
          console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`)
        }

        stat.checkPaths(src, dest, 'copy', (err, stats) => {
          if (err) return cb(err)
          const { srcStat, destStat } = stats
          stat.checkParentPaths(src, srcStat, dest, 'copy', err => {
            if (err) return cb(err)
            if (opts.filter)
              return handleFilter(checkParentDir, destStat, src, dest, opts, cb)
            return checkParentDir(destStat, src, dest, opts, cb)
          })
        })
      }

      function checkParentDir(destStat, src, dest, opts, cb) {
        const destParent = path.dirname(dest)
        pathExists(destParent, (err, dirExists) => {
          if (err) return cb(err)
          if (dirExists) return startCopy(destStat, src, dest, opts, cb)
          mkdirp(destParent, err => {
            if (err) return cb(err)
            return startCopy(destStat, src, dest, opts, cb)
          })
        })
      }

      function handleFilter(onInclude, destStat, src, dest, opts, cb) {
        Promise.resolve(opts.filter(src, dest)).then(
          include => {
            if (include) return onInclude(destStat, src, dest, opts, cb)
            return cb()
          },
          error => cb(error)
        )
      }

      function startCopy(destStat, src, dest, opts, cb) {
        if (opts.filter)
          return handleFilter(getStats, destStat, src, dest, opts, cb)
        return getStats(destStat, src, dest, opts, cb)
      }

      function getStats(destStat, src, dest, opts, cb) {
        const stat = opts.dereference ? fs.stat : fs.lstat
        stat(src, (err, srcStat) => {
          if (err) return cb(err)

          if (srcStat.isDirectory())
            return onDir(srcStat, destStat, src, dest, opts, cb)
          else if (
            srcStat.isFile() ||
            srcStat.isCharacterDevice() ||
            srcStat.isBlockDevice()
          )
            return onFile(srcStat, destStat, src, dest, opts, cb)
          else if (srcStat.isSymbolicLink())
            return onLink(destStat, src, dest, opts, cb)
        })
      }

      function onFile(srcStat, destStat, src, dest, opts, cb) {
        if (!destStat) return copyFile(srcStat, src, dest, opts, cb)
        return mayCopyFile(srcStat, src, dest, opts, cb)
      }

      function mayCopyFile(srcStat, src, dest, opts, cb) {
        if (opts.overwrite) {
          fs.unlink(dest, err => {
            if (err) return cb(err)
            return copyFile(srcStat, src, dest, opts, cb)
          })
        } else if (opts.errorOnExist) {
          return cb(new Error(`'${dest}' already exists`))
        } else return cb()
      }

      function copyFile(srcStat, src, dest, opts, cb) {
        if (typeof fs.copyFile === 'function') {
          return fs.copyFile(src, dest, err => {
            if (err) return cb(err)
            return setDestModeAndTimestamps(srcStat, dest, opts, cb)
          })
        }
        return copyFileFallback(srcStat, src, dest, opts, cb)
      }

      function copyFileFallback(srcStat, src, dest, opts, cb) {
        const rs = fs.createReadStream(src)
        rs.on('error', err => cb(err)).once('open', () => {
          const ws = fs.createWriteStream(dest, { mode: srcStat.mode })
          ws.on('error', err => cb(err))
            .on('open', () => rs.pipe(ws))
            .once('close', () =>
              setDestModeAndTimestamps(srcStat, dest, opts, cb)
            )
        })
      }

      function setDestModeAndTimestamps(srcStat, dest, opts, cb) {
        fs.chmod(dest, srcStat.mode, err => {
          if (err) return cb(err)
          if (opts.preserveTimestamps) {
            return utimes(dest, srcStat.atime, srcStat.mtime, cb)
          }
          return cb()
        })
      }

      function onDir(srcStat, destStat, src, dest, opts, cb) {
        if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts, cb)
        if (destStat && !destStat.isDirectory()) {
          return cb(
            new Error(
              `Cannot overwrite non-directory '${dest}' with directory '${src}'.`
            )
          )
        }
        return copyDir(src, dest, opts, cb)
      }

      function mkDirAndCopy(srcStat, src, dest, opts, cb) {
        fs.mkdir(dest, err => {
          if (err) return cb(err)
          copyDir(src, dest, opts, err => {
            if (err) return cb(err)
            return fs.chmod(dest, srcStat.mode, cb)
          })
        })
      }

      function copyDir(src, dest, opts, cb) {
        fs.readdir(src, (err, items) => {
          if (err) return cb(err)
          return copyDirItems(items, src, dest, opts, cb)
        })
      }

      function copyDirItems(items, src, dest, opts, cb) {
        const item = items.pop()
        if (!item) return cb()
        return copyDirItem(items, item, src, dest, opts, cb)
      }

      function copyDirItem(items, item, src, dest, opts, cb) {
        const srcItem = path.join(src, item)
        const destItem = path.join(dest, item)
        stat.checkPaths(srcItem, destItem, 'copy', (err, stats) => {
          if (err) return cb(err)
          const { destStat } = stats
          startCopy(destStat, srcItem, destItem, opts, err => {
            if (err) return cb(err)
            return copyDirItems(items, src, dest, opts, cb)
          })
        })
      }

      function onLink(destStat, src, dest, opts, cb) {
        fs.readlink(src, (err, resolvedSrc) => {
          if (err) return cb(err)
          if (opts.dereference) {
            resolvedSrc = path.resolve(process.cwd(), resolvedSrc)
          }

          if (!destStat) {
            return fs.symlink(resolvedSrc, dest, cb)
          } else {
            fs.readlink(dest, (err, resolvedDest) => {
              if (err) {
                // dest exists and is a regular file or directory,
                // Windows may throw UNKNOWN error. If dest already exists,
                // fs throws error anyway, so no need to guard against it here.
                if (err.code === 'EINVAL' || err.code === 'UNKNOWN')
                  return fs.symlink(resolvedSrc, dest, cb)
                return cb(err)
              }
              if (opts.dereference) {
                resolvedDest = path.resolve(process.cwd(), resolvedDest)
              }
              if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
                return cb(
                  new Error(
                    `Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`
                  )
                )
              }

              // do not copy if src is a subdir of dest since unlinking
              // dest in this case would result in removing src contents
              // and therefore a broken symlink would be created.
              if (
                destStat.isDirectory() &&
                stat.isSrcSubdir(resolvedDest, resolvedSrc)
              ) {
                return cb(
                  new Error(
                    `Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`
                  )
                )
              }
              return copyLink(resolvedSrc, dest, cb)
            })
          }
        })
      }

      function copyLink(resolvedSrc, dest, cb) {
        fs.unlink(dest, err => {
          if (err) return cb(err)
          return fs.symlink(resolvedSrc, dest, cb)
        })
      }

      module.exports = copy

      /***/
    },

    /***/ 4882: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      module.exports = {
        copy: u(__nccwpck_require__(7350)),
      }

      /***/
    },

    /***/ 665: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const mkdir = __nccwpck_require__(3264)
      const remove = __nccwpck_require__(8588)

      const emptyDir = u(function emptyDir(dir, callback) {
        callback = callback || function () {}
        fs.readdir(dir, (err, items) => {
          if (err) return mkdir.mkdirs(dir, callback)

          items = items.map(item => path.join(dir, item))

          deleteItem()

          function deleteItem() {
            const item = items.pop()
            if (!item) return callback()
            remove.remove(item, err => {
              if (err) return callback(err)
              deleteItem()
            })
          }
        })
      })

      function emptyDirSync(dir) {
        let items
        try {
          items = fs.readdirSync(dir)
        } catch (err) {
          return mkdir.mkdirsSync(dir)
        }

        items.forEach(item => {
          item = path.join(dir, item)
          remove.removeSync(item)
        })
      }

      module.exports = {
        emptyDirSync,
        emptydirSync: emptyDirSync,
        emptyDir,
        emptydir: emptyDir,
      }

      /***/
    },

    /***/ 5083: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const path = __nccwpck_require__(1017)
      const fs = __nccwpck_require__(7758)
      const mkdir = __nccwpck_require__(3264)
      const pathExists = __nccwpck_require__(1256).pathExists

      function createFile(file, callback) {
        function makeFile() {
          fs.writeFile(file, '', err => {
            if (err) return callback(err)
            callback()
          })
        }

        fs.stat(file, (err, stats) => {
          // eslint-disable-line handle-callback-err
          if (!err && stats.isFile()) return callback()
          const dir = path.dirname(file)
          pathExists(dir, (err, dirExists) => {
            if (err) return callback(err)
            if (dirExists) return makeFile()
            mkdir.mkdirs(dir, err => {
              if (err) return callback(err)
              makeFile()
            })
          })
        })
      }

      function createFileSync(file) {
        let stats
        try {
          stats = fs.statSync(file)
        } catch (e) {}
        if (stats && stats.isFile()) return

        const dir = path.dirname(file)
        if (!fs.existsSync(dir)) {
          mkdir.mkdirsSync(dir)
        }

        fs.writeFileSync(file, '')
      }

      module.exports = {
        createFile: u(createFile),
        createFileSync,
      }

      /***/
    },

    /***/ 9269: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const file = __nccwpck_require__(5083)
      const link = __nccwpck_require__(729)
      const symlink = __nccwpck_require__(6804)

      module.exports = {
        // file
        createFile: file.createFile,
        createFileSync: file.createFileSync,
        ensureFile: file.createFile,
        ensureFileSync: file.createFileSync,
        // link
        createLink: link.createLink,
        createLinkSync: link.createLinkSync,
        ensureLink: link.createLink,
        ensureLinkSync: link.createLinkSync,
        // symlink
        createSymlink: symlink.createSymlink,
        createSymlinkSync: symlink.createSymlinkSync,
        ensureSymlink: symlink.createSymlink,
        ensureSymlinkSync: symlink.createSymlinkSync,
      }

      /***/
    },

    /***/ 729: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const path = __nccwpck_require__(1017)
      const fs = __nccwpck_require__(7758)
      const mkdir = __nccwpck_require__(3264)
      const pathExists = __nccwpck_require__(1256).pathExists

      function createLink(srcpath, dstpath, callback) {
        function makeLink(srcpath, dstpath) {
          fs.link(srcpath, dstpath, err => {
            if (err) return callback(err)
            callback(null)
          })
        }

        pathExists(dstpath, (err, destinationExists) => {
          if (err) return callback(err)
          if (destinationExists) return callback(null)
          fs.lstat(srcpath, err => {
            if (err) {
              err.message = err.message.replace('lstat', 'ensureLink')
              return callback(err)
            }

            const dir = path.dirname(dstpath)
            pathExists(dir, (err, dirExists) => {
              if (err) return callback(err)
              if (dirExists) return makeLink(srcpath, dstpath)
              mkdir.mkdirs(dir, err => {
                if (err) return callback(err)
                makeLink(srcpath, dstpath)
              })
            })
          })
        })
      }

      function createLinkSync(srcpath, dstpath) {
        const destinationExists = fs.existsSync(dstpath)
        if (destinationExists) return undefined

        try {
          fs.lstatSync(srcpath)
        } catch (err) {
          err.message = err.message.replace('lstat', 'ensureLink')
          throw err
        }

        const dir = path.dirname(dstpath)
        const dirExists = fs.existsSync(dir)
        if (dirExists) return fs.linkSync(srcpath, dstpath)
        mkdir.mkdirsSync(dir)

        return fs.linkSync(srcpath, dstpath)
      }

      module.exports = {
        createLink: u(createLink),
        createLinkSync,
      }

      /***/
    },

    /***/ 4706: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const path = __nccwpck_require__(1017)
      const fs = __nccwpck_require__(7758)
      const pathExists = __nccwpck_require__(1256).pathExists

      /**
       * Function that returns two types of paths, one relative to symlink, and one
       * relative to the current working directory. Checks if path is absolute or
       * relative. If the path is relative, this function checks if the path is
       * relative to symlink or relative to current working directory. This is an
       * initiative to find a smarter `srcpath` to supply when building symlinks.
       * This allows you to determine which path to use out of one of three possible
       * types of source paths. The first is an absolute path. This is detected by
       * `path.isAbsolute()`. When an absolute path is provided, it is checked to
       * see if it exists. If it does it's used, if not an error is returned
       * (callback)/ thrown (sync). The other two options for `srcpath` are a
       * relative url. By default Node's `fs.symlink` works by creating a symlink
       * using `dstpath` and expects the `srcpath` to be relative to the newly
       * created symlink. If you provide a `srcpath` that does not exist on the file
       * system it results in a broken symlink. To minimize this, the function
       * checks to see if the 'relative to symlink' source file exists, and if it
       * does it will use it. If it does not, it checks if there's a file that
       * exists that is relative to the current working directory, if does its used.
       * This preserves the expectations of the original fs.symlink spec and adds
       * the ability to pass in `relative to current working direcotry` paths.
       */

      function symlinkPaths(srcpath, dstpath, callback) {
        if (path.isAbsolute(srcpath)) {
          return fs.lstat(srcpath, err => {
            if (err) {
              err.message = err.message.replace('lstat', 'ensureSymlink')
              return callback(err)
            }
            return callback(null, {
              toCwd: srcpath,
              toDst: srcpath,
            })
          })
        } else {
          const dstdir = path.dirname(dstpath)
          const relativeToDst = path.join(dstdir, srcpath)
          return pathExists(relativeToDst, (err, exists) => {
            if (err) return callback(err)
            if (exists) {
              return callback(null, {
                toCwd: relativeToDst,
                toDst: srcpath,
              })
            } else {
              return fs.lstat(srcpath, err => {
                if (err) {
                  err.message = err.message.replace('lstat', 'ensureSymlink')
                  return callback(err)
                }
                return callback(null, {
                  toCwd: srcpath,
                  toDst: path.relative(dstdir, srcpath),
                })
              })
            }
          })
        }
      }

      function symlinkPathsSync(srcpath, dstpath) {
        let exists
        if (path.isAbsolute(srcpath)) {
          exists = fs.existsSync(srcpath)
          if (!exists) throw new Error('absolute srcpath does not exist')
          return {
            toCwd: srcpath,
            toDst: srcpath,
          }
        } else {
          const dstdir = path.dirname(dstpath)
          const relativeToDst = path.join(dstdir, srcpath)
          exists = fs.existsSync(relativeToDst)
          if (exists) {
            return {
              toCwd: relativeToDst,
              toDst: srcpath,
            }
          } else {
            exists = fs.existsSync(srcpath)
            if (!exists) throw new Error('relative srcpath does not exist')
            return {
              toCwd: srcpath,
              toDst: path.relative(dstdir, srcpath),
            }
          }
        }
      }

      module.exports = {
        symlinkPaths,
        symlinkPathsSync,
      }

      /***/
    },

    /***/ 3442: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)

      function symlinkType(srcpath, type, callback) {
        callback = typeof type === 'function' ? type : callback
        type = typeof type === 'function' ? false : type
        if (type) return callback(null, type)
        fs.lstat(srcpath, (err, stats) => {
          if (err) return callback(null, 'file')
          type = stats && stats.isDirectory() ? 'dir' : 'file'
          callback(null, type)
        })
      }

      function symlinkTypeSync(srcpath, type) {
        let stats

        if (type) return type
        try {
          stats = fs.lstatSync(srcpath)
        } catch (e) {
          return 'file'
        }
        return stats && stats.isDirectory() ? 'dir' : 'file'
      }

      module.exports = {
        symlinkType,
        symlinkTypeSync,
      }

      /***/
    },

    /***/ 6804: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const path = __nccwpck_require__(1017)
      const fs = __nccwpck_require__(7758)
      const _mkdirs = __nccwpck_require__(3264)
      const mkdirs = _mkdirs.mkdirs
      const mkdirsSync = _mkdirs.mkdirsSync

      const _symlinkPaths = __nccwpck_require__(4706)
      const symlinkPaths = _symlinkPaths.symlinkPaths
      const symlinkPathsSync = _symlinkPaths.symlinkPathsSync

      const _symlinkType = __nccwpck_require__(3442)
      const symlinkType = _symlinkType.symlinkType
      const symlinkTypeSync = _symlinkType.symlinkTypeSync

      const pathExists = __nccwpck_require__(1256).pathExists

      function createSymlink(srcpath, dstpath, type, callback) {
        callback = typeof type === 'function' ? type : callback
        type = typeof type === 'function' ? false : type

        pathExists(dstpath, (err, destinationExists) => {
          if (err) return callback(err)
          if (destinationExists) return callback(null)
          symlinkPaths(srcpath, dstpath, (err, relative) => {
            if (err) return callback(err)
            srcpath = relative.toDst
            symlinkType(relative.toCwd, type, (err, type) => {
              if (err) return callback(err)
              const dir = path.dirname(dstpath)
              pathExists(dir, (err, dirExists) => {
                if (err) return callback(err)
                if (dirExists)
                  return fs.symlink(srcpath, dstpath, type, callback)
                mkdirs(dir, err => {
                  if (err) return callback(err)
                  fs.symlink(srcpath, dstpath, type, callback)
                })
              })
            })
          })
        })
      }

      function createSymlinkSync(srcpath, dstpath, type) {
        const destinationExists = fs.existsSync(dstpath)
        if (destinationExists) return undefined

        const relative = symlinkPathsSync(srcpath, dstpath)
        srcpath = relative.toDst
        type = symlinkTypeSync(relative.toCwd, type)
        const dir = path.dirname(dstpath)
        const exists = fs.existsSync(dir)
        if (exists) return fs.symlinkSync(srcpath, dstpath, type)
        mkdirsSync(dir)
        return fs.symlinkSync(srcpath, dstpath, type)
      }

      module.exports = {
        createSymlink: u(createSymlink),
        createSymlinkSync,
      }

      /***/
    },

    /***/ 6712: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      // This is adapted from https://github.com/normalize/mz
      // Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const fs = __nccwpck_require__(7758)

      const api = [
        'access',
        'appendFile',
        'chmod',
        'chown',
        'close',
        'copyFile',
        'fchmod',
        'fchown',
        'fdatasync',
        'fstat',
        'fsync',
        'ftruncate',
        'futimes',
        'lchown',
        'lchmod',
        'link',
        'lstat',
        'mkdir',
        'mkdtemp',
        'open',
        'readFile',
        'readdir',
        'readlink',
        'realpath',
        'rename',
        'rmdir',
        'stat',
        'symlink',
        'truncate',
        'unlink',
        'utimes',
        'writeFile',
      ].filter(key => {
        // Some commands are not available on some systems. Ex:
        // fs.copyFile was added in Node.js v8.5.0
        // fs.mkdtemp was added in Node.js v5.10.0
        // fs.lchown is not available on at least some Linux
        return typeof fs[key] === 'function'
      })

      // Export all keys:
      Object.keys(fs).forEach(key => {
        if (key === 'promises') {
          // fs.promises is a getter property that triggers ExperimentalWarning
          // Don't re-export it here, the getter is defined in "lib/index.js"
          return
        }
        exports[key] = fs[key]
      })

      // Universalify async methods:
      api.forEach(method => {
        exports[method] = u(fs[method])
      })

      // We differ from mz/fs in that we still ship the old, broken, fs.exists()
      // since we are a drop-in replacement for the native module
      exports.exists = function (filename, callback) {
        if (typeof callback === 'function') {
          return fs.exists(filename, callback)
        }
        return new Promise(resolve => {
          return fs.exists(filename, resolve)
        })
      }

      // fs.read() & fs.write need special treatment due to multiple callback args

      exports.read = function (fd, buffer, offset, length, position, callback) {
        if (typeof callback === 'function') {
          return fs.read(fd, buffer, offset, length, position, callback)
        }
        return new Promise((resolve, reject) => {
          fs.read(
            fd,
            buffer,
            offset,
            length,
            position,
            (err, bytesRead, buffer) => {
              if (err) return reject(err)
              resolve({ bytesRead, buffer })
            }
          )
        })
      }

      // Function signature can be
      // fs.write(fd, buffer[, offset[, length[, position]]], callback)
      // OR
      // fs.write(fd, string[, position[, encoding]], callback)
      // We need to handle both cases, so we use ...args
      exports.write = function (fd, buffer, ...args) {
        if (typeof args[args.length - 1] === 'function') {
          return fs.write(fd, buffer, ...args)
        }

        return new Promise((resolve, reject) => {
          fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
            if (err) return reject(err)
            resolve({ bytesWritten, buffer })
          })
        })
      }

      // fs.realpath.native only available in Node v9.2+
      if (typeof fs.realpath.native === 'function') {
        exports.realpath.native = u(fs.realpath.native)
      }

      /***/
    },

    /***/ 4586: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      module.exports = Object.assign(
        {},
        // Export promiseified graceful-fs:
        __nccwpck_require__(6712),
        // Export extra methods:
        __nccwpck_require__(5552),
        __nccwpck_require__(4882),
        __nccwpck_require__(665),
        __nccwpck_require__(9269),
        __nccwpck_require__(5344),
        __nccwpck_require__(3264),
        __nccwpck_require__(9813),
        __nccwpck_require__(3706),
        __nccwpck_require__(5918),
        __nccwpck_require__(1256),
        __nccwpck_require__(8588)
      )

      // Export fs.promises as a getter property so that we don't trigger
      // ExperimentalWarning before fs.promises is actually accessed.
      const fs = __nccwpck_require__(7147)
      if (Object.getOwnPropertyDescriptor(fs, 'promises')) {
        Object.defineProperty(module.exports, 'promises', {
          get() {
            return fs.promises
          },
        })
      }

      /***/
    },

    /***/ 5344: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const jsonFile = __nccwpck_require__(1760)

      jsonFile.outputJson = u(__nccwpck_require__(2256))
      jsonFile.outputJsonSync = __nccwpck_require__(3406)
      // aliases
      jsonFile.outputJSON = jsonFile.outputJson
      jsonFile.outputJSONSync = jsonFile.outputJsonSync
      jsonFile.writeJSON = jsonFile.writeJson
      jsonFile.writeJSONSync = jsonFile.writeJsonSync
      jsonFile.readJSON = jsonFile.readJson
      jsonFile.readJSONSync = jsonFile.readJsonSync

      module.exports = jsonFile

      /***/
    },

    /***/ 1760: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const jsonFile = __nccwpck_require__(6160)

      module.exports = {
        // jsonfile exports
        readJson: u(jsonFile.readFile),
        readJsonSync: jsonFile.readFileSync,
        writeJson: u(jsonFile.writeFile),
        writeJsonSync: jsonFile.writeFileSync,
      }

      /***/
    },

    /***/ 3406: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const mkdir = __nccwpck_require__(3264)
      const jsonFile = __nccwpck_require__(1760)

      function outputJsonSync(file, data, options) {
        const dir = path.dirname(file)

        if (!fs.existsSync(dir)) {
          mkdir.mkdirsSync(dir)
        }

        jsonFile.writeJsonSync(file, data, options)
      }

      module.exports = outputJsonSync

      /***/
    },

    /***/ 2256: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const path = __nccwpck_require__(1017)
      const mkdir = __nccwpck_require__(3264)
      const pathExists = __nccwpck_require__(1256).pathExists
      const jsonFile = __nccwpck_require__(1760)

      function outputJson(file, data, options, callback) {
        if (typeof options === 'function') {
          callback = options
          options = {}
        }

        const dir = path.dirname(file)

        pathExists(dir, (err, itDoes) => {
          if (err) return callback(err)
          if (itDoes) return jsonFile.writeJson(file, data, options, callback)

          mkdir.mkdirs(dir, err => {
            if (err) return callback(err)
            jsonFile.writeJson(file, data, options, callback)
          })
        })
      }

      module.exports = outputJson

      /***/
    },

    /***/ 3264: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const mkdirs = u(__nccwpck_require__(8690))
      const mkdirsSync = __nccwpck_require__(8532)

      module.exports = {
        mkdirs,
        mkdirsSync,
        // alias
        mkdirp: mkdirs,
        mkdirpSync: mkdirsSync,
        ensureDir: mkdirs,
        ensureDirSync: mkdirsSync,
      }

      /***/
    },

    /***/ 8532: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const invalidWin32Path = __nccwpck_require__(7006).invalidWin32Path

      const o777 = parseInt('0777', 8)

      function mkdirsSync(p, opts, made) {
        if (!opts || typeof opts !== 'object') {
          opts = { mode: opts }
        }

        let mode = opts.mode
        const xfs = opts.fs || fs

        if (process.platform === 'win32' && invalidWin32Path(p)) {
          const errInval = new Error(
            p + ' contains invalid WIN32 path characters.'
          )
          errInval.code = 'EINVAL'
          throw errInval
        }

        if (mode === undefined) {
          mode = o777 & ~process.umask()
        }
        if (!made) made = null

        p = path.resolve(p)

        try {
          xfs.mkdirSync(p, mode)
          made = made || p
        } catch (err0) {
          if (err0.code === 'ENOENT') {
            if (path.dirname(p) === p) throw err0
            made = mkdirsSync(path.dirname(p), opts, made)
            mkdirsSync(p, opts, made)
          } else {
            // In the case of any other error, just see if there's a dir there
            // already. If so, then hooray!  If not, then something is borked.
            let stat
            try {
              stat = xfs.statSync(p)
            } catch (err1) {
              throw err0
            }
            if (!stat.isDirectory()) throw err0
          }
        }

        return made
      }

      module.exports = mkdirsSync

      /***/
    },

    /***/ 8690: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const invalidWin32Path = __nccwpck_require__(7006).invalidWin32Path

      const o777 = parseInt('0777', 8)

      function mkdirs(p, opts, callback, made) {
        if (typeof opts === 'function') {
          callback = opts
          opts = {}
        } else if (!opts || typeof opts !== 'object') {
          opts = { mode: opts }
        }

        if (process.platform === 'win32' && invalidWin32Path(p)) {
          const errInval = new Error(
            p + ' contains invalid WIN32 path characters.'
          )
          errInval.code = 'EINVAL'
          return callback(errInval)
        }

        let mode = opts.mode
        const xfs = opts.fs || fs

        if (mode === undefined) {
          mode = o777 & ~process.umask()
        }
        if (!made) made = null

        callback = callback || function () {}
        p = path.resolve(p)

        xfs.mkdir(p, mode, er => {
          if (!er) {
            made = made || p
            return callback(null, made)
          }
          switch (er.code) {
            case 'ENOENT':
              if (path.dirname(p) === p) return callback(er)
              mkdirs(path.dirname(p), opts, (er, made) => {
                if (er) callback(er, made)
                else mkdirs(p, opts, callback, made)
              })
              break

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
              xfs.stat(p, (er2, stat) => {
                // if the stat fails, then that's super weird.
                // let the original error be the failure reason.
                if (er2 || !stat.isDirectory()) callback(er, made)
                else callback(null, made)
              })
              break
          }
        })
      }

      module.exports = mkdirs

      /***/
    },

    /***/ 7006: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const path = __nccwpck_require__(1017)

      // get drive on windows
      function getRootPath(p) {
        p = path.normalize(path.resolve(p)).split(path.sep)
        if (p.length > 0) return p[0]
        return null
      }

      // http://stackoverflow.com/a/62888/10333 contains more accurate
      // TODO: expand to include the rest
      const INVALID_PATH_CHARS = /[<>:"|?*]/

      function invalidWin32Path(p) {
        const rp = getRootPath(p)
        p = p.replace(rp, '')
        return INVALID_PATH_CHARS.test(p)
      }

      module.exports = {
        getRootPath,
        invalidWin32Path,
      }

      /***/
    },

    /***/ 9813: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      module.exports = {
        moveSync: __nccwpck_require__(5179),
      }

      /***/
    },

    /***/ 5179: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const copySync = __nccwpck_require__(5552).copySync
      const removeSync = __nccwpck_require__(8588).removeSync
      const mkdirpSync = __nccwpck_require__(3264).mkdirpSync
      const stat = __nccwpck_require__(2022)

      function moveSync(src, dest, opts) {
        opts = opts || {}
        const overwrite = opts.overwrite || opts.clobber || false

        const { srcStat } = stat.checkPathsSync(src, dest, 'move')
        stat.checkParentPathsSync(src, srcStat, dest, 'move')
        mkdirpSync(path.dirname(dest))
        return doRename(src, dest, overwrite)
      }

      function doRename(src, dest, overwrite) {
        if (overwrite) {
          removeSync(dest)
          return rename(src, dest, overwrite)
        }
        if (fs.existsSync(dest)) throw new Error('dest already exists.')
        return rename(src, dest, overwrite)
      }

      function rename(src, dest, overwrite) {
        try {
          fs.renameSync(src, dest)
        } catch (err) {
          if (err.code !== 'EXDEV') throw err
          return moveAcrossDevice(src, dest, overwrite)
        }
      }

      function moveAcrossDevice(src, dest, overwrite) {
        const opts = {
          overwrite,
          errorOnExist: true,
        }
        copySync(src, dest, opts)
        return removeSync(src)
      }

      module.exports = moveSync

      /***/
    },

    /***/ 3706: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      module.exports = {
        move: u(__nccwpck_require__(5419)),
      }

      /***/
    },

    /***/ 5419: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const copy = __nccwpck_require__(4882).copy
      const remove = __nccwpck_require__(8588).remove
      const mkdirp = __nccwpck_require__(3264).mkdirp
      const pathExists = __nccwpck_require__(1256).pathExists
      const stat = __nccwpck_require__(2022)

      function move(src, dest, opts, cb) {
        if (typeof opts === 'function') {
          cb = opts
          opts = {}
        }

        const overwrite = opts.overwrite || opts.clobber || false

        stat.checkPaths(src, dest, 'move', (err, stats) => {
          if (err) return cb(err)
          const { srcStat } = stats
          stat.checkParentPaths(src, srcStat, dest, 'move', err => {
            if (err) return cb(err)
            mkdirp(path.dirname(dest), err => {
              if (err) return cb(err)
              return doRename(src, dest, overwrite, cb)
            })
          })
        })
      }

      function doRename(src, dest, overwrite, cb) {
        if (overwrite) {
          return remove(dest, err => {
            if (err) return cb(err)
            return rename(src, dest, overwrite, cb)
          })
        }
        pathExists(dest, (err, destExists) => {
          if (err) return cb(err)
          if (destExists) return cb(new Error('dest already exists.'))
          return rename(src, dest, overwrite, cb)
        })
      }

      function rename(src, dest, overwrite, cb) {
        fs.rename(src, dest, err => {
          if (!err) return cb()
          if (err.code !== 'EXDEV') return cb(err)
          return moveAcrossDevice(src, dest, overwrite, cb)
        })
      }

      function moveAcrossDevice(src, dest, overwrite, cb) {
        const opts = {
          overwrite,
          errorOnExist: true,
        }
        copy(src, dest, opts, err => {
          if (err) return cb(err)
          return remove(src, cb)
        })
      }

      module.exports = move

      /***/
    },

    /***/ 5918: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const mkdir = __nccwpck_require__(3264)
      const pathExists = __nccwpck_require__(1256).pathExists

      function outputFile(file, data, encoding, callback) {
        if (typeof encoding === 'function') {
          callback = encoding
          encoding = 'utf8'
        }

        const dir = path.dirname(file)
        pathExists(dir, (err, itDoes) => {
          if (err) return callback(err)
          if (itDoes) return fs.writeFile(file, data, encoding, callback)

          mkdir.mkdirs(dir, err => {
            if (err) return callback(err)

            fs.writeFile(file, data, encoding, callback)
          })
        })
      }

      function outputFileSync(file, ...args) {
        const dir = path.dirname(file)
        if (fs.existsSync(dir)) {
          return fs.writeFileSync(file, ...args)
        }
        mkdir.mkdirsSync(dir)
        fs.writeFileSync(file, ...args)
      }

      module.exports = {
        outputFile: u(outputFile),
        outputFileSync,
      }

      /***/
    },

    /***/ 1256: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromPromise */.p
      const fs = __nccwpck_require__(6712)

      function pathExists(path) {
        return fs
          .access(path)
          .then(() => true)
          .catch(() => false)
      }

      module.exports = {
        pathExists: u(pathExists),
        pathExistsSync: fs.existsSync,
      }

      /***/
    },

    /***/ 8588: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const rimraf = __nccwpck_require__(7143)

      module.exports = {
        remove: u(rimraf),
        removeSync: rimraf.sync,
      }

      /***/
    },

    /***/ 7143: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const assert = __nccwpck_require__(9491)

      const isWindows = process.platform === 'win32'

      function defaults(options) {
        const methods = ['unlink', 'chmod', 'stat', 'lstat', 'rmdir', 'readdir']
        methods.forEach(m => {
          options[m] = options[m] || fs[m]
          m = m + 'Sync'
          options[m] = options[m] || fs[m]
        })

        options.maxBusyTries = options.maxBusyTries || 3
      }

      function rimraf(p, options, cb) {
        let busyTries = 0

        if (typeof options === 'function') {
          cb = options
          options = {}
        }

        assert(p, 'rimraf: missing path')
        assert.strictEqual(
          typeof p,
          'string',
          'rimraf: path should be a string'
        )
        assert.strictEqual(
          typeof cb,
          'function',
          'rimraf: callback function required'
        )
        assert(options, 'rimraf: invalid options argument provided')
        assert.strictEqual(
          typeof options,
          'object',
          'rimraf: options should be object'
        )

        defaults(options)

        rimraf_(p, options, function CB(er) {
          if (er) {
            if (
              (er.code === 'EBUSY' ||
                er.code === 'ENOTEMPTY' ||
                er.code === 'EPERM') &&
              busyTries < options.maxBusyTries
            ) {
              busyTries++
              const time = busyTries * 100
              // try again, with the same exact callback as this one.
              return setTimeout(() => rimraf_(p, options, CB), time)
            }

            // already gone
            if (er.code === 'ENOENT') er = null
          }

          cb(er)
        })
      }

      // Two possible strategies.
      // 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
      // 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
      //
      // Both result in an extra syscall when you guess wrong.  However, there
      // are likely far more normal files in the world than directories.  This
      // is based on the assumption that a the average number of files per
      // directory is >= 1.
      //
      // If anyone ever complains about this, then I guess the strategy could
      // be made configurable somehow.  But until then, YAGNI.
      function rimraf_(p, options, cb) {
        assert(p)
        assert(options)
        assert(typeof cb === 'function')

        // sunos lets the root user unlink directories, which is... weird.
        // so we have to lstat here and make sure it's not a dir.
        options.lstat(p, (er, st) => {
          if (er && er.code === 'ENOENT') {
            return cb(null)
          }

          // Windows can EPERM on stat.  Life is suffering.
          if (er && er.code === 'EPERM' && isWindows) {
            return fixWinEPERM(p, options, er, cb)
          }

          if (st && st.isDirectory()) {
            return rmdir(p, options, er, cb)
          }

          options.unlink(p, er => {
            if (er) {
              if (er.code === 'ENOENT') {
                return cb(null)
              }
              if (er.code === 'EPERM') {
                return isWindows
                  ? fixWinEPERM(p, options, er, cb)
                  : rmdir(p, options, er, cb)
              }
              if (er.code === 'EISDIR') {
                return rmdir(p, options, er, cb)
              }
            }
            return cb(er)
          })
        })
      }

      function fixWinEPERM(p, options, er, cb) {
        assert(p)
        assert(options)
        assert(typeof cb === 'function')
        if (er) {
          assert(er instanceof Error)
        }

        options.chmod(p, 0o666, er2 => {
          if (er2) {
            cb(er2.code === 'ENOENT' ? null : er)
          } else {
            options.stat(p, (er3, stats) => {
              if (er3) {
                cb(er3.code === 'ENOENT' ? null : er)
              } else if (stats.isDirectory()) {
                rmdir(p, options, er, cb)
              } else {
                options.unlink(p, cb)
              }
            })
          }
        })
      }

      function fixWinEPERMSync(p, options, er) {
        let stats

        assert(p)
        assert(options)
        if (er) {
          assert(er instanceof Error)
        }

        try {
          options.chmodSync(p, 0o666)
        } catch (er2) {
          if (er2.code === 'ENOENT') {
            return
          } else {
            throw er
          }
        }

        try {
          stats = options.statSync(p)
        } catch (er3) {
          if (er3.code === 'ENOENT') {
            return
          } else {
            throw er
          }
        }

        if (stats.isDirectory()) {
          rmdirSync(p, options, er)
        } else {
          options.unlinkSync(p)
        }
      }

      function rmdir(p, options, originalEr, cb) {
        assert(p)
        assert(options)
        if (originalEr) {
          assert(originalEr instanceof Error)
        }
        assert(typeof cb === 'function')

        // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
        // if we guessed wrong, and it's not a directory, then
        // raise the original error.
        options.rmdir(p, er => {
          if (
            er &&
            (er.code === 'ENOTEMPTY' ||
              er.code === 'EEXIST' ||
              er.code === 'EPERM')
          ) {
            rmkids(p, options, cb)
          } else if (er && er.code === 'ENOTDIR') {
            cb(originalEr)
          } else {
            cb(er)
          }
        })
      }

      function rmkids(p, options, cb) {
        assert(p)
        assert(options)
        assert(typeof cb === 'function')

        options.readdir(p, (er, files) => {
          if (er) return cb(er)

          let n = files.length
          let errState

          if (n === 0) return options.rmdir(p, cb)

          files.forEach(f => {
            rimraf(path.join(p, f), options, er => {
              if (errState) {
                return
              }
              if (er) return cb((errState = er))
              if (--n === 0) {
                options.rmdir(p, cb)
              }
            })
          })
        })
      }

      // this looks simpler, and is strictly *faster*, but will
      // tie up the JavaScript thread and fail on excessively
      // deep directory trees.
      function rimrafSync(p, options) {
        let st

        options = options || {}
        defaults(options)

        assert(p, 'rimraf: missing path')
        assert.strictEqual(
          typeof p,
          'string',
          'rimraf: path should be a string'
        )
        assert(options, 'rimraf: missing options')
        assert.strictEqual(
          typeof options,
          'object',
          'rimraf: options should be object'
        )

        try {
          st = options.lstatSync(p)
        } catch (er) {
          if (er.code === 'ENOENT') {
            return
          }

          // Windows can EPERM on stat.  Life is suffering.
          if (er.code === 'EPERM' && isWindows) {
            fixWinEPERMSync(p, options, er)
          }
        }

        try {
          // sunos lets the root user unlink directories, which is... weird.
          if (st && st.isDirectory()) {
            rmdirSync(p, options, null)
          } else {
            options.unlinkSync(p)
          }
        } catch (er) {
          if (er.code === 'ENOENT') {
            return
          } else if (er.code === 'EPERM') {
            return isWindows
              ? fixWinEPERMSync(p, options, er)
              : rmdirSync(p, options, er)
          } else if (er.code !== 'EISDIR') {
            throw er
          }
          rmdirSync(p, options, er)
        }
      }

      function rmdirSync(p, options, originalEr) {
        assert(p)
        assert(options)
        if (originalEr) {
          assert(originalEr instanceof Error)
        }

        try {
          options.rmdirSync(p)
        } catch (er) {
          if (er.code === 'ENOTDIR') {
            throw originalEr
          } else if (
            er.code === 'ENOTEMPTY' ||
            er.code === 'EEXIST' ||
            er.code === 'EPERM'
          ) {
            rmkidsSync(p, options)
          } else if (er.code !== 'ENOENT') {
            throw er
          }
        }
      }

      function rmkidsSync(p, options) {
        assert(p)
        assert(options)
        options
          .readdirSync(p)
          .forEach(f => rimrafSync(path.join(p, f), options))

        if (isWindows) {
          // We only end up here once we got ENOTEMPTY at least once, and
          // at this point, we are guaranteed to have removed all the kids.
          // So, we know that it won't be ENOENT or ENOTDIR or anything else.
          // try really hard to delete stuff on windows, because it has a
          // PROFOUNDLY annoying habit of not closing handles promptly when
          // files are deleted, resulting in spurious ENOTEMPTY errors.
          const startTime = Date.now()
          do {
            try {
              const ret = options.rmdirSync(p, options)
              return ret
            } catch (er) {}
          } while (Date.now() - startTime < 500) // give up after 500ms
        } else {
          const ret = options.rmdirSync(p, options)
          return ret
        }
      }

      module.exports = rimraf
      rimraf.sync = rimrafSync

      /***/
    },

    /***/ 3502: /***/ module => {
      'use strict'

      /* eslint-disable node/no-deprecated-api */
      module.exports = function (size) {
        if (typeof Buffer.allocUnsafe === 'function') {
          try {
            return Buffer.allocUnsafe(size)
          } catch (e) {
            return new Buffer(size)
          }
        }
        return new Buffer(size)
      }

      /***/
    },

    /***/ 2022: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)

      const NODE_VERSION_MAJOR_WITH_BIGINT = 10
      const NODE_VERSION_MINOR_WITH_BIGINT = 5
      const NODE_VERSION_PATCH_WITH_BIGINT = 0
      const nodeVersion = process.versions.node.split('.')
      const nodeVersionMajor = Number.parseInt(nodeVersion[0], 10)
      const nodeVersionMinor = Number.parseInt(nodeVersion[1], 10)
      const nodeVersionPatch = Number.parseInt(nodeVersion[2], 10)

      function nodeSupportsBigInt() {
        if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) {
          return true
        } else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {
          if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) {
            return true
          } else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {
            if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) {
              return true
            }
          }
        }
        return false
      }

      function getStats(src, dest, cb) {
        if (nodeSupportsBigInt()) {
          fs.stat(src, { bigint: true }, (err, srcStat) => {
            if (err) return cb(err)
            fs.stat(dest, { bigint: true }, (err, destStat) => {
              if (err) {
                if (err.code === 'ENOENT')
                  return cb(null, { srcStat, destStat: null })
                return cb(err)
              }
              return cb(null, { srcStat, destStat })
            })
          })
        } else {
          fs.stat(src, (err, srcStat) => {
            if (err) return cb(err)
            fs.stat(dest, (err, destStat) => {
              if (err) {
                if (err.code === 'ENOENT')
                  return cb(null, { srcStat, destStat: null })
                return cb(err)
              }
              return cb(null, { srcStat, destStat })
            })
          })
        }
      }

      function getStatsSync(src, dest) {
        let srcStat, destStat
        if (nodeSupportsBigInt()) {
          srcStat = fs.statSync(src, { bigint: true })
        } else {
          srcStat = fs.statSync(src)
        }
        try {
          if (nodeSupportsBigInt()) {
            destStat = fs.statSync(dest, { bigint: true })
          } else {
            destStat = fs.statSync(dest)
          }
        } catch (err) {
          if (err.code === 'ENOENT') return { srcStat, destStat: null }
          throw err
        }
        return { srcStat, destStat }
      }

      function checkPaths(src, dest, funcName, cb) {
        getStats(src, dest, (err, stats) => {
          if (err) return cb(err)
          const { srcStat, destStat } = stats
          if (
            destStat &&
            destStat.ino &&
            destStat.dev &&
            destStat.ino === srcStat.ino &&
            destStat.dev === srcStat.dev
          ) {
            return cb(new Error('Source and destination must not be the same.'))
          }
          if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
            return cb(new Error(errMsg(src, dest, funcName)))
          }
          return cb(null, { srcStat, destStat })
        })
      }

      function checkPathsSync(src, dest, funcName) {
        const { srcStat, destStat } = getStatsSync(src, dest)
        if (
          destStat &&
          destStat.ino &&
          destStat.dev &&
          destStat.ino === srcStat.ino &&
          destStat.dev === srcStat.dev
        ) {
          throw new Error('Source and destination must not be the same.')
        }
        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
          throw new Error(errMsg(src, dest, funcName))
        }
        return { srcStat, destStat }
      }

      // recursively check if dest parent is a subdirectory of src.
      // It works for all file types including symlinks since it
      // checks the src and dest inodes. It starts from the deepest
      // parent and stops once it reaches the src parent or the root path.
      function checkParentPaths(src, srcStat, dest, funcName, cb) {
        const srcParent = path.resolve(path.dirname(src))
        const destParent = path.resolve(path.dirname(dest))
        if (
          destParent === srcParent ||
          destParent === path.parse(destParent).root
        )
          return cb()
        if (nodeSupportsBigInt()) {
          fs.stat(destParent, { bigint: true }, (err, destStat) => {
            if (err) {
              if (err.code === 'ENOENT') return cb()
              return cb(err)
            }
            if (
              destStat.ino &&
              destStat.dev &&
              destStat.ino === srcStat.ino &&
              destStat.dev === srcStat.dev
            ) {
              return cb(new Error(errMsg(src, dest, funcName)))
            }
            return checkParentPaths(src, srcStat, destParent, funcName, cb)
          })
        } else {
          fs.stat(destParent, (err, destStat) => {
            if (err) {
              if (err.code === 'ENOENT') return cb()
              return cb(err)
            }
            if (
              destStat.ino &&
              destStat.dev &&
              destStat.ino === srcStat.ino &&
              destStat.dev === srcStat.dev
            ) {
              return cb(new Error(errMsg(src, dest, funcName)))
            }
            return checkParentPaths(src, srcStat, destParent, funcName, cb)
          })
        }
      }

      function checkParentPathsSync(src, srcStat, dest, funcName) {
        const srcParent = path.resolve(path.dirname(src))
        const destParent = path.resolve(path.dirname(dest))
        if (
          destParent === srcParent ||
          destParent === path.parse(destParent).root
        )
          return
        let destStat
        try {
          if (nodeSupportsBigInt()) {
            destStat = fs.statSync(destParent, { bigint: true })
          } else {
            destStat = fs.statSync(destParent)
          }
        } catch (err) {
          if (err.code === 'ENOENT') return
          throw err
        }
        if (
          destStat.ino &&
          destStat.dev &&
          destStat.ino === srcStat.ino &&
          destStat.dev === srcStat.dev
        ) {
          throw new Error(errMsg(src, dest, funcName))
        }
        return checkParentPathsSync(src, srcStat, destParent, funcName)
      }

      // return true if dest is a subdir of src, otherwise false.
      // It only checks the path strings.
      function isSrcSubdir(src, dest) {
        const srcArr = path
          .resolve(src)
          .split(path.sep)
          .filter(i => i)
        const destArr = path
          .resolve(dest)
          .split(path.sep)
          .filter(i => i)
        return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)
      }

      function errMsg(src, dest, funcName) {
        return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`
      }

      module.exports = {
        checkPaths,
        checkPathsSync,
        checkParentPaths,
        checkParentPathsSync,
        isSrcSubdir,
      }

      /***/
    },

    /***/ 5026: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const os = __nccwpck_require__(2037)
      const path = __nccwpck_require__(1017)

      // HFS, ext{2,3}, FAT do not, Node.js v0.10 does not
      function hasMillisResSync() {
        let tmpfile = path.join(
          'millis-test-sync' +
            Date.now().toString() +
            Math.random().toString().slice(2)
        )
        tmpfile = path.join(os.tmpdir(), tmpfile)

        // 550 millis past UNIX epoch
        const d = new Date(1435410243862)
        fs.writeFileSync(
          tmpfile,
          'https://github.com/jprichardson/node-fs-extra/pull/141'
        )
        const fd = fs.openSync(tmpfile, 'r+')
        fs.futimesSync(fd, d, d)
        fs.closeSync(fd)
        return fs.statSync(tmpfile).mtime > 1435410243000
      }

      function hasMillisRes(callback) {
        let tmpfile = path.join(
          'millis-test' +
            Date.now().toString() +
            Math.random().toString().slice(2)
        )
        tmpfile = path.join(os.tmpdir(), tmpfile)

        // 550 millis past UNIX epoch
        const d = new Date(1435410243862)
        fs.writeFile(
          tmpfile,
          'https://github.com/jprichardson/node-fs-extra/pull/141',
          err => {
            if (err) return callback(err)
            fs.open(tmpfile, 'r+', (err, fd) => {
              if (err) return callback(err)
              fs.futimes(fd, d, d, err => {
                if (err) return callback(err)
                fs.close(fd, err => {
                  if (err) return callback(err)
                  fs.stat(tmpfile, (err, stats) => {
                    if (err) return callback(err)
                    callback(null, stats.mtime > 1435410243000)
                  })
                })
              })
            })
          }
        )
      }

      function timeRemoveMillis(timestamp) {
        if (typeof timestamp === 'number') {
          return Math.floor(timestamp / 1000) * 1000
        } else if (timestamp instanceof Date) {
          return new Date(Math.floor(timestamp.getTime() / 1000) * 1000)
        } else {
          throw new Error('fs-extra: timeRemoveMillis() unknown parameter type')
        }
      }

      function utimesMillis(path, atime, mtime, callback) {
        // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
        fs.open(path, 'r+', (err, fd) => {
          if (err) return callback(err)
          fs.futimes(fd, atime, mtime, futimesErr => {
            fs.close(fd, closeErr => {
              if (callback) callback(futimesErr || closeErr)
            })
          })
        })
      }

      function utimesMillisSync(path, atime, mtime) {
        const fd = fs.openSync(path, 'r+')
        fs.futimesSync(fd, atime, mtime)
        return fs.closeSync(fd)
      }

      module.exports = {
        hasMillisRes,
        hasMillisResSync,
        timeRemoveMillis,
        utimesMillis,
        utimesMillisSync,
      }

      /***/
    },

    /***/ 1000: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })

      function _interopDefault(ex) {
        return ex && typeof ex === 'object' && 'default' in ex
          ? ex['default']
          : ex
      }

      var _regeneratorRuntime = _interopDefault(__nccwpck_require__(7705))
      var _asyncToGenerator = _interopDefault(__nccwpck_require__(6093))
      var _classCallCheck = _interopDefault(__nccwpck_require__(931))
      var _possibleConstructorReturn = _interopDefault(
        __nccwpck_require__(4635)
      )
      var _getPrototypeOf = _interopDefault(__nccwpck_require__(9244))
      var _inherits = _interopDefault(__nccwpck_require__(3078))
      var _wrapNativeSuper = _interopDefault(__nccwpck_require__(1068))
      var fs = _interopDefault(__nccwpck_require__(4858))
      var path = _interopDefault(__nccwpck_require__(1017))
      var globby = __nccwpck_require__(3398)
      var globby__default = _interopDefault(globby)
      var readYamlFile = __nccwpck_require__(2920)
      var readYamlFile__default = _interopDefault(readYamlFile)
      var findRoot = __nccwpck_require__(8482)

      var PackageJsonMissingNameError =
        /*#__PURE__*/
        (function (_Error) {
          _inherits(PackageJsonMissingNameError, _Error)

          function PackageJsonMissingNameError(directories) {
            var _this

            _classCallCheck(this, PackageJsonMissingNameError)

            _this = _possibleConstructorReturn(
              this,
              _getPrototypeOf(PackageJsonMissingNameError).call(
                this,
                'The following package.jsons are missing the "name" field:\n'.concat(
                  directories.join('\n')
                )
              )
            )
            _this.directories = directories
            return _this
          }

          return PackageJsonMissingNameError
        })(_wrapNativeSuper(Error))
      function getPackages(_x) {
        return _getPackages.apply(this, arguments)
      }

      function _getPackages() {
        _getPackages = _asyncToGenerator(
          /*#__PURE__*/
          _regeneratorRuntime.mark(function _callee(dir) {
            var cwd,
              pkg,
              tool,
              manifest,
              lernaJson,
              root,
              relativeDirectories,
              directories,
              pkgJsonsMissingNameField,
              results
            return _regeneratorRuntime.wrap(
              function _callee$(_context) {
                while (1) {
                  switch ((_context.prev = _context.next)) {
                    case 0:
                      _context.next = 2
                      return findRoot.findRoot(dir)

                    case 2:
                      cwd = _context.sent
                      _context.next = 5
                      return fs.readJson(path.join(cwd, 'package.json'))

                    case 5:
                      pkg = _context.sent

                      if (!pkg.workspaces) {
                        _context.next = 10
                        break
                      }

                      if (Array.isArray(pkg.workspaces)) {
                        tool = {
                          type: 'yarn',
                          packageGlobs: pkg.workspaces,
                        }
                      } else if (pkg.workspaces.packages) {
                        tool = {
                          type: 'yarn',
                          packageGlobs: pkg.workspaces.packages,
                        }
                      }

                      _context.next = 37
                      break

                    case 10:
                      if (!(pkg.bolt && pkg.bolt.workspaces)) {
                        _context.next = 14
                        break
                      }

                      tool = {
                        type: 'bolt',
                        packageGlobs: pkg.bolt.workspaces,
                      }
                      _context.next = 37
                      break

                    case 14:
                      _context.prev = 14
                      _context.next = 17
                      return readYamlFile__default(
                        path.join(cwd, 'pnpm-workspace.yaml')
                      )

                    case 17:
                      manifest = _context.sent

                      if (manifest && manifest.packages) {
                        tool = {
                          type: 'pnpm',
                          packageGlobs: manifest.packages,
                        }
                      }

                      _context.next = 25
                      break

                    case 21:
                      _context.prev = 21
                      _context.t0 = _context['catch'](14)

                      if (!(_context.t0.code !== 'ENOENT')) {
                        _context.next = 25
                        break
                      }

                      throw _context.t0

                    case 25:
                      if (tool) {
                        _context.next = 37
                        break
                      }

                      _context.prev = 26
                      _context.next = 29
                      return fs.readJson(path.join(cwd, 'lerna.json'))

                    case 29:
                      lernaJson = _context.sent

                      if (lernaJson) {
                        tool = {
                          type: 'lerna',
                          packageGlobs: lernaJson.packages || ['packages/*'],
                        }
                      }

                      _context.next = 37
                      break

                    case 33:
                      _context.prev = 33
                      _context.t1 = _context['catch'](26)

                      if (!(_context.t1.code !== 'ENOENT')) {
                        _context.next = 37
                        break
                      }

                      throw _context.t1

                    case 37:
                      if (tool) {
                        _context.next = 42
                        break
                      }

                      root = {
                        dir: cwd,
                        packageJson: pkg,
                      }

                      if (pkg.name) {
                        _context.next = 41
                        break
                      }

                      throw new PackageJsonMissingNameError(['package.json'])

                    case 41:
                      return _context.abrupt('return', {
                        tool: 'root',
                        root: root,
                        packages: [root],
                      })

                    case 42:
                      _context.next = 44
                      return globby__default(tool.packageGlobs, {
                        cwd: cwd,
                        onlyDirectories: true,
                        expandDirectories: false,
                        ignore: ['**/node_modules'],
                      })

                    case 44:
                      relativeDirectories = _context.sent
                      directories = relativeDirectories.map(function (p) {
                        return path.resolve(cwd, p)
                      })
                      pkgJsonsMissingNameField = []
                      _context.next = 49
                      return Promise.all(
                        directories.sort().map(function (dir) {
                          return fs
                            .readJson(path.join(dir, 'package.json'))
                            .then(function (packageJson) {
                              if (!packageJson.name) {
                                pkgJsonsMissingNameField.push(
                                  path.relative(
                                    cwd,
                                    path.join(dir, 'package.json')
                                  )
                                )
                              }

                              return {
                                packageJson: packageJson,
                                dir: dir,
                              }
                            })
                            ['catch'](function (err) {
                              if (err.code === 'ENOENT') {
                                return null
                              }

                              throw err
                            })
                        })
                      )

                    case 49:
                      _context.t2 = function (x) {
                        return x
                      }

                      results = _context.sent.filter(_context.t2)

                      if (!(pkgJsonsMissingNameField.length !== 0)) {
                        _context.next = 54
                        break
                      }

                      pkgJsonsMissingNameField.sort()
                      throw new PackageJsonMissingNameError(
                        pkgJsonsMissingNameField
                      )

                    case 54:
                      return _context.abrupt('return', {
                        tool: tool.type,
                        root: {
                          dir: cwd,
                          packageJson: pkg,
                        },
                        packages: results,
                      })

                    case 55:
                    case 'end':
                      return _context.stop()
                  }
                }
              },
              _callee,
              null,
              [
                [14, 21],
                [26, 33],
              ]
            )
          })
        )
        return _getPackages.apply(this, arguments)
      }

      function getPackagesSync(dir) {
        var cwd = findRoot.findRootSync(dir)
        var pkg = fs.readJsonSync(path.join(cwd, 'package.json'))
        var tool

        if (pkg.workspaces) {
          if (Array.isArray(pkg.workspaces)) {
            tool = {
              type: 'yarn',
              packageGlobs: pkg.workspaces,
            }
          } else if (pkg.workspaces.packages) {
            tool = {
              type: 'yarn',
              packageGlobs: pkg.workspaces.packages,
            }
          }
        } else if (pkg.bolt && pkg.bolt.workspaces) {
          tool = {
            type: 'bolt',
            packageGlobs: pkg.bolt.workspaces,
          }
        } else {
          try {
            var manifest = readYamlFile.sync(
              path.join(cwd, 'pnpm-workspace.yaml')
            )

            if (manifest && manifest.packages) {
              tool = {
                type: 'pnpm',
                packageGlobs: manifest.packages,
              }
            }
          } catch (err) {
            if (err.code !== 'ENOENT') {
              throw err
            }
          }

          if (!tool) {
            try {
              var lernaJson = fs.readJsonSync(path.join(cwd, 'lerna.json'))

              if (lernaJson) {
                tool = {
                  type: 'lerna',
                  packageGlobs: lernaJson.packages || ['packages/*'],
                }
              }
            } catch (err) {
              if (err.code !== 'ENOENT') {
                throw err
              }
            }
          }
        }

        if (!tool) {
          var root = {
            dir: cwd,
            packageJson: pkg,
          }

          if (!pkg.name) {
            throw new PackageJsonMissingNameError(['package.json'])
          }

          return {
            tool: 'root',
            root: root,
            packages: [root],
          }
        }

        var relativeDirectories = globby.sync(tool.packageGlobs, {
          cwd: cwd,
          onlyDirectories: true,
          expandDirectories: false,
          ignore: ['**/node_modules'],
        })
        var directories = relativeDirectories.map(function (p) {
          return path.resolve(cwd, p)
        })
        var pkgJsonsMissingNameField = []
        var results = directories
          .sort()
          .map(function (dir) {
            try {
              var packageJson = fs.readJsonSync(path.join(dir, 'package.json'))

              if (!packageJson.name) {
                pkgJsonsMissingNameField.push(
                  path.relative(cwd, path.join(dir, 'package.json'))
                )
              }

              return {
                packageJson: packageJson,
                dir: dir,
              }
            } catch (err) {
              if (err.code === 'ENOENT') return null
              throw err
            }
          })
          .filter(function (x) {
            return x
          })

        if (pkgJsonsMissingNameField.length !== 0) {
          pkgJsonsMissingNameField.sort()
          throw new PackageJsonMissingNameError(pkgJsonsMissingNameField)
        }

        return {
          tool: tool.type,
          root: {
            dir: cwd,
            packageJson: pkg,
          },
          packages: results,
        }
      }

      exports.PackageJsonMissingNameError = PackageJsonMissingNameError
      exports.getPackages = getPackages
      exports.getPackagesSync = getPackagesSync

      /***/
    },

    /***/ 8166: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      if (process.env.NODE_ENV === 'production') {
        module.exports = __nccwpck_require__(9871)
      } else {
        module.exports = __nccwpck_require__(1000)
      }

      /***/
    },

    /***/ 9871: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      function _interopDefault(ex) {
        return ex && 'object' == typeof ex && 'default' in ex ? ex.default : ex
      }

      Object.defineProperty(exports, '__esModule', {
        value: !0,
      })

      var _regeneratorRuntime = _interopDefault(__nccwpck_require__(7705)),
        _asyncToGenerator = _interopDefault(__nccwpck_require__(6093)),
        _classCallCheck = _interopDefault(__nccwpck_require__(931)),
        _possibleConstructorReturn = _interopDefault(__nccwpck_require__(4635)),
        _getPrototypeOf = _interopDefault(__nccwpck_require__(9244)),
        _inherits = _interopDefault(__nccwpck_require__(3078)),
        _wrapNativeSuper = _interopDefault(__nccwpck_require__(1068)),
        fs = _interopDefault(__nccwpck_require__(4858)),
        path = _interopDefault(__nccwpck_require__(1017)),
        globby = __nccwpck_require__(3398),
        globby__default = _interopDefault(globby),
        readYamlFile = __nccwpck_require__(2920),
        readYamlFile__default = _interopDefault(readYamlFile),
        findRoot = __nccwpck_require__(8482),
        PackageJsonMissingNameError = (function (_Error) {
          function PackageJsonMissingNameError(directories) {
            var _this
            return (
              _classCallCheck(this, PackageJsonMissingNameError),
              ((_this = _possibleConstructorReturn(
                this,
                _getPrototypeOf(PackageJsonMissingNameError).call(
                  this,
                  'The following package.jsons are missing the "name" field:\n'.concat(
                    directories.join('\n')
                  )
                )
              )).directories = directories),
              _this
            )
          }
          return (
            _inherits(PackageJsonMissingNameError, _Error),
            PackageJsonMissingNameError
          )
        })(_wrapNativeSuper(Error))

      function getPackages(_x) {
        return _getPackages.apply(this, arguments)
      }

      function _getPackages() {
        return (_getPackages = _asyncToGenerator(
          _regeneratorRuntime.mark(function _callee(dir) {
            var cwd,
              pkg,
              tool,
              manifest,
              lernaJson,
              root,
              relativeDirectories,
              directories,
              pkgJsonsMissingNameField,
              results
            return _regeneratorRuntime.wrap(
              function (_context) {
                for (;;)
                  switch ((_context.prev = _context.next)) {
                    case 0:
                      return (_context.next = 2), findRoot.findRoot(dir)

                    case 2:
                      return (
                        (cwd = _context.sent),
                        (_context.next = 5),
                        fs.readJson(path.join(cwd, 'package.json'))
                      )

                    case 5:
                      if (!(pkg = _context.sent).workspaces) {
                        _context.next = 10
                        break
                      }
                      Array.isArray(pkg.workspaces)
                        ? (tool = {
                            type: 'yarn',
                            packageGlobs: pkg.workspaces,
                          })
                        : pkg.workspaces.packages &&
                          (tool = {
                            type: 'yarn',
                            packageGlobs: pkg.workspaces.packages,
                          }),
                        (_context.next = 37)
                      break

                    case 10:
                      if (!pkg.bolt || !pkg.bolt.workspaces) {
                        _context.next = 14
                        break
                      }
                      ;(tool = {
                        type: 'bolt',
                        packageGlobs: pkg.bolt.workspaces,
                      }),
                        (_context.next = 37)
                      break

                    case 14:
                      return (
                        (_context.prev = 14),
                        (_context.next = 17),
                        readYamlFile__default(
                          path.join(cwd, 'pnpm-workspace.yaml')
                        )
                      )

                    case 17:
                      ;(manifest = _context.sent) &&
                        manifest.packages &&
                        (tool = {
                          type: 'pnpm',
                          packageGlobs: manifest.packages,
                        }),
                        (_context.next = 25)
                      break

                    case 21:
                      if (
                        ((_context.prev = 21),
                        (_context.t0 = _context.catch(14)),
                        'ENOENT' === _context.t0.code)
                      ) {
                        _context.next = 25
                        break
                      }
                      throw _context.t0

                    case 25:
                      if (tool) {
                        _context.next = 37
                        break
                      }
                      return (
                        (_context.prev = 26),
                        (_context.next = 29),
                        fs.readJson(path.join(cwd, 'lerna.json'))
                      )

                    case 29:
                      ;(lernaJson = _context.sent) &&
                        (tool = {
                          type: 'lerna',
                          packageGlobs: lernaJson.packages || ['packages/*'],
                        }),
                        (_context.next = 37)
                      break

                    case 33:
                      if (
                        ((_context.prev = 33),
                        (_context.t1 = _context.catch(26)),
                        'ENOENT' === _context.t1.code)
                      ) {
                        _context.next = 37
                        break
                      }
                      throw _context.t1

                    case 37:
                      if (tool) {
                        _context.next = 42
                        break
                      }
                      if (
                        ((root = {
                          dir: cwd,
                          packageJson: pkg,
                        }),
                        pkg.name)
                      ) {
                        _context.next = 41
                        break
                      }
                      throw new PackageJsonMissingNameError(['package.json'])

                    case 41:
                      return _context.abrupt('return', {
                        tool: 'root',
                        root: root,
                        packages: [root],
                      })

                    case 42:
                      return (
                        (_context.next = 44),
                        globby__default(tool.packageGlobs, {
                          cwd: cwd,
                          onlyDirectories: !0,
                          expandDirectories: !1,
                          ignore: ['**/node_modules'],
                        })
                      )

                    case 44:
                      return (
                        (relativeDirectories = _context.sent),
                        (directories = relativeDirectories.map(function (p) {
                          return path.resolve(cwd, p)
                        })),
                        (pkgJsonsMissingNameField = []),
                        (_context.next = 49),
                        Promise.all(
                          directories.sort().map(function (dir) {
                            return fs
                              .readJson(path.join(dir, 'package.json'))
                              .then(function (packageJson) {
                                return (
                                  packageJson.name ||
                                    pkgJsonsMissingNameField.push(
                                      path.relative(
                                        cwd,
                                        path.join(dir, 'package.json')
                                      )
                                    ),
                                  {
                                    packageJson: packageJson,
                                    dir: dir,
                                  }
                                )
                              })
                              .catch(function (err) {
                                if ('ENOENT' === err.code) return null
                                throw err
                              })
                          })
                        )
                      )

                    case 49:
                      if (
                        ((_context.t2 = function (x) {
                          return x
                        }),
                        (results = _context.sent.filter(_context.t2)),
                        0 === pkgJsonsMissingNameField.length)
                      ) {
                        _context.next = 54
                        break
                      }
                      throw (
                        (pkgJsonsMissingNameField.sort(),
                        new PackageJsonMissingNameError(
                          pkgJsonsMissingNameField
                        ))
                      )

                    case 54:
                      return _context.abrupt('return', {
                        tool: tool.type,
                        root: {
                          dir: cwd,
                          packageJson: pkg,
                        },
                        packages: results,
                      })

                    case 55:
                    case 'end':
                      return _context.stop()
                  }
              },
              _callee,
              null,
              [
                [14, 21],
                [26, 33],
              ]
            )
          })
        )).apply(this, arguments)
      }

      function getPackagesSync(dir) {
        var tool,
          cwd = findRoot.findRootSync(dir),
          pkg = fs.readJsonSync(path.join(cwd, 'package.json'))
        if (pkg.workspaces)
          Array.isArray(pkg.workspaces)
            ? (tool = {
                type: 'yarn',
                packageGlobs: pkg.workspaces,
              })
            : pkg.workspaces.packages &&
              (tool = {
                type: 'yarn',
                packageGlobs: pkg.workspaces.packages,
              })
        else if (pkg.bolt && pkg.bolt.workspaces)
          tool = {
            type: 'bolt',
            packageGlobs: pkg.bolt.workspaces,
          }
        else {
          try {
            var manifest = readYamlFile.sync(
              path.join(cwd, 'pnpm-workspace.yaml')
            )
            manifest &&
              manifest.packages &&
              (tool = {
                type: 'pnpm',
                packageGlobs: manifest.packages,
              })
          } catch (err) {
            if ('ENOENT' !== err.code) throw err
          }
          if (!tool)
            try {
              var lernaJson = fs.readJsonSync(path.join(cwd, 'lerna.json'))
              lernaJson &&
                (tool = {
                  type: 'lerna',
                  packageGlobs: lernaJson.packages || ['packages/*'],
                })
            } catch (err) {
              if ('ENOENT' !== err.code) throw err
            }
        }
        if (!tool) {
          var root = {
            dir: cwd,
            packageJson: pkg,
          }
          if (!pkg.name) throw new PackageJsonMissingNameError(['package.json'])
          return {
            tool: 'root',
            root: root,
            packages: [root],
          }
        }
        var directories = globby
            .sync(tool.packageGlobs, {
              cwd: cwd,
              onlyDirectories: !0,
              expandDirectories: !1,
              ignore: ['**/node_modules'],
            })
            .map(function (p) {
              return path.resolve(cwd, p)
            }),
          pkgJsonsMissingNameField = [],
          results = directories
            .sort()
            .map(function (dir) {
              try {
                var packageJson = fs.readJsonSync(
                  path.join(dir, 'package.json')
                )
                return (
                  packageJson.name ||
                    pkgJsonsMissingNameField.push(
                      path.relative(cwd, path.join(dir, 'package.json'))
                    ),
                  {
                    packageJson: packageJson,
                    dir: dir,
                  }
                )
              } catch (err) {
                if ('ENOENT' === err.code) return null
                throw err
              }
            })
            .filter(function (x) {
              return x
            })
        if (0 !== pkgJsonsMissingNameField.length)
          throw (
            (pkgJsonsMissingNameField.sort(),
            new PackageJsonMissingNameError(pkgJsonsMissingNameField))
          )
        return {
          tool: tool.type,
          root: {
            dir: cwd,
            packageJson: pkg,
          },
          packages: results,
        }
      }

      ;(exports.PackageJsonMissingNameError = PackageJsonMissingNameError),
        (exports.getPackages = getPackages),
        (exports.getPackagesSync = getPackagesSync)

      /***/
    },

    /***/ 7408: /***/ module => {
      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          )
        }

        return self
      }

      ;(module.exports = _assertThisInitialized),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 6093: /***/ module => {
      function asyncGeneratorStep(
        gen,
        resolve,
        reject,
        _next,
        _throw,
        key,
        arg
      ) {
        try {
          var info = gen[key](arg)
          var value = info.value
        } catch (error) {
          reject(error)
          return
        }

        if (info.done) {
          resolve(value)
        } else {
          Promise.resolve(value).then(_next, _throw)
        }
      }

      function _asyncToGenerator(fn) {
        return function () {
          var self = this,
            args = arguments
          return new Promise(function (resolve, reject) {
            var gen = fn.apply(self, args)

            function _next(value) {
              asyncGeneratorStep(
                gen,
                resolve,
                reject,
                _next,
                _throw,
                'next',
                value
              )
            }

            function _throw(err) {
              asyncGeneratorStep(
                gen,
                resolve,
                reject,
                _next,
                _throw,
                'throw',
                err
              )
            }

            _next(undefined)
          })
        }
      }

      ;(module.exports = _asyncToGenerator),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 931: /***/ module => {
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError('Cannot call a class as a function')
        }
      }

      ;(module.exports = _classCallCheck),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 1567: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      var setPrototypeOf = __nccwpck_require__(3282)

      var isNativeReflectConstruct = __nccwpck_require__(7049)

      function _construct(Parent, args, Class) {
        if (isNativeReflectConstruct()) {
          ;(module.exports = _construct = Reflect.construct),
            (module.exports.__esModule = true),
            (module.exports['default'] = module.exports)
        } else {
          ;(module.exports = _construct =
            function _construct(Parent, args, Class) {
              var a = [null]
              a.push.apply(a, args)
              var Constructor = Function.bind.apply(Parent, a)
              var instance = new Constructor()
              if (Class) setPrototypeOf(instance, Class.prototype)
              return instance
            }),
            (module.exports.__esModule = true),
            (module.exports['default'] = module.exports)
        }

        return _construct.apply(null, arguments)
      }

      ;(module.exports = _construct),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 9244: /***/ module => {
      function _getPrototypeOf(o) {
        ;(module.exports = _getPrototypeOf =
          Object.setPrototypeOf
            ? Object.getPrototypeOf
            : function _getPrototypeOf(o) {
                return o.__proto__ || Object.getPrototypeOf(o)
              }),
          (module.exports.__esModule = true),
          (module.exports['default'] = module.exports)
        return _getPrototypeOf(o)
      }

      ;(module.exports = _getPrototypeOf),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 3078: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      var setPrototypeOf = __nccwpck_require__(3282)

      function _inherits(subClass, superClass) {
        if (typeof superClass !== 'function' && superClass !== null) {
          throw new TypeError(
            'Super expression must either be null or a function'
          )
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true,
          },
        })
        Object.defineProperty(subClass, 'prototype', {
          writable: false,
        })
        if (superClass) setPrototypeOf(subClass, superClass)
      }

      ;(module.exports = _inherits),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 6033: /***/ module => {
      function _isNativeFunction(fn) {
        return Function.toString.call(fn).indexOf('[native code]') !== -1
      }

      ;(module.exports = _isNativeFunction),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 7049: /***/ module => {
      function _isNativeReflectConstruct() {
        if (typeof Reflect === 'undefined' || !Reflect.construct) return false
        if (Reflect.construct.sham) return false
        if (typeof Proxy === 'function') return true

        try {
          Boolean.prototype.valueOf.call(
            Reflect.construct(Boolean, [], function () {})
          )
          return true
        } catch (e) {
          return false
        }
      }

      ;(module.exports = _isNativeReflectConstruct),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 4635: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      var _typeof = __nccwpck_require__(3240)['default']

      var assertThisInitialized = __nccwpck_require__(7408)

      function _possibleConstructorReturn(self, call) {
        if (
          call &&
          (_typeof(call) === 'object' || typeof call === 'function')
        ) {
          return call
        } else if (call !== void 0) {
          throw new TypeError(
            'Derived constructors may only return object or undefined'
          )
        }

        return assertThisInitialized(self)
      }

      ;(module.exports = _possibleConstructorReturn),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 3282: /***/ module => {
      function _setPrototypeOf(o, p) {
        ;(module.exports = _setPrototypeOf =
          Object.setPrototypeOf ||
          function _setPrototypeOf(o, p) {
            o.__proto__ = p
            return o
          }),
          (module.exports.__esModule = true),
          (module.exports['default'] = module.exports)
        return _setPrototypeOf(o, p)
      }

      ;(module.exports = _setPrototypeOf),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 3240: /***/ module => {
      function _typeof(obj) {
        '@babel/helpers - typeof'

        return (
          ((module.exports = _typeof =
            'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
              ? function (obj) {
                  return typeof obj
                }
              : function (obj) {
                  return obj &&
                    'function' == typeof Symbol &&
                    obj.constructor === Symbol &&
                    obj !== Symbol.prototype
                    ? 'symbol'
                    : typeof obj
                }),
          (module.exports.__esModule = true),
          (module.exports['default'] = module.exports)),
          _typeof(obj)
        )
      }

      ;(module.exports = _typeof),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 1068: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      var getPrototypeOf = __nccwpck_require__(9244)

      var setPrototypeOf = __nccwpck_require__(3282)

      var isNativeFunction = __nccwpck_require__(6033)

      var construct = __nccwpck_require__(1567)

      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === 'function' ? new Map() : undefined

        ;(module.exports = _wrapNativeSuper =
          function _wrapNativeSuper(Class) {
            if (Class === null || !isNativeFunction(Class)) return Class

            if (typeof Class !== 'function') {
              throw new TypeError(
                'Super expression must either be null or a function'
              )
            }

            if (typeof _cache !== 'undefined') {
              if (_cache.has(Class)) return _cache.get(Class)

              _cache.set(Class, Wrapper)
            }

            function Wrapper() {
              return construct(
                Class,
                arguments,
                getPrototypeOf(this).constructor
              )
            }

            Wrapper.prototype = Object.create(Class.prototype, {
              constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true,
              },
            })
            return setPrototypeOf(Wrapper, Class)
          }),
          (module.exports.__esModule = true),
          (module.exports['default'] = module.exports)
        return _wrapNativeSuper(Class)
      }

      ;(module.exports = _wrapNativeSuper),
        (module.exports.__esModule = true),
        (module.exports['default'] = module.exports)

      /***/
    },

    /***/ 7705: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      module.exports = __nccwpck_require__(4307)

      /***/
    },

    /***/ 7068: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const mkdirpSync = __nccwpck_require__(8719).mkdirsSync
      const utimesSync = __nccwpck_require__(6001).utimesMillisSync
      const stat = __nccwpck_require__(5056)

      function copySync(src, dest, opts) {
        if (typeof opts === 'function') {
          opts = { filter: opts }
        }

        opts = opts || {}
        opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now
        opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber

        // Warn about using preserveTimestamps on 32-bit node
        if (opts.preserveTimestamps && process.arch === 'ia32') {
          console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`)
        }

        const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy')
        stat.checkParentPathsSync(src, srcStat, dest, 'copy')
        return handleFilterAndCopy(destStat, src, dest, opts)
      }

      function handleFilterAndCopy(destStat, src, dest, opts) {
        if (opts.filter && !opts.filter(src, dest)) return
        const destParent = path.dirname(dest)
        if (!fs.existsSync(destParent)) mkdirpSync(destParent)
        return startCopy(destStat, src, dest, opts)
      }

      function startCopy(destStat, src, dest, opts) {
        if (opts.filter && !opts.filter(src, dest)) return
        return getStats(destStat, src, dest, opts)
      }

      function getStats(destStat, src, dest, opts) {
        const statSync = opts.dereference ? fs.statSync : fs.lstatSync
        const srcStat = statSync(src)

        if (srcStat.isDirectory())
          return onDir(srcStat, destStat, src, dest, opts)
        else if (
          srcStat.isFile() ||
          srcStat.isCharacterDevice() ||
          srcStat.isBlockDevice()
        )
          return onFile(srcStat, destStat, src, dest, opts)
        else if (srcStat.isSymbolicLink())
          return onLink(destStat, src, dest, opts)
      }

      function onFile(srcStat, destStat, src, dest, opts) {
        if (!destStat) return copyFile(srcStat, src, dest, opts)
        return mayCopyFile(srcStat, src, dest, opts)
      }

      function mayCopyFile(srcStat, src, dest, opts) {
        if (opts.overwrite) {
          fs.unlinkSync(dest)
          return copyFile(srcStat, src, dest, opts)
        } else if (opts.errorOnExist) {
          throw new Error(`'${dest}' already exists`)
        }
      }

      function copyFile(srcStat, src, dest, opts) {
        if (typeof fs.copyFileSync === 'function') {
          fs.copyFileSync(src, dest)
          fs.chmodSync(dest, srcStat.mode)
          if (opts.preserveTimestamps) {
            return utimesSync(dest, srcStat.atime, srcStat.mtime)
          }
          return
        }
        return copyFileFallback(srcStat, src, dest, opts)
      }

      function copyFileFallback(srcStat, src, dest, opts) {
        const BUF_LENGTH = 64 * 1024
        const _buff = __nccwpck_require__(9425)(BUF_LENGTH)

        const fdr = fs.openSync(src, 'r')
        const fdw = fs.openSync(dest, 'w', srcStat.mode)
        let pos = 0

        while (pos < srcStat.size) {
          const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)
          fs.writeSync(fdw, _buff, 0, bytesRead)
          pos += bytesRead
        }

        if (opts.preserveTimestamps)
          fs.futimesSync(fdw, srcStat.atime, srcStat.mtime)

        fs.closeSync(fdr)
        fs.closeSync(fdw)
      }

      function onDir(srcStat, destStat, src, dest, opts) {
        if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts)
        if (destStat && !destStat.isDirectory()) {
          throw new Error(
            `Cannot overwrite non-directory '${dest}' with directory '${src}'.`
          )
        }
        return copyDir(src, dest, opts)
      }

      function mkDirAndCopy(srcStat, src, dest, opts) {
        fs.mkdirSync(dest)
        copyDir(src, dest, opts)
        return fs.chmodSync(dest, srcStat.mode)
      }

      function copyDir(src, dest, opts) {
        fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))
      }

      function copyDirItem(item, src, dest, opts) {
        const srcItem = path.join(src, item)
        const destItem = path.join(dest, item)
        const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy')
        return startCopy(destStat, srcItem, destItem, opts)
      }

      function onLink(destStat, src, dest, opts) {
        let resolvedSrc = fs.readlinkSync(src)
        if (opts.dereference) {
          resolvedSrc = path.resolve(process.cwd(), resolvedSrc)
        }

        if (!destStat) {
          return fs.symlinkSync(resolvedSrc, dest)
        } else {
          let resolvedDest
          try {
            resolvedDest = fs.readlinkSync(dest)
          } catch (err) {
            // dest exists and is a regular file or directory,
            // Windows may throw UNKNOWN error. If dest already exists,
            // fs throws error anyway, so no need to guard against it here.
            if (err.code === 'EINVAL' || err.code === 'UNKNOWN')
              return fs.symlinkSync(resolvedSrc, dest)
            throw err
          }
          if (opts.dereference) {
            resolvedDest = path.resolve(process.cwd(), resolvedDest)
          }
          if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
            throw new Error(
              `Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`
            )
          }

          // prevent copy if src is a subdir of dest since unlinking
          // dest in this case would result in removing src contents
          // and therefore a broken symlink would be created.
          if (
            fs.statSync(dest).isDirectory() &&
            stat.isSrcSubdir(resolvedDest, resolvedSrc)
          ) {
            throw new Error(
              `Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`
            )
          }
          return copyLink(resolvedSrc, dest)
        }
      }

      function copyLink(resolvedSrc, dest) {
        fs.unlinkSync(dest)
        return fs.symlinkSync(resolvedSrc, dest)
      }

      module.exports = copySync

      /***/
    },

    /***/ 5341: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      module.exports = {
        copySync: __nccwpck_require__(7068),
      }

      /***/
    },

    /***/ 6557: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const mkdirp = __nccwpck_require__(8719).mkdirs
      const pathExists = __nccwpck_require__(7716).pathExists
      const utimes = __nccwpck_require__(6001).utimesMillis
      const stat = __nccwpck_require__(5056)

      function copy(src, dest, opts, cb) {
        if (typeof opts === 'function' && !cb) {
          cb = opts
          opts = {}
        } else if (typeof opts === 'function') {
          opts = { filter: opts }
        }

        cb = cb || function () {}
        opts = opts || {}

        opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now
        opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber

        // Warn about using preserveTimestamps on 32-bit node
        if (opts.preserveTimestamps && process.arch === 'ia32') {
          console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`)
        }

        stat.checkPaths(src, dest, 'copy', (err, stats) => {
          if (err) return cb(err)
          const { srcStat, destStat } = stats
          stat.checkParentPaths(src, srcStat, dest, 'copy', err => {
            if (err) return cb(err)
            if (opts.filter)
              return handleFilter(checkParentDir, destStat, src, dest, opts, cb)
            return checkParentDir(destStat, src, dest, opts, cb)
          })
        })
      }

      function checkParentDir(destStat, src, dest, opts, cb) {
        const destParent = path.dirname(dest)
        pathExists(destParent, (err, dirExists) => {
          if (err) return cb(err)
          if (dirExists) return startCopy(destStat, src, dest, opts, cb)
          mkdirp(destParent, err => {
            if (err) return cb(err)
            return startCopy(destStat, src, dest, opts, cb)
          })
        })
      }

      function handleFilter(onInclude, destStat, src, dest, opts, cb) {
        Promise.resolve(opts.filter(src, dest)).then(
          include => {
            if (include) return onInclude(destStat, src, dest, opts, cb)
            return cb()
          },
          error => cb(error)
        )
      }

      function startCopy(destStat, src, dest, opts, cb) {
        if (opts.filter)
          return handleFilter(getStats, destStat, src, dest, opts, cb)
        return getStats(destStat, src, dest, opts, cb)
      }

      function getStats(destStat, src, dest, opts, cb) {
        const stat = opts.dereference ? fs.stat : fs.lstat
        stat(src, (err, srcStat) => {
          if (err) return cb(err)

          if (srcStat.isDirectory())
            return onDir(srcStat, destStat, src, dest, opts, cb)
          else if (
            srcStat.isFile() ||
            srcStat.isCharacterDevice() ||
            srcStat.isBlockDevice()
          )
            return onFile(srcStat, destStat, src, dest, opts, cb)
          else if (srcStat.isSymbolicLink())
            return onLink(destStat, src, dest, opts, cb)
        })
      }

      function onFile(srcStat, destStat, src, dest, opts, cb) {
        if (!destStat) return copyFile(srcStat, src, dest, opts, cb)
        return mayCopyFile(srcStat, src, dest, opts, cb)
      }

      function mayCopyFile(srcStat, src, dest, opts, cb) {
        if (opts.overwrite) {
          fs.unlink(dest, err => {
            if (err) return cb(err)
            return copyFile(srcStat, src, dest, opts, cb)
          })
        } else if (opts.errorOnExist) {
          return cb(new Error(`'${dest}' already exists`))
        } else return cb()
      }

      function copyFile(srcStat, src, dest, opts, cb) {
        if (typeof fs.copyFile === 'function') {
          return fs.copyFile(src, dest, err => {
            if (err) return cb(err)
            return setDestModeAndTimestamps(srcStat, dest, opts, cb)
          })
        }
        return copyFileFallback(srcStat, src, dest, opts, cb)
      }

      function copyFileFallback(srcStat, src, dest, opts, cb) {
        const rs = fs.createReadStream(src)
        rs.on('error', err => cb(err)).once('open', () => {
          const ws = fs.createWriteStream(dest, { mode: srcStat.mode })
          ws.on('error', err => cb(err))
            .on('open', () => rs.pipe(ws))
            .once('close', () =>
              setDestModeAndTimestamps(srcStat, dest, opts, cb)
            )
        })
      }

      function setDestModeAndTimestamps(srcStat, dest, opts, cb) {
        fs.chmod(dest, srcStat.mode, err => {
          if (err) return cb(err)
          if (opts.preserveTimestamps) {
            return utimes(dest, srcStat.atime, srcStat.mtime, cb)
          }
          return cb()
        })
      }

      function onDir(srcStat, destStat, src, dest, opts, cb) {
        if (!destStat) return mkDirAndCopy(srcStat, src, dest, opts, cb)
        if (destStat && !destStat.isDirectory()) {
          return cb(
            new Error(
              `Cannot overwrite non-directory '${dest}' with directory '${src}'.`
            )
          )
        }
        return copyDir(src, dest, opts, cb)
      }

      function mkDirAndCopy(srcStat, src, dest, opts, cb) {
        fs.mkdir(dest, err => {
          if (err) return cb(err)
          copyDir(src, dest, opts, err => {
            if (err) return cb(err)
            return fs.chmod(dest, srcStat.mode, cb)
          })
        })
      }

      function copyDir(src, dest, opts, cb) {
        fs.readdir(src, (err, items) => {
          if (err) return cb(err)
          return copyDirItems(items, src, dest, opts, cb)
        })
      }

      function copyDirItems(items, src, dest, opts, cb) {
        const item = items.pop()
        if (!item) return cb()
        return copyDirItem(items, item, src, dest, opts, cb)
      }

      function copyDirItem(items, item, src, dest, opts, cb) {
        const srcItem = path.join(src, item)
        const destItem = path.join(dest, item)
        stat.checkPaths(srcItem, destItem, 'copy', (err, stats) => {
          if (err) return cb(err)
          const { destStat } = stats
          startCopy(destStat, srcItem, destItem, opts, err => {
            if (err) return cb(err)
            return copyDirItems(items, src, dest, opts, cb)
          })
        })
      }

      function onLink(destStat, src, dest, opts, cb) {
        fs.readlink(src, (err, resolvedSrc) => {
          if (err) return cb(err)
          if (opts.dereference) {
            resolvedSrc = path.resolve(process.cwd(), resolvedSrc)
          }

          if (!destStat) {
            return fs.symlink(resolvedSrc, dest, cb)
          } else {
            fs.readlink(dest, (err, resolvedDest) => {
              if (err) {
                // dest exists and is a regular file or directory,
                // Windows may throw UNKNOWN error. If dest already exists,
                // fs throws error anyway, so no need to guard against it here.
                if (err.code === 'EINVAL' || err.code === 'UNKNOWN')
                  return fs.symlink(resolvedSrc, dest, cb)
                return cb(err)
              }
              if (opts.dereference) {
                resolvedDest = path.resolve(process.cwd(), resolvedDest)
              }
              if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
                return cb(
                  new Error(
                    `Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`
                  )
                )
              }

              // do not copy if src is a subdir of dest since unlinking
              // dest in this case would result in removing src contents
              // and therefore a broken symlink would be created.
              if (
                destStat.isDirectory() &&
                stat.isSrcSubdir(resolvedDest, resolvedSrc)
              ) {
                return cb(
                  new Error(
                    `Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`
                  )
                )
              }
              return copyLink(resolvedSrc, dest, cb)
            })
          }
        })
      }

      function copyLink(resolvedSrc, dest, cb) {
        fs.unlink(dest, err => {
          if (err) return cb(err)
          return fs.symlink(resolvedSrc, dest, cb)
        })
      }

      module.exports = copy

      /***/
    },

    /***/ 4794: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      module.exports = {
        copy: u(__nccwpck_require__(6557)),
      }

      /***/
    },

    /***/ 7655: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const mkdir = __nccwpck_require__(8719)
      const remove = __nccwpck_require__(7799)

      const emptyDir = u(function emptyDir(dir, callback) {
        callback = callback || function () {}
        fs.readdir(dir, (err, items) => {
          if (err) return mkdir.mkdirs(dir, callback)

          items = items.map(item => path.join(dir, item))

          deleteItem()

          function deleteItem() {
            const item = items.pop()
            if (!item) return callback()
            remove.remove(item, err => {
              if (err) return callback(err)
              deleteItem()
            })
          }
        })
      })

      function emptyDirSync(dir) {
        let items
        try {
          items = fs.readdirSync(dir)
        } catch (err) {
          return mkdir.mkdirsSync(dir)
        }

        items.forEach(item => {
          item = path.join(dir, item)
          remove.removeSync(item)
        })
      }

      module.exports = {
        emptyDirSync,
        emptydirSync: emptyDirSync,
        emptyDir,
        emptydir: emptyDir,
      }

      /***/
    },

    /***/ 2413: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const path = __nccwpck_require__(1017)
      const fs = __nccwpck_require__(7758)
      const mkdir = __nccwpck_require__(8719)
      const pathExists = __nccwpck_require__(7716).pathExists

      function createFile(file, callback) {
        function makeFile() {
          fs.writeFile(file, '', err => {
            if (err) return callback(err)
            callback()
          })
        }

        fs.stat(file, (err, stats) => {
          // eslint-disable-line handle-callback-err
          if (!err && stats.isFile()) return callback()
          const dir = path.dirname(file)
          pathExists(dir, (err, dirExists) => {
            if (err) return callback(err)
            if (dirExists) return makeFile()
            mkdir.mkdirs(dir, err => {
              if (err) return callback(err)
              makeFile()
            })
          })
        })
      }

      function createFileSync(file) {
        let stats
        try {
          stats = fs.statSync(file)
        } catch (e) {}
        if (stats && stats.isFile()) return

        const dir = path.dirname(file)
        if (!fs.existsSync(dir)) {
          mkdir.mkdirsSync(dir)
        }

        fs.writeFileSync(file, '')
      }

      module.exports = {
        createFile: u(createFile),
        createFileSync,
      }

      /***/
    },

    /***/ 2952: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const file = __nccwpck_require__(2413)
      const link = __nccwpck_require__(6589)
      const symlink = __nccwpck_require__(761)

      module.exports = {
        // file
        createFile: file.createFile,
        createFileSync: file.createFileSync,
        ensureFile: file.createFile,
        ensureFileSync: file.createFileSync,
        // link
        createLink: link.createLink,
        createLinkSync: link.createLinkSync,
        ensureLink: link.createLink,
        ensureLinkSync: link.createLinkSync,
        // symlink
        createSymlink: symlink.createSymlink,
        createSymlinkSync: symlink.createSymlinkSync,
        ensureSymlink: symlink.createSymlink,
        ensureSymlinkSync: symlink.createSymlinkSync,
      }

      /***/
    },

    /***/ 6589: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const path = __nccwpck_require__(1017)
      const fs = __nccwpck_require__(7758)
      const mkdir = __nccwpck_require__(8719)
      const pathExists = __nccwpck_require__(7716).pathExists

      function createLink(srcpath, dstpath, callback) {
        function makeLink(srcpath, dstpath) {
          fs.link(srcpath, dstpath, err => {
            if (err) return callback(err)
            callback(null)
          })
        }

        pathExists(dstpath, (err, destinationExists) => {
          if (err) return callback(err)
          if (destinationExists) return callback(null)
          fs.lstat(srcpath, err => {
            if (err) {
              err.message = err.message.replace('lstat', 'ensureLink')
              return callback(err)
            }

            const dir = path.dirname(dstpath)
            pathExists(dir, (err, dirExists) => {
              if (err) return callback(err)
              if (dirExists) return makeLink(srcpath, dstpath)
              mkdir.mkdirs(dir, err => {
                if (err) return callback(err)
                makeLink(srcpath, dstpath)
              })
            })
          })
        })
      }

      function createLinkSync(srcpath, dstpath) {
        const destinationExists = fs.existsSync(dstpath)
        if (destinationExists) return undefined

        try {
          fs.lstatSync(srcpath)
        } catch (err) {
          err.message = err.message.replace('lstat', 'ensureLink')
          throw err
        }

        const dir = path.dirname(dstpath)
        const dirExists = fs.existsSync(dir)
        if (dirExists) return fs.linkSync(srcpath, dstpath)
        mkdir.mkdirsSync(dir)

        return fs.linkSync(srcpath, dstpath)
      }

      module.exports = {
        createLink: u(createLink),
        createLinkSync,
      }

      /***/
    },

    /***/ 2036: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const path = __nccwpck_require__(1017)
      const fs = __nccwpck_require__(7758)
      const pathExists = __nccwpck_require__(7716).pathExists

      /**
       * Function that returns two types of paths, one relative to symlink, and one
       * relative to the current working directory. Checks if path is absolute or
       * relative. If the path is relative, this function checks if the path is
       * relative to symlink or relative to current working directory. This is an
       * initiative to find a smarter `srcpath` to supply when building symlinks.
       * This allows you to determine which path to use out of one of three possible
       * types of source paths. The first is an absolute path. This is detected by
       * `path.isAbsolute()`. When an absolute path is provided, it is checked to
       * see if it exists. If it does it's used, if not an error is returned
       * (callback)/ thrown (sync). The other two options for `srcpath` are a
       * relative url. By default Node's `fs.symlink` works by creating a symlink
       * using `dstpath` and expects the `srcpath` to be relative to the newly
       * created symlink. If you provide a `srcpath` that does not exist on the file
       * system it results in a broken symlink. To minimize this, the function
       * checks to see if the 'relative to symlink' source file exists, and if it
       * does it will use it. If it does not, it checks if there's a file that
       * exists that is relative to the current working directory, if does its used.
       * This preserves the expectations of the original fs.symlink spec and adds
       * the ability to pass in `relative to current working direcotry` paths.
       */

      function symlinkPaths(srcpath, dstpath, callback) {
        if (path.isAbsolute(srcpath)) {
          return fs.lstat(srcpath, err => {
            if (err) {
              err.message = err.message.replace('lstat', 'ensureSymlink')
              return callback(err)
            }
            return callback(null, {
              toCwd: srcpath,
              toDst: srcpath,
            })
          })
        } else {
          const dstdir = path.dirname(dstpath)
          const relativeToDst = path.join(dstdir, srcpath)
          return pathExists(relativeToDst, (err, exists) => {
            if (err) return callback(err)
            if (exists) {
              return callback(null, {
                toCwd: relativeToDst,
                toDst: srcpath,
              })
            } else {
              return fs.lstat(srcpath, err => {
                if (err) {
                  err.message = err.message.replace('lstat', 'ensureSymlink')
                  return callback(err)
                }
                return callback(null, {
                  toCwd: srcpath,
                  toDst: path.relative(dstdir, srcpath),
                })
              })
            }
          })
        }
      }

      function symlinkPathsSync(srcpath, dstpath) {
        let exists
        if (path.isAbsolute(srcpath)) {
          exists = fs.existsSync(srcpath)
          if (!exists) throw new Error('absolute srcpath does not exist')
          return {
            toCwd: srcpath,
            toDst: srcpath,
          }
        } else {
          const dstdir = path.dirname(dstpath)
          const relativeToDst = path.join(dstdir, srcpath)
          exists = fs.existsSync(relativeToDst)
          if (exists) {
            return {
              toCwd: relativeToDst,
              toDst: srcpath,
            }
          } else {
            exists = fs.existsSync(srcpath)
            if (!exists) throw new Error('relative srcpath does not exist')
            return {
              toCwd: srcpath,
              toDst: path.relative(dstdir, srcpath),
            }
          }
        }
      }

      module.exports = {
        symlinkPaths,
        symlinkPathsSync,
      }

      /***/
    },

    /***/ 3217: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)

      function symlinkType(srcpath, type, callback) {
        callback = typeof type === 'function' ? type : callback
        type = typeof type === 'function' ? false : type
        if (type) return callback(null, type)
        fs.lstat(srcpath, (err, stats) => {
          if (err) return callback(null, 'file')
          type = stats && stats.isDirectory() ? 'dir' : 'file'
          callback(null, type)
        })
      }

      function symlinkTypeSync(srcpath, type) {
        let stats

        if (type) return type
        try {
          stats = fs.lstatSync(srcpath)
        } catch (e) {
          return 'file'
        }
        return stats && stats.isDirectory() ? 'dir' : 'file'
      }

      module.exports = {
        symlinkType,
        symlinkTypeSync,
      }

      /***/
    },

    /***/ 761: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const path = __nccwpck_require__(1017)
      const fs = __nccwpck_require__(7758)
      const _mkdirs = __nccwpck_require__(8719)
      const mkdirs = _mkdirs.mkdirs
      const mkdirsSync = _mkdirs.mkdirsSync

      const _symlinkPaths = __nccwpck_require__(2036)
      const symlinkPaths = _symlinkPaths.symlinkPaths
      const symlinkPathsSync = _symlinkPaths.symlinkPathsSync

      const _symlinkType = __nccwpck_require__(3217)
      const symlinkType = _symlinkType.symlinkType
      const symlinkTypeSync = _symlinkType.symlinkTypeSync

      const pathExists = __nccwpck_require__(7716).pathExists

      function createSymlink(srcpath, dstpath, type, callback) {
        callback = typeof type === 'function' ? type : callback
        type = typeof type === 'function' ? false : type

        pathExists(dstpath, (err, destinationExists) => {
          if (err) return callback(err)
          if (destinationExists) return callback(null)
          symlinkPaths(srcpath, dstpath, (err, relative) => {
            if (err) return callback(err)
            srcpath = relative.toDst
            symlinkType(relative.toCwd, type, (err, type) => {
              if (err) return callback(err)
              const dir = path.dirname(dstpath)
              pathExists(dir, (err, dirExists) => {
                if (err) return callback(err)
                if (dirExists)
                  return fs.symlink(srcpath, dstpath, type, callback)
                mkdirs(dir, err => {
                  if (err) return callback(err)
                  fs.symlink(srcpath, dstpath, type, callback)
                })
              })
            })
          })
        })
      }

      function createSymlinkSync(srcpath, dstpath, type) {
        const destinationExists = fs.existsSync(dstpath)
        if (destinationExists) return undefined

        const relative = symlinkPathsSync(srcpath, dstpath)
        srcpath = relative.toDst
        type = symlinkTypeSync(relative.toCwd, type)
        const dir = path.dirname(dstpath)
        const exists = fs.existsSync(dir)
        if (exists) return fs.symlinkSync(srcpath, dstpath, type)
        mkdirsSync(dir)
        return fs.symlinkSync(srcpath, dstpath, type)
      }

      module.exports = {
        createSymlink: u(createSymlink),
        createSymlinkSync,
      }

      /***/
    },

    /***/ 705: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      // This is adapted from https://github.com/normalize/mz
      // Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const fs = __nccwpck_require__(7758)

      const api = [
        'access',
        'appendFile',
        'chmod',
        'chown',
        'close',
        'copyFile',
        'fchmod',
        'fchown',
        'fdatasync',
        'fstat',
        'fsync',
        'ftruncate',
        'futimes',
        'lchown',
        'lchmod',
        'link',
        'lstat',
        'mkdir',
        'mkdtemp',
        'open',
        'readFile',
        'readdir',
        'readlink',
        'realpath',
        'rename',
        'rmdir',
        'stat',
        'symlink',
        'truncate',
        'unlink',
        'utimes',
        'writeFile',
      ].filter(key => {
        // Some commands are not available on some systems. Ex:
        // fs.copyFile was added in Node.js v8.5.0
        // fs.mkdtemp was added in Node.js v5.10.0
        // fs.lchown is not available on at least some Linux
        return typeof fs[key] === 'function'
      })

      // Export all keys:
      Object.keys(fs).forEach(key => {
        if (key === 'promises') {
          // fs.promises is a getter property that triggers ExperimentalWarning
          // Don't re-export it here, the getter is defined in "lib/index.js"
          return
        }
        exports[key] = fs[key]
      })

      // Universalify async methods:
      api.forEach(method => {
        exports[method] = u(fs[method])
      })

      // We differ from mz/fs in that we still ship the old, broken, fs.exists()
      // since we are a drop-in replacement for the native module
      exports.exists = function (filename, callback) {
        if (typeof callback === 'function') {
          return fs.exists(filename, callback)
        }
        return new Promise(resolve => {
          return fs.exists(filename, resolve)
        })
      }

      // fs.read() & fs.write need special treatment due to multiple callback args

      exports.read = function (fd, buffer, offset, length, position, callback) {
        if (typeof callback === 'function') {
          return fs.read(fd, buffer, offset, length, position, callback)
        }
        return new Promise((resolve, reject) => {
          fs.read(
            fd,
            buffer,
            offset,
            length,
            position,
            (err, bytesRead, buffer) => {
              if (err) return reject(err)
              resolve({ bytesRead, buffer })
            }
          )
        })
      }

      // Function signature can be
      // fs.write(fd, buffer[, offset[, length[, position]]], callback)
      // OR
      // fs.write(fd, string[, position[, encoding]], callback)
      // We need to handle both cases, so we use ...args
      exports.write = function (fd, buffer, ...args) {
        if (typeof args[args.length - 1] === 'function') {
          return fs.write(fd, buffer, ...args)
        }

        return new Promise((resolve, reject) => {
          fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
            if (err) return reject(err)
            resolve({ bytesWritten, buffer })
          })
        })
      }

      // fs.realpath.native only available in Node v9.2+
      if (typeof fs.realpath.native === 'function') {
        exports.realpath.native = u(fs.realpath.native)
      }

      /***/
    },

    /***/ 4858: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      module.exports = Object.assign(
        {},
        // Export promiseified graceful-fs:
        __nccwpck_require__(705),
        // Export extra methods:
        __nccwpck_require__(5341),
        __nccwpck_require__(4794),
        __nccwpck_require__(7655),
        __nccwpck_require__(2952),
        __nccwpck_require__(6434),
        __nccwpck_require__(8719),
        __nccwpck_require__(5619),
        __nccwpck_require__(4204),
        __nccwpck_require__(3652),
        __nccwpck_require__(7716),
        __nccwpck_require__(7799)
      )

      // Export fs.promises as a getter property so that we don't trigger
      // ExperimentalWarning before fs.promises is actually accessed.
      const fs = __nccwpck_require__(7147)
      if (Object.getOwnPropertyDescriptor(fs, 'promises')) {
        Object.defineProperty(module.exports, 'promises', {
          get() {
            return fs.promises
          },
        })
      }

      /***/
    },

    /***/ 6434: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const jsonFile = __nccwpck_require__(3834)

      jsonFile.outputJson = u(__nccwpck_require__(820))
      jsonFile.outputJsonSync = __nccwpck_require__(7286)
      // aliases
      jsonFile.outputJSON = jsonFile.outputJson
      jsonFile.outputJSONSync = jsonFile.outputJsonSync
      jsonFile.writeJSON = jsonFile.writeJson
      jsonFile.writeJSONSync = jsonFile.writeJsonSync
      jsonFile.readJSON = jsonFile.readJson
      jsonFile.readJSONSync = jsonFile.readJsonSync

      module.exports = jsonFile

      /***/
    },

    /***/ 3834: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const jsonFile = __nccwpck_require__(6160)

      module.exports = {
        // jsonfile exports
        readJson: u(jsonFile.readFile),
        readJsonSync: jsonFile.readFileSync,
        writeJson: u(jsonFile.writeFile),
        writeJsonSync: jsonFile.writeFileSync,
      }

      /***/
    },

    /***/ 7286: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const mkdir = __nccwpck_require__(8719)
      const jsonFile = __nccwpck_require__(3834)

      function outputJsonSync(file, data, options) {
        const dir = path.dirname(file)

        if (!fs.existsSync(dir)) {
          mkdir.mkdirsSync(dir)
        }

        jsonFile.writeJsonSync(file, data, options)
      }

      module.exports = outputJsonSync

      /***/
    },

    /***/ 820: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const path = __nccwpck_require__(1017)
      const mkdir = __nccwpck_require__(8719)
      const pathExists = __nccwpck_require__(7716).pathExists
      const jsonFile = __nccwpck_require__(3834)

      function outputJson(file, data, options, callback) {
        if (typeof options === 'function') {
          callback = options
          options = {}
        }

        const dir = path.dirname(file)

        pathExists(dir, (err, itDoes) => {
          if (err) return callback(err)
          if (itDoes) return jsonFile.writeJson(file, data, options, callback)

          mkdir.mkdirs(dir, err => {
            if (err) return callback(err)
            jsonFile.writeJson(file, data, options, callback)
          })
        })
      }

      module.exports = outputJson

      /***/
    },

    /***/ 8719: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const mkdirs = u(__nccwpck_require__(2625))
      const mkdirsSync = __nccwpck_require__(3400)

      module.exports = {
        mkdirs,
        mkdirsSync,
        // alias
        mkdirp: mkdirs,
        mkdirpSync: mkdirsSync,
        ensureDir: mkdirs,
        ensureDirSync: mkdirsSync,
      }

      /***/
    },

    /***/ 3400: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const invalidWin32Path = __nccwpck_require__(9089).invalidWin32Path

      const o777 = parseInt('0777', 8)

      function mkdirsSync(p, opts, made) {
        if (!opts || typeof opts !== 'object') {
          opts = { mode: opts }
        }

        let mode = opts.mode
        const xfs = opts.fs || fs

        if (process.platform === 'win32' && invalidWin32Path(p)) {
          const errInval = new Error(
            p + ' contains invalid WIN32 path characters.'
          )
          errInval.code = 'EINVAL'
          throw errInval
        }

        if (mode === undefined) {
          mode = o777 & ~process.umask()
        }
        if (!made) made = null

        p = path.resolve(p)

        try {
          xfs.mkdirSync(p, mode)
          made = made || p
        } catch (err0) {
          if (err0.code === 'ENOENT') {
            if (path.dirname(p) === p) throw err0
            made = mkdirsSync(path.dirname(p), opts, made)
            mkdirsSync(p, opts, made)
          } else {
            // In the case of any other error, just see if there's a dir there
            // already. If so, then hooray!  If not, then something is borked.
            let stat
            try {
              stat = xfs.statSync(p)
            } catch (err1) {
              throw err0
            }
            if (!stat.isDirectory()) throw err0
          }
        }

        return made
      }

      module.exports = mkdirsSync

      /***/
    },

    /***/ 2625: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const invalidWin32Path = __nccwpck_require__(9089).invalidWin32Path

      const o777 = parseInt('0777', 8)

      function mkdirs(p, opts, callback, made) {
        if (typeof opts === 'function') {
          callback = opts
          opts = {}
        } else if (!opts || typeof opts !== 'object') {
          opts = { mode: opts }
        }

        if (process.platform === 'win32' && invalidWin32Path(p)) {
          const errInval = new Error(
            p + ' contains invalid WIN32 path characters.'
          )
          errInval.code = 'EINVAL'
          return callback(errInval)
        }

        let mode = opts.mode
        const xfs = opts.fs || fs

        if (mode === undefined) {
          mode = o777 & ~process.umask()
        }
        if (!made) made = null

        callback = callback || function () {}
        p = path.resolve(p)

        xfs.mkdir(p, mode, er => {
          if (!er) {
            made = made || p
            return callback(null, made)
          }
          switch (er.code) {
            case 'ENOENT':
              if (path.dirname(p) === p) return callback(er)
              mkdirs(path.dirname(p), opts, (er, made) => {
                if (er) callback(er, made)
                else mkdirs(p, opts, callback, made)
              })
              break

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
              xfs.stat(p, (er2, stat) => {
                // if the stat fails, then that's super weird.
                // let the original error be the failure reason.
                if (er2 || !stat.isDirectory()) callback(er, made)
                else callback(null, made)
              })
              break
          }
        })
      }

      module.exports = mkdirs

      /***/
    },

    /***/ 9089: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const path = __nccwpck_require__(1017)

      // get drive on windows
      function getRootPath(p) {
        p = path.normalize(path.resolve(p)).split(path.sep)
        if (p.length > 0) return p[0]
        return null
      }

      // http://stackoverflow.com/a/62888/10333 contains more accurate
      // TODO: expand to include the rest
      const INVALID_PATH_CHARS = /[<>:"|?*]/

      function invalidWin32Path(p) {
        const rp = getRootPath(p)
        p = p.replace(rp, '')
        return INVALID_PATH_CHARS.test(p)
      }

      module.exports = {
        getRootPath,
        invalidWin32Path,
      }

      /***/
    },

    /***/ 5619: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      module.exports = {
        moveSync: __nccwpck_require__(6449),
      }

      /***/
    },

    /***/ 6449: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const copySync = __nccwpck_require__(5341).copySync
      const removeSync = __nccwpck_require__(7799).removeSync
      const mkdirpSync = __nccwpck_require__(8719).mkdirpSync
      const stat = __nccwpck_require__(5056)

      function moveSync(src, dest, opts) {
        opts = opts || {}
        const overwrite = opts.overwrite || opts.clobber || false

        const { srcStat } = stat.checkPathsSync(src, dest, 'move')
        stat.checkParentPathsSync(src, srcStat, dest, 'move')
        mkdirpSync(path.dirname(dest))
        return doRename(src, dest, overwrite)
      }

      function doRename(src, dest, overwrite) {
        if (overwrite) {
          removeSync(dest)
          return rename(src, dest, overwrite)
        }
        if (fs.existsSync(dest)) throw new Error('dest already exists.')
        return rename(src, dest, overwrite)
      }

      function rename(src, dest, overwrite) {
        try {
          fs.renameSync(src, dest)
        } catch (err) {
          if (err.code !== 'EXDEV') throw err
          return moveAcrossDevice(src, dest, overwrite)
        }
      }

      function moveAcrossDevice(src, dest, overwrite) {
        const opts = {
          overwrite,
          errorOnExist: true,
        }
        copySync(src, dest, opts)
        return removeSync(src)
      }

      module.exports = moveSync

      /***/
    },

    /***/ 4204: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      module.exports = {
        move: u(__nccwpck_require__(2596)),
      }

      /***/
    },

    /***/ 2596: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const copy = __nccwpck_require__(4794).copy
      const remove = __nccwpck_require__(7799).remove
      const mkdirp = __nccwpck_require__(8719).mkdirp
      const pathExists = __nccwpck_require__(7716).pathExists
      const stat = __nccwpck_require__(5056)

      function move(src, dest, opts, cb) {
        if (typeof opts === 'function') {
          cb = opts
          opts = {}
        }

        const overwrite = opts.overwrite || opts.clobber || false

        stat.checkPaths(src, dest, 'move', (err, stats) => {
          if (err) return cb(err)
          const { srcStat } = stats
          stat.checkParentPaths(src, srcStat, dest, 'move', err => {
            if (err) return cb(err)
            mkdirp(path.dirname(dest), err => {
              if (err) return cb(err)
              return doRename(src, dest, overwrite, cb)
            })
          })
        })
      }

      function doRename(src, dest, overwrite, cb) {
        if (overwrite) {
          return remove(dest, err => {
            if (err) return cb(err)
            return rename(src, dest, overwrite, cb)
          })
        }
        pathExists(dest, (err, destExists) => {
          if (err) return cb(err)
          if (destExists) return cb(new Error('dest already exists.'))
          return rename(src, dest, overwrite, cb)
        })
      }

      function rename(src, dest, overwrite, cb) {
        fs.rename(src, dest, err => {
          if (!err) return cb()
          if (err.code !== 'EXDEV') return cb(err)
          return moveAcrossDevice(src, dest, overwrite, cb)
        })
      }

      function moveAcrossDevice(src, dest, overwrite, cb) {
        const opts = {
          overwrite,
          errorOnExist: true,
        }
        copy(src, dest, opts, err => {
          if (err) return cb(err)
          return remove(src, cb)
        })
      }

      module.exports = move

      /***/
    },

    /***/ 3652: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const mkdir = __nccwpck_require__(8719)
      const pathExists = __nccwpck_require__(7716).pathExists

      function outputFile(file, data, encoding, callback) {
        if (typeof encoding === 'function') {
          callback = encoding
          encoding = 'utf8'
        }

        const dir = path.dirname(file)
        pathExists(dir, (err, itDoes) => {
          if (err) return callback(err)
          if (itDoes) return fs.writeFile(file, data, encoding, callback)

          mkdir.mkdirs(dir, err => {
            if (err) return callback(err)

            fs.writeFile(file, data, encoding, callback)
          })
        })
      }

      function outputFileSync(file, ...args) {
        const dir = path.dirname(file)
        if (fs.existsSync(dir)) {
          return fs.writeFileSync(file, ...args)
        }
        mkdir.mkdirsSync(dir)
        fs.writeFileSync(file, ...args)
      }

      module.exports = {
        outputFile: u(outputFile),
        outputFileSync,
      }

      /***/
    },

    /***/ 7716: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromPromise */.p
      const fs = __nccwpck_require__(705)

      function pathExists(path) {
        return fs
          .access(path)
          .then(() => true)
          .catch(() => false)
      }

      module.exports = {
        pathExists: u(pathExists),
        pathExistsSync: fs.existsSync,
      }

      /***/
    },

    /***/ 7799: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const rimraf = __nccwpck_require__(9507)

      module.exports = {
        remove: u(rimraf),
        removeSync: rimraf.sync,
      }

      /***/
    },

    /***/ 9507: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const assert = __nccwpck_require__(9491)

      const isWindows = process.platform === 'win32'

      function defaults(options) {
        const methods = ['unlink', 'chmod', 'stat', 'lstat', 'rmdir', 'readdir']
        methods.forEach(m => {
          options[m] = options[m] || fs[m]
          m = m + 'Sync'
          options[m] = options[m] || fs[m]
        })

        options.maxBusyTries = options.maxBusyTries || 3
      }

      function rimraf(p, options, cb) {
        let busyTries = 0

        if (typeof options === 'function') {
          cb = options
          options = {}
        }

        assert(p, 'rimraf: missing path')
        assert.strictEqual(
          typeof p,
          'string',
          'rimraf: path should be a string'
        )
        assert.strictEqual(
          typeof cb,
          'function',
          'rimraf: callback function required'
        )
        assert(options, 'rimraf: invalid options argument provided')
        assert.strictEqual(
          typeof options,
          'object',
          'rimraf: options should be object'
        )

        defaults(options)

        rimraf_(p, options, function CB(er) {
          if (er) {
            if (
              (er.code === 'EBUSY' ||
                er.code === 'ENOTEMPTY' ||
                er.code === 'EPERM') &&
              busyTries < options.maxBusyTries
            ) {
              busyTries++
              const time = busyTries * 100
              // try again, with the same exact callback as this one.
              return setTimeout(() => rimraf_(p, options, CB), time)
            }

            // already gone
            if (er.code === 'ENOENT') er = null
          }

          cb(er)
        })
      }

      // Two possible strategies.
      // 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
      // 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
      //
      // Both result in an extra syscall when you guess wrong.  However, there
      // are likely far more normal files in the world than directories.  This
      // is based on the assumption that a the average number of files per
      // directory is >= 1.
      //
      // If anyone ever complains about this, then I guess the strategy could
      // be made configurable somehow.  But until then, YAGNI.
      function rimraf_(p, options, cb) {
        assert(p)
        assert(options)
        assert(typeof cb === 'function')

        // sunos lets the root user unlink directories, which is... weird.
        // so we have to lstat here and make sure it's not a dir.
        options.lstat(p, (er, st) => {
          if (er && er.code === 'ENOENT') {
            return cb(null)
          }

          // Windows can EPERM on stat.  Life is suffering.
          if (er && er.code === 'EPERM' && isWindows) {
            return fixWinEPERM(p, options, er, cb)
          }

          if (st && st.isDirectory()) {
            return rmdir(p, options, er, cb)
          }

          options.unlink(p, er => {
            if (er) {
              if (er.code === 'ENOENT') {
                return cb(null)
              }
              if (er.code === 'EPERM') {
                return isWindows
                  ? fixWinEPERM(p, options, er, cb)
                  : rmdir(p, options, er, cb)
              }
              if (er.code === 'EISDIR') {
                return rmdir(p, options, er, cb)
              }
            }
            return cb(er)
          })
        })
      }

      function fixWinEPERM(p, options, er, cb) {
        assert(p)
        assert(options)
        assert(typeof cb === 'function')
        if (er) {
          assert(er instanceof Error)
        }

        options.chmod(p, 0o666, er2 => {
          if (er2) {
            cb(er2.code === 'ENOENT' ? null : er)
          } else {
            options.stat(p, (er3, stats) => {
              if (er3) {
                cb(er3.code === 'ENOENT' ? null : er)
              } else if (stats.isDirectory()) {
                rmdir(p, options, er, cb)
              } else {
                options.unlink(p, cb)
              }
            })
          }
        })
      }

      function fixWinEPERMSync(p, options, er) {
        let stats

        assert(p)
        assert(options)
        if (er) {
          assert(er instanceof Error)
        }

        try {
          options.chmodSync(p, 0o666)
        } catch (er2) {
          if (er2.code === 'ENOENT') {
            return
          } else {
            throw er
          }
        }

        try {
          stats = options.statSync(p)
        } catch (er3) {
          if (er3.code === 'ENOENT') {
            return
          } else {
            throw er
          }
        }

        if (stats.isDirectory()) {
          rmdirSync(p, options, er)
        } else {
          options.unlinkSync(p)
        }
      }

      function rmdir(p, options, originalEr, cb) {
        assert(p)
        assert(options)
        if (originalEr) {
          assert(originalEr instanceof Error)
        }
        assert(typeof cb === 'function')

        // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
        // if we guessed wrong, and it's not a directory, then
        // raise the original error.
        options.rmdir(p, er => {
          if (
            er &&
            (er.code === 'ENOTEMPTY' ||
              er.code === 'EEXIST' ||
              er.code === 'EPERM')
          ) {
            rmkids(p, options, cb)
          } else if (er && er.code === 'ENOTDIR') {
            cb(originalEr)
          } else {
            cb(er)
          }
        })
      }

      function rmkids(p, options, cb) {
        assert(p)
        assert(options)
        assert(typeof cb === 'function')

        options.readdir(p, (er, files) => {
          if (er) return cb(er)

          let n = files.length
          let errState

          if (n === 0) return options.rmdir(p, cb)

          files.forEach(f => {
            rimraf(path.join(p, f), options, er => {
              if (errState) {
                return
              }
              if (er) return cb((errState = er))
              if (--n === 0) {
                options.rmdir(p, cb)
              }
            })
          })
        })
      }

      // this looks simpler, and is strictly *faster*, but will
      // tie up the JavaScript thread and fail on excessively
      // deep directory trees.
      function rimrafSync(p, options) {
        let st

        options = options || {}
        defaults(options)

        assert(p, 'rimraf: missing path')
        assert.strictEqual(
          typeof p,
          'string',
          'rimraf: path should be a string'
        )
        assert(options, 'rimraf: missing options')
        assert.strictEqual(
          typeof options,
          'object',
          'rimraf: options should be object'
        )

        try {
          st = options.lstatSync(p)
        } catch (er) {
          if (er.code === 'ENOENT') {
            return
          }

          // Windows can EPERM on stat.  Life is suffering.
          if (er.code === 'EPERM' && isWindows) {
            fixWinEPERMSync(p, options, er)
          }
        }

        try {
          // sunos lets the root user unlink directories, which is... weird.
          if (st && st.isDirectory()) {
            rmdirSync(p, options, null)
          } else {
            options.unlinkSync(p)
          }
        } catch (er) {
          if (er.code === 'ENOENT') {
            return
          } else if (er.code === 'EPERM') {
            return isWindows
              ? fixWinEPERMSync(p, options, er)
              : rmdirSync(p, options, er)
          } else if (er.code !== 'EISDIR') {
            throw er
          }
          rmdirSync(p, options, er)
        }
      }

      function rmdirSync(p, options, originalEr) {
        assert(p)
        assert(options)
        if (originalEr) {
          assert(originalEr instanceof Error)
        }

        try {
          options.rmdirSync(p)
        } catch (er) {
          if (er.code === 'ENOTDIR') {
            throw originalEr
          } else if (
            er.code === 'ENOTEMPTY' ||
            er.code === 'EEXIST' ||
            er.code === 'EPERM'
          ) {
            rmkidsSync(p, options)
          } else if (er.code !== 'ENOENT') {
            throw er
          }
        }
      }

      function rmkidsSync(p, options) {
        assert(p)
        assert(options)
        options
          .readdirSync(p)
          .forEach(f => rimrafSync(path.join(p, f), options))

        if (isWindows) {
          // We only end up here once we got ENOTEMPTY at least once, and
          // at this point, we are guaranteed to have removed all the kids.
          // So, we know that it won't be ENOENT or ENOTDIR or anything else.
          // try really hard to delete stuff on windows, because it has a
          // PROFOUNDLY annoying habit of not closing handles promptly when
          // files are deleted, resulting in spurious ENOTEMPTY errors.
          const startTime = Date.now()
          do {
            try {
              const ret = options.rmdirSync(p, options)
              return ret
            } catch (er) {}
          } while (Date.now() - startTime < 500) // give up after 500ms
        } else {
          const ret = options.rmdirSync(p, options)
          return ret
        }
      }

      module.exports = rimraf
      rimraf.sync = rimrafSync

      /***/
    },

    /***/ 9425: /***/ module => {
      'use strict'

      /* eslint-disable node/no-deprecated-api */
      module.exports = function (size) {
        if (typeof Buffer.allocUnsafe === 'function') {
          try {
            return Buffer.allocUnsafe(size)
          } catch (e) {
            return new Buffer(size)
          }
        }
        return new Buffer(size)
      }

      /***/
    },

    /***/ 5056: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)

      const NODE_VERSION_MAJOR_WITH_BIGINT = 10
      const NODE_VERSION_MINOR_WITH_BIGINT = 5
      const NODE_VERSION_PATCH_WITH_BIGINT = 0
      const nodeVersion = process.versions.node.split('.')
      const nodeVersionMajor = Number.parseInt(nodeVersion[0], 10)
      const nodeVersionMinor = Number.parseInt(nodeVersion[1], 10)
      const nodeVersionPatch = Number.parseInt(nodeVersion[2], 10)

      function nodeSupportsBigInt() {
        if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) {
          return true
        } else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {
          if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) {
            return true
          } else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {
            if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) {
              return true
            }
          }
        }
        return false
      }

      function getStats(src, dest, cb) {
        if (nodeSupportsBigInt()) {
          fs.stat(src, { bigint: true }, (err, srcStat) => {
            if (err) return cb(err)
            fs.stat(dest, { bigint: true }, (err, destStat) => {
              if (err) {
                if (err.code === 'ENOENT')
                  return cb(null, { srcStat, destStat: null })
                return cb(err)
              }
              return cb(null, { srcStat, destStat })
            })
          })
        } else {
          fs.stat(src, (err, srcStat) => {
            if (err) return cb(err)
            fs.stat(dest, (err, destStat) => {
              if (err) {
                if (err.code === 'ENOENT')
                  return cb(null, { srcStat, destStat: null })
                return cb(err)
              }
              return cb(null, { srcStat, destStat })
            })
          })
        }
      }

      function getStatsSync(src, dest) {
        let srcStat, destStat
        if (nodeSupportsBigInt()) {
          srcStat = fs.statSync(src, { bigint: true })
        } else {
          srcStat = fs.statSync(src)
        }
        try {
          if (nodeSupportsBigInt()) {
            destStat = fs.statSync(dest, { bigint: true })
          } else {
            destStat = fs.statSync(dest)
          }
        } catch (err) {
          if (err.code === 'ENOENT') return { srcStat, destStat: null }
          throw err
        }
        return { srcStat, destStat }
      }

      function checkPaths(src, dest, funcName, cb) {
        getStats(src, dest, (err, stats) => {
          if (err) return cb(err)
          const { srcStat, destStat } = stats
          if (
            destStat &&
            destStat.ino &&
            destStat.dev &&
            destStat.ino === srcStat.ino &&
            destStat.dev === srcStat.dev
          ) {
            return cb(new Error('Source and destination must not be the same.'))
          }
          if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
            return cb(new Error(errMsg(src, dest, funcName)))
          }
          return cb(null, { srcStat, destStat })
        })
      }

      function checkPathsSync(src, dest, funcName) {
        const { srcStat, destStat } = getStatsSync(src, dest)
        if (
          destStat &&
          destStat.ino &&
          destStat.dev &&
          destStat.ino === srcStat.ino &&
          destStat.dev === srcStat.dev
        ) {
          throw new Error('Source and destination must not be the same.')
        }
        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
          throw new Error(errMsg(src, dest, funcName))
        }
        return { srcStat, destStat }
      }

      // recursively check if dest parent is a subdirectory of src.
      // It works for all file types including symlinks since it
      // checks the src and dest inodes. It starts from the deepest
      // parent and stops once it reaches the src parent or the root path.
      function checkParentPaths(src, srcStat, dest, funcName, cb) {
        const srcParent = path.resolve(path.dirname(src))
        const destParent = path.resolve(path.dirname(dest))
        if (
          destParent === srcParent ||
          destParent === path.parse(destParent).root
        )
          return cb()
        if (nodeSupportsBigInt()) {
          fs.stat(destParent, { bigint: true }, (err, destStat) => {
            if (err) {
              if (err.code === 'ENOENT') return cb()
              return cb(err)
            }
            if (
              destStat.ino &&
              destStat.dev &&
              destStat.ino === srcStat.ino &&
              destStat.dev === srcStat.dev
            ) {
              return cb(new Error(errMsg(src, dest, funcName)))
            }
            return checkParentPaths(src, srcStat, destParent, funcName, cb)
          })
        } else {
          fs.stat(destParent, (err, destStat) => {
            if (err) {
              if (err.code === 'ENOENT') return cb()
              return cb(err)
            }
            if (
              destStat.ino &&
              destStat.dev &&
              destStat.ino === srcStat.ino &&
              destStat.dev === srcStat.dev
            ) {
              return cb(new Error(errMsg(src, dest, funcName)))
            }
            return checkParentPaths(src, srcStat, destParent, funcName, cb)
          })
        }
      }

      function checkParentPathsSync(src, srcStat, dest, funcName) {
        const srcParent = path.resolve(path.dirname(src))
        const destParent = path.resolve(path.dirname(dest))
        if (
          destParent === srcParent ||
          destParent === path.parse(destParent).root
        )
          return
        let destStat
        try {
          if (nodeSupportsBigInt()) {
            destStat = fs.statSync(destParent, { bigint: true })
          } else {
            destStat = fs.statSync(destParent)
          }
        } catch (err) {
          if (err.code === 'ENOENT') return
          throw err
        }
        if (
          destStat.ino &&
          destStat.dev &&
          destStat.ino === srcStat.ino &&
          destStat.dev === srcStat.dev
        ) {
          throw new Error(errMsg(src, dest, funcName))
        }
        return checkParentPathsSync(src, srcStat, destParent, funcName)
      }

      // return true if dest is a subdir of src, otherwise false.
      // It only checks the path strings.
      function isSrcSubdir(src, dest) {
        const srcArr = path
          .resolve(src)
          .split(path.sep)
          .filter(i => i)
        const destArr = path
          .resolve(dest)
          .split(path.sep)
          .filter(i => i)
        return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)
      }

      function errMsg(src, dest, funcName) {
        return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`
      }

      module.exports = {
        checkPaths,
        checkPathsSync,
        checkParentPaths,
        checkParentPathsSync,
        isSrcSubdir,
      }

      /***/
    },

    /***/ 6001: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const os = __nccwpck_require__(2037)
      const path = __nccwpck_require__(1017)

      // HFS, ext{2,3}, FAT do not, Node.js v0.10 does not
      function hasMillisResSync() {
        let tmpfile = path.join(
          'millis-test-sync' +
            Date.now().toString() +
            Math.random().toString().slice(2)
        )
        tmpfile = path.join(os.tmpdir(), tmpfile)

        // 550 millis past UNIX epoch
        const d = new Date(1435410243862)
        fs.writeFileSync(
          tmpfile,
          'https://github.com/jprichardson/node-fs-extra/pull/141'
        )
        const fd = fs.openSync(tmpfile, 'r+')
        fs.futimesSync(fd, d, d)
        fs.closeSync(fd)
        return fs.statSync(tmpfile).mtime > 1435410243000
      }

      function hasMillisRes(callback) {
        let tmpfile = path.join(
          'millis-test' +
            Date.now().toString() +
            Math.random().toString().slice(2)
        )
        tmpfile = path.join(os.tmpdir(), tmpfile)

        // 550 millis past UNIX epoch
        const d = new Date(1435410243862)
        fs.writeFile(
          tmpfile,
          'https://github.com/jprichardson/node-fs-extra/pull/141',
          err => {
            if (err) return callback(err)
            fs.open(tmpfile, 'r+', (err, fd) => {
              if (err) return callback(err)
              fs.futimes(fd, d, d, err => {
                if (err) return callback(err)
                fs.close(fd, err => {
                  if (err) return callback(err)
                  fs.stat(tmpfile, (err, stats) => {
                    if (err) return callback(err)
                    callback(null, stats.mtime > 1435410243000)
                  })
                })
              })
            })
          }
        )
      }

      function timeRemoveMillis(timestamp) {
        if (typeof timestamp === 'number') {
          return Math.floor(timestamp / 1000) * 1000
        } else if (timestamp instanceof Date) {
          return new Date(Math.floor(timestamp.getTime() / 1000) * 1000)
        } else {
          throw new Error('fs-extra: timeRemoveMillis() unknown parameter type')
        }
      }

      function utimesMillis(path, atime, mtime, callback) {
        // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
        fs.open(path, 'r+', (err, fd) => {
          if (err) return callback(err)
          fs.futimes(fd, atime, mtime, futimesErr => {
            fs.close(fd, closeErr => {
              if (callback) callback(futimesErr || closeErr)
            })
          })
        })
      }

      function utimesMillisSync(path, atime, mtime) {
        const fd = fs.openSync(path, 'r+')
        fs.futimesSync(fd, atime, mtime)
        return fs.closeSync(fd)
      }

      module.exports = {
        hasMillisRes,
        hasMillisResSync,
        timeRemoveMillis,
        utimesMillis,
        utimesMillisSync,
      }

      /***/
    },

    /***/ 3803: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0
      const fs = __nccwpck_require__(7147)
      exports.FILE_SYSTEM_ADAPTER = {
        lstat: fs.lstat,
        stat: fs.stat,
        lstatSync: fs.lstatSync,
        statSync: fs.statSync,
        readdir: fs.readdir,
        readdirSync: fs.readdirSync,
      }
      function createFileSystemAdapter(fsMethods) {
        if (fsMethods === undefined) {
          return exports.FILE_SYSTEM_ADAPTER
        }
        return Object.assign(
          Object.assign({}, exports.FILE_SYSTEM_ADAPTER),
          fsMethods
        )
      }
      exports.createFileSystemAdapter = createFileSystemAdapter

      /***/
    },

    /***/ 8838: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0
      const NODE_PROCESS_VERSION_PARTS = process.versions.node.split('.')
      if (
        NODE_PROCESS_VERSION_PARTS[0] === undefined ||
        NODE_PROCESS_VERSION_PARTS[1] === undefined
      ) {
        throw new Error(
          `Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`
        )
      }
      const MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10)
      const MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10)
      const SUPPORTED_MAJOR_VERSION = 10
      const SUPPORTED_MINOR_VERSION = 10
      const IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION
      const IS_MATCHED_BY_MAJOR_AND_MINOR =
        MAJOR_VERSION === SUPPORTED_MAJOR_VERSION &&
        MINOR_VERSION >= SUPPORTED_MINOR_VERSION
      /**
       * IS `true` for Node.js 10.10 and greater.
       */
      exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES =
        IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR

      /***/
    },

    /***/ 5667: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.Settings = exports.scandirSync = exports.scandir = void 0
      const async = __nccwpck_require__(4507)
      const sync = __nccwpck_require__(9560)
      const settings_1 = __nccwpck_require__(8662)
      exports.Settings = settings_1.default
      function scandir(path, optionsOrSettingsOrCallback, callback) {
        if (typeof optionsOrSettingsOrCallback === 'function') {
          async.read(path, getSettings(), optionsOrSettingsOrCallback)
          return
        }
        async.read(path, getSettings(optionsOrSettingsOrCallback), callback)
      }
      exports.scandir = scandir
      function scandirSync(path, optionsOrSettings) {
        const settings = getSettings(optionsOrSettings)
        return sync.read(path, settings)
      }
      exports.scandirSync = scandirSync
      function getSettings(settingsOrOptions = {}) {
        if (settingsOrOptions instanceof settings_1.default) {
          return settingsOrOptions
        }
        return new settings_1.default(settingsOrOptions)
      }

      /***/
    },

    /***/ 4507: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.readdir = exports.readdirWithFileTypes = exports.read = void 0
      const fsStat = __nccwpck_require__(109)
      const rpl = __nccwpck_require__(5288)
      const constants_1 = __nccwpck_require__(8838)
      const utils = __nccwpck_require__(6297)
      const common = __nccwpck_require__(3847)
      function read(directory, settings, callback) {
        if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
          readdirWithFileTypes(directory, settings, callback)
          return
        }
        readdir(directory, settings, callback)
      }
      exports.read = read
      function readdirWithFileTypes(directory, settings, callback) {
        settings.fs.readdir(
          directory,
          { withFileTypes: true },
          (readdirError, dirents) => {
            if (readdirError !== null) {
              callFailureCallback(callback, readdirError)
              return
            }
            const entries = dirents.map(dirent => ({
              dirent,
              name: dirent.name,
              path: common.joinPathSegments(
                directory,
                dirent.name,
                settings.pathSegmentSeparator
              ),
            }))
            if (!settings.followSymbolicLinks) {
              callSuccessCallback(callback, entries)
              return
            }
            const tasks = entries.map(entry =>
              makeRplTaskEntry(entry, settings)
            )
            rpl(tasks, (rplError, rplEntries) => {
              if (rplError !== null) {
                callFailureCallback(callback, rplError)
                return
              }
              callSuccessCallback(callback, rplEntries)
            })
          }
        )
      }
      exports.readdirWithFileTypes = readdirWithFileTypes
      function makeRplTaskEntry(entry, settings) {
        return done => {
          if (!entry.dirent.isSymbolicLink()) {
            done(null, entry)
            return
          }
          settings.fs.stat(entry.path, (statError, stats) => {
            if (statError !== null) {
              if (settings.throwErrorOnBrokenSymbolicLink) {
                done(statError)
                return
              }
              done(null, entry)
              return
            }
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats)
            done(null, entry)
          })
        }
      }
      function readdir(directory, settings, callback) {
        settings.fs.readdir(directory, (readdirError, names) => {
          if (readdirError !== null) {
            callFailureCallback(callback, readdirError)
            return
          }
          const tasks = names.map(name => {
            const path = common.joinPathSegments(
              directory,
              name,
              settings.pathSegmentSeparator
            )
            return done => {
              fsStat.stat(path, settings.fsStatSettings, (error, stats) => {
                if (error !== null) {
                  done(error)
                  return
                }
                const entry = {
                  name,
                  path,
                  dirent: utils.fs.createDirentFromStats(name, stats),
                }
                if (settings.stats) {
                  entry.stats = stats
                }
                done(null, entry)
              })
            }
          })
          rpl(tasks, (rplError, entries) => {
            if (rplError !== null) {
              callFailureCallback(callback, rplError)
              return
            }
            callSuccessCallback(callback, entries)
          })
        })
      }
      exports.readdir = readdir
      function callFailureCallback(callback, error) {
        callback(error)
      }
      function callSuccessCallback(callback, result) {
        callback(null, result)
      }

      /***/
    },

    /***/ 3847: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.joinPathSegments = void 0
      function joinPathSegments(a, b, separator) {
        /**
         * The correct handling of cases when the first segment is a root (`/`, `C:/`) or UNC path (`//?/C:/`).
         */
        if (a.endsWith(separator)) {
          return a + b
        }
        return a + separator + b
      }
      exports.joinPathSegments = joinPathSegments

      /***/
    },

    /***/ 9560: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.readdir = exports.readdirWithFileTypes = exports.read = void 0
      const fsStat = __nccwpck_require__(109)
      const constants_1 = __nccwpck_require__(8838)
      const utils = __nccwpck_require__(6297)
      const common = __nccwpck_require__(3847)
      function read(directory, settings) {
        if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
          return readdirWithFileTypes(directory, settings)
        }
        return readdir(directory, settings)
      }
      exports.read = read
      function readdirWithFileTypes(directory, settings) {
        const dirents = settings.fs.readdirSync(directory, {
          withFileTypes: true,
        })
        return dirents.map(dirent => {
          const entry = {
            dirent,
            name: dirent.name,
            path: common.joinPathSegments(
              directory,
              dirent.name,
              settings.pathSegmentSeparator
            ),
          }
          if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
            try {
              const stats = settings.fs.statSync(entry.path)
              entry.dirent = utils.fs.createDirentFromStats(entry.name, stats)
            } catch (error) {
              if (settings.throwErrorOnBrokenSymbolicLink) {
                throw error
              }
            }
          }
          return entry
        })
      }
      exports.readdirWithFileTypes = readdirWithFileTypes
      function readdir(directory, settings) {
        const names = settings.fs.readdirSync(directory)
        return names.map(name => {
          const entryPath = common.joinPathSegments(
            directory,
            name,
            settings.pathSegmentSeparator
          )
          const stats = fsStat.statSync(entryPath, settings.fsStatSettings)
          const entry = {
            name,
            path: entryPath,
            dirent: utils.fs.createDirentFromStats(name, stats),
          }
          if (settings.stats) {
            entry.stats = stats
          }
          return entry
        })
      }
      exports.readdir = readdir

      /***/
    },

    /***/ 8662: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const path = __nccwpck_require__(1017)
      const fsStat = __nccwpck_require__(109)
      const fs = __nccwpck_require__(3803)
      class Settings {
        constructor(_options = {}) {
          this._options = _options
          this.followSymbolicLinks = this._getValue(
            this._options.followSymbolicLinks,
            false
          )
          this.fs = fs.createFileSystemAdapter(this._options.fs)
          this.pathSegmentSeparator = this._getValue(
            this._options.pathSegmentSeparator,
            path.sep
          )
          this.stats = this._getValue(this._options.stats, false)
          this.throwErrorOnBrokenSymbolicLink = this._getValue(
            this._options.throwErrorOnBrokenSymbolicLink,
            true
          )
          this.fsStatSettings = new fsStat.Settings({
            followSymbolicLink: this.followSymbolicLinks,
            fs: this.fs,
            throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink,
          })
        }
        _getValue(option, value) {
          return option !== null && option !== void 0 ? option : value
        }
      }
      exports['default'] = Settings

      /***/
    },

    /***/ 883: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.createDirentFromStats = void 0
      class DirentFromStats {
        constructor(name, stats) {
          this.name = name
          this.isBlockDevice = stats.isBlockDevice.bind(stats)
          this.isCharacterDevice = stats.isCharacterDevice.bind(stats)
          this.isDirectory = stats.isDirectory.bind(stats)
          this.isFIFO = stats.isFIFO.bind(stats)
          this.isFile = stats.isFile.bind(stats)
          this.isSocket = stats.isSocket.bind(stats)
          this.isSymbolicLink = stats.isSymbolicLink.bind(stats)
        }
      }
      function createDirentFromStats(name, stats) {
        return new DirentFromStats(name, stats)
      }
      exports.createDirentFromStats = createDirentFromStats

      /***/
    },

    /***/ 6297: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.fs = void 0
      const fs = __nccwpck_require__(883)
      exports.fs = fs

      /***/
    },

    /***/ 2987: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0
      const fs = __nccwpck_require__(7147)
      exports.FILE_SYSTEM_ADAPTER = {
        lstat: fs.lstat,
        stat: fs.stat,
        lstatSync: fs.lstatSync,
        statSync: fs.statSync,
      }
      function createFileSystemAdapter(fsMethods) {
        if (fsMethods === undefined) {
          return exports.FILE_SYSTEM_ADAPTER
        }
        return Object.assign(
          Object.assign({}, exports.FILE_SYSTEM_ADAPTER),
          fsMethods
        )
      }
      exports.createFileSystemAdapter = createFileSystemAdapter

      /***/
    },

    /***/ 109: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.statSync = exports.stat = exports.Settings = void 0
      const async = __nccwpck_require__(4147)
      const sync = __nccwpck_require__(4527)
      const settings_1 = __nccwpck_require__(2410)
      exports.Settings = settings_1.default
      function stat(path, optionsOrSettingsOrCallback, callback) {
        if (typeof optionsOrSettingsOrCallback === 'function') {
          async.read(path, getSettings(), optionsOrSettingsOrCallback)
          return
        }
        async.read(path, getSettings(optionsOrSettingsOrCallback), callback)
      }
      exports.stat = stat
      function statSync(path, optionsOrSettings) {
        const settings = getSettings(optionsOrSettings)
        return sync.read(path, settings)
      }
      exports.statSync = statSync
      function getSettings(settingsOrOptions = {}) {
        if (settingsOrOptions instanceof settings_1.default) {
          return settingsOrOptions
        }
        return new settings_1.default(settingsOrOptions)
      }

      /***/
    },

    /***/ 4147: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.read = void 0
      function read(path, settings, callback) {
        settings.fs.lstat(path, (lstatError, lstat) => {
          if (lstatError !== null) {
            callFailureCallback(callback, lstatError)
            return
          }
          if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
            callSuccessCallback(callback, lstat)
            return
          }
          settings.fs.stat(path, (statError, stat) => {
            if (statError !== null) {
              if (settings.throwErrorOnBrokenSymbolicLink) {
                callFailureCallback(callback, statError)
                return
              }
              callSuccessCallback(callback, lstat)
              return
            }
            if (settings.markSymbolicLink) {
              stat.isSymbolicLink = () => true
            }
            callSuccessCallback(callback, stat)
          })
        })
      }
      exports.read = read
      function callFailureCallback(callback, error) {
        callback(error)
      }
      function callSuccessCallback(callback, result) {
        callback(null, result)
      }

      /***/
    },

    /***/ 4527: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.read = void 0
      function read(path, settings) {
        const lstat = settings.fs.lstatSync(path)
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
          return lstat
        }
        try {
          const stat = settings.fs.statSync(path)
          if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true
          }
          return stat
        } catch (error) {
          if (!settings.throwErrorOnBrokenSymbolicLink) {
            return lstat
          }
          throw error
        }
      }
      exports.read = read

      /***/
    },

    /***/ 2410: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const fs = __nccwpck_require__(2987)
      class Settings {
        constructor(_options = {}) {
          this._options = _options
          this.followSymbolicLink = this._getValue(
            this._options.followSymbolicLink,
            true
          )
          this.fs = fs.createFileSystemAdapter(this._options.fs)
          this.markSymbolicLink = this._getValue(
            this._options.markSymbolicLink,
            false
          )
          this.throwErrorOnBrokenSymbolicLink = this._getValue(
            this._options.throwErrorOnBrokenSymbolicLink,
            true
          )
        }
        _getValue(option, value) {
          return option !== null && option !== void 0 ? option : value
        }
      }
      exports['default'] = Settings

      /***/
    },

    /***/ 6026: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.Settings =
        exports.walkStream =
        exports.walkSync =
        exports.walk =
          void 0
      const async_1 = __nccwpck_require__(7523)
      const stream_1 = __nccwpck_require__(6737)
      const sync_1 = __nccwpck_require__(3068)
      const settings_1 = __nccwpck_require__(141)
      exports.Settings = settings_1.default
      function walk(directory, optionsOrSettingsOrCallback, callback) {
        if (typeof optionsOrSettingsOrCallback === 'function') {
          new async_1.default(directory, getSettings()).read(
            optionsOrSettingsOrCallback
          )
          return
        }
        new async_1.default(
          directory,
          getSettings(optionsOrSettingsOrCallback)
        ).read(callback)
      }
      exports.walk = walk
      function walkSync(directory, optionsOrSettings) {
        const settings = getSettings(optionsOrSettings)
        const provider = new sync_1.default(directory, settings)
        return provider.read()
      }
      exports.walkSync = walkSync
      function walkStream(directory, optionsOrSettings) {
        const settings = getSettings(optionsOrSettings)
        const provider = new stream_1.default(directory, settings)
        return provider.read()
      }
      exports.walkStream = walkStream
      function getSettings(settingsOrOptions = {}) {
        if (settingsOrOptions instanceof settings_1.default) {
          return settingsOrOptions
        }
        return new settings_1.default(settingsOrOptions)
      }

      /***/
    },

    /***/ 7523: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const async_1 = __nccwpck_require__(5732)
      class AsyncProvider {
        constructor(_root, _settings) {
          this._root = _root
          this._settings = _settings
          this._reader = new async_1.default(this._root, this._settings)
          this._storage = []
        }
        read(callback) {
          this._reader.onError(error => {
            callFailureCallback(callback, error)
          })
          this._reader.onEntry(entry => {
            this._storage.push(entry)
          })
          this._reader.onEnd(() => {
            callSuccessCallback(callback, this._storage)
          })
          this._reader.read()
        }
      }
      exports['default'] = AsyncProvider
      function callFailureCallback(callback, error) {
        callback(error)
      }
      function callSuccessCallback(callback, entries) {
        callback(null, entries)
      }

      /***/
    },

    /***/ 6737: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const stream_1 = __nccwpck_require__(2781)
      const async_1 = __nccwpck_require__(5732)
      class StreamProvider {
        constructor(_root, _settings) {
          this._root = _root
          this._settings = _settings
          this._reader = new async_1.default(this._root, this._settings)
          this._stream = new stream_1.Readable({
            objectMode: true,
            read: () => {},
            destroy: () => {
              if (!this._reader.isDestroyed) {
                this._reader.destroy()
              }
            },
          })
        }
        read() {
          this._reader.onError(error => {
            this._stream.emit('error', error)
          })
          this._reader.onEntry(entry => {
            this._stream.push(entry)
          })
          this._reader.onEnd(() => {
            this._stream.push(null)
          })
          this._reader.read()
          return this._stream
        }
      }
      exports['default'] = StreamProvider

      /***/
    },

    /***/ 3068: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const sync_1 = __nccwpck_require__(3595)
      class SyncProvider {
        constructor(_root, _settings) {
          this._root = _root
          this._settings = _settings
          this._reader = new sync_1.default(this._root, this._settings)
        }
        read() {
          return this._reader.read()
        }
      }
      exports['default'] = SyncProvider

      /***/
    },

    /***/ 5732: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const events_1 = __nccwpck_require__(2361)
      const fsScandir = __nccwpck_require__(5667)
      const fastq = __nccwpck_require__(7340)
      const common = __nccwpck_require__(7988)
      const reader_1 = __nccwpck_require__(8311)
      class AsyncReader extends reader_1.default {
        constructor(_root, _settings) {
          super(_root, _settings)
          this._settings = _settings
          this._scandir = fsScandir.scandir
          this._emitter = new events_1.EventEmitter()
          this._queue = fastq(
            this._worker.bind(this),
            this._settings.concurrency
          )
          this._isFatalError = false
          this._isDestroyed = false
          this._queue.drain = () => {
            if (!this._isFatalError) {
              this._emitter.emit('end')
            }
          }
        }
        read() {
          this._isFatalError = false
          this._isDestroyed = false
          setImmediate(() => {
            this._pushToQueue(this._root, this._settings.basePath)
          })
          return this._emitter
        }
        get isDestroyed() {
          return this._isDestroyed
        }
        destroy() {
          if (this._isDestroyed) {
            throw new Error('The reader is already destroyed')
          }
          this._isDestroyed = true
          this._queue.killAndDrain()
        }
        onEntry(callback) {
          this._emitter.on('entry', callback)
        }
        onError(callback) {
          this._emitter.once('error', callback)
        }
        onEnd(callback) {
          this._emitter.once('end', callback)
        }
        _pushToQueue(directory, base) {
          const queueItem = { directory, base }
          this._queue.push(queueItem, error => {
            if (error !== null) {
              this._handleError(error)
            }
          })
        }
        _worker(item, done) {
          this._scandir(
            item.directory,
            this._settings.fsScandirSettings,
            (error, entries) => {
              if (error !== null) {
                done(error, undefined)
                return
              }
              for (const entry of entries) {
                this._handleEntry(entry, item.base)
              }
              done(null, undefined)
            }
          )
        }
        _handleError(error) {
          if (
            this._isDestroyed ||
            !common.isFatalError(this._settings, error)
          ) {
            return
          }
          this._isFatalError = true
          this._isDestroyed = true
          this._emitter.emit('error', error)
        }
        _handleEntry(entry, base) {
          if (this._isDestroyed || this._isFatalError) {
            return
          }
          const fullpath = entry.path
          if (base !== undefined) {
            entry.path = common.joinPathSegments(
              base,
              entry.name,
              this._settings.pathSegmentSeparator
            )
          }
          if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
            this._emitEntry(entry)
          }
          if (
            entry.dirent.isDirectory() &&
            common.isAppliedFilter(this._settings.deepFilter, entry)
          ) {
            this._pushToQueue(
              fullpath,
              base === undefined ? undefined : entry.path
            )
          }
        }
        _emitEntry(entry) {
          this._emitter.emit('entry', entry)
        }
      }
      exports['default'] = AsyncReader

      /***/
    },

    /***/ 7988: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.joinPathSegments =
        exports.replacePathSegmentSeparator =
        exports.isAppliedFilter =
        exports.isFatalError =
          void 0
      function isFatalError(settings, error) {
        if (settings.errorFilter === null) {
          return true
        }
        return !settings.errorFilter(error)
      }
      exports.isFatalError = isFatalError
      function isAppliedFilter(filter, value) {
        return filter === null || filter(value)
      }
      exports.isAppliedFilter = isAppliedFilter
      function replacePathSegmentSeparator(filepath, separator) {
        return filepath.split(/[/\\]/).join(separator)
      }
      exports.replacePathSegmentSeparator = replacePathSegmentSeparator
      function joinPathSegments(a, b, separator) {
        if (a === '') {
          return b
        }
        /**
         * The correct handling of cases when the first segment is a root (`/`, `C:/`) or UNC path (`//?/C:/`).
         */
        if (a.endsWith(separator)) {
          return a + b
        }
        return a + separator + b
      }
      exports.joinPathSegments = joinPathSegments

      /***/
    },

    /***/ 8311: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const common = __nccwpck_require__(7988)
      class Reader {
        constructor(_root, _settings) {
          this._root = _root
          this._settings = _settings
          this._root = common.replacePathSegmentSeparator(
            _root,
            _settings.pathSegmentSeparator
          )
        }
      }
      exports['default'] = Reader

      /***/
    },

    /***/ 3595: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const fsScandir = __nccwpck_require__(5667)
      const common = __nccwpck_require__(7988)
      const reader_1 = __nccwpck_require__(8311)
      class SyncReader extends reader_1.default {
        constructor() {
          super(...arguments)
          this._scandir = fsScandir.scandirSync
          this._storage = []
          this._queue = new Set()
        }
        read() {
          this._pushToQueue(this._root, this._settings.basePath)
          this._handleQueue()
          return this._storage
        }
        _pushToQueue(directory, base) {
          this._queue.add({ directory, base })
        }
        _handleQueue() {
          for (const item of this._queue.values()) {
            this._handleDirectory(item.directory, item.base)
          }
        }
        _handleDirectory(directory, base) {
          try {
            const entries = this._scandir(
              directory,
              this._settings.fsScandirSettings
            )
            for (const entry of entries) {
              this._handleEntry(entry, base)
            }
          } catch (error) {
            this._handleError(error)
          }
        }
        _handleError(error) {
          if (!common.isFatalError(this._settings, error)) {
            return
          }
          throw error
        }
        _handleEntry(entry, base) {
          const fullpath = entry.path
          if (base !== undefined) {
            entry.path = common.joinPathSegments(
              base,
              entry.name,
              this._settings.pathSegmentSeparator
            )
          }
          if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
            this._pushToStorage(entry)
          }
          if (
            entry.dirent.isDirectory() &&
            common.isAppliedFilter(this._settings.deepFilter, entry)
          ) {
            this._pushToQueue(
              fullpath,
              base === undefined ? undefined : entry.path
            )
          }
        }
        _pushToStorage(entry) {
          this._storage.push(entry)
        }
      }
      exports['default'] = SyncReader

      /***/
    },

    /***/ 141: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const path = __nccwpck_require__(1017)
      const fsScandir = __nccwpck_require__(5667)
      class Settings {
        constructor(_options = {}) {
          this._options = _options
          this.basePath = this._getValue(this._options.basePath, undefined)
          this.concurrency = this._getValue(
            this._options.concurrency,
            Number.POSITIVE_INFINITY
          )
          this.deepFilter = this._getValue(this._options.deepFilter, null)
          this.entryFilter = this._getValue(this._options.entryFilter, null)
          this.errorFilter = this._getValue(this._options.errorFilter, null)
          this.pathSegmentSeparator = this._getValue(
            this._options.pathSegmentSeparator,
            path.sep
          )
          this.fsScandirSettings = new fsScandir.Settings({
            followSymbolicLinks: this._options.followSymbolicLinks,
            fs: this._options.fs,
            pathSegmentSeparator: this._options.pathSegmentSeparator,
            stats: this._options.stats,
            throwErrorOnBrokenSymbolicLink:
              this._options.throwErrorOnBrokenSymbolicLink,
          })
        }
        _getValue(option, value) {
          return option !== null && option !== void 0 ? option : value
        }
      }
      exports['default'] = Settings

      /***/
    },

    /***/ 9600: /***/ module => {
      'use strict'

      module.exports = (...arguments_) => {
        return [...new Set([].concat(...arguments_))]
      }

      /***/
    },

    /***/ 7053: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const path = __nccwpck_require__(1017)
      const isWindows = __nccwpck_require__(9125)

      module.exports = isWindows() ? winResolve : path.resolve

      function winResolve(p) {
        if (arguments.length === 0) return path.resolve()
        if (typeof p !== 'string') {
          return path.resolve(p)
        }
        // c: => C:
        if (p[1] === ':') {
          const cc = p[0].charCodeAt()
          if (cc < 65 || cc > 90) {
            p = `${p[0].toUpperCase()}${p.substr(1)}`
          }
        }
        // On Windows path.resolve('C:') returns C:\Users\
        // We resolve C: to C:
        if (p.endsWith(':')) {
          return p
        }
        return path.resolve(p)
      }

      /***/
    },

    /***/ 610: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const stringify = __nccwpck_require__(8750)
      const compile = __nccwpck_require__(9434)
      const expand = __nccwpck_require__(5873)
      const parse = __nccwpck_require__(6477)

      /**
       * Expand the given pattern or create a regex-compatible string.
       *
       * ```js
       * const braces = require('braces');
       * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
       * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
       * ```
       * @param {String} `str`
       * @param {Object} `options`
       * @return {String}
       * @api public
       */

      const braces = (input, options = {}) => {
        let output = []

        if (Array.isArray(input)) {
          for (let pattern of input) {
            let result = braces.create(pattern, options)
            if (Array.isArray(result)) {
              output.push(...result)
            } else {
              output.push(result)
            }
          }
        } else {
          output = [].concat(braces.create(input, options))
        }

        if (options && options.expand === true && options.nodupes === true) {
          output = [...new Set(output)]
        }
        return output
      }

      /**
       * Parse the given `str` with the given `options`.
       *
       * ```js
       * // braces.parse(pattern, [, options]);
       * const ast = braces.parse('a/{b,c}/d');
       * console.log(ast);
       * ```
       * @param {String} pattern Brace pattern to parse
       * @param {Object} options
       * @return {Object} Returns an AST
       * @api public
       */

      braces.parse = (input, options = {}) => parse(input, options)

      /**
       * Creates a braces string from an AST, or an AST node.
       *
       * ```js
       * const braces = require('braces');
       * let ast = braces.parse('foo/{a,b}/bar');
       * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
       * ```
       * @param {String} `input` Brace pattern or AST.
       * @param {Object} `options`
       * @return {Array} Returns an array of expanded values.
       * @api public
       */

      braces.stringify = (input, options = {}) => {
        if (typeof input === 'string') {
          return stringify(braces.parse(input, options), options)
        }
        return stringify(input, options)
      }

      /**
       * Compiles a brace pattern into a regex-compatible, optimized string.
       * This method is called by the main [braces](#braces) function by default.
       *
       * ```js
       * const braces = require('braces');
       * console.log(braces.compile('a/{b,c}/d'));
       * //=> ['a/(b|c)/d']
       * ```
       * @param {String} `input` Brace pattern or AST.
       * @param {Object} `options`
       * @return {Array} Returns an array of expanded values.
       * @api public
       */

      braces.compile = (input, options = {}) => {
        if (typeof input === 'string') {
          input = braces.parse(input, options)
        }
        return compile(input, options)
      }

      /**
       * Expands a brace pattern into an array. This method is called by the
       * main [braces](#braces) function when `options.expand` is true. Before
       * using this method it's recommended that you read the [performance notes](#performance))
       * and advantages of using [.compile](#compile) instead.
       *
       * ```js
       * const braces = require('braces');
       * console.log(braces.expand('a/{b,c}/d'));
       * //=> ['a/b/d', 'a/c/d'];
       * ```
       * @param {String} `pattern` Brace pattern
       * @param {Object} `options`
       * @return {Array} Returns an array of expanded values.
       * @api public
       */

      braces.expand = (input, options = {}) => {
        if (typeof input === 'string') {
          input = braces.parse(input, options)
        }

        let result = expand(input, options)

        // filter out empty strings if specified
        if (options.noempty === true) {
          result = result.filter(Boolean)
        }

        // filter out duplicates if specified
        if (options.nodupes === true) {
          result = [...new Set(result)]
        }

        return result
      }

      /**
       * Processes a brace pattern and returns either an expanded array
       * (if `options.expand` is true), a highly optimized regex-compatible string.
       * This method is called by the main [braces](#braces) function.
       *
       * ```js
       * const braces = require('braces');
       * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
       * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
       * ```
       * @param {String} `pattern` Brace pattern
       * @param {Object} `options`
       * @return {Array} Returns an array of expanded values.
       * @api public
       */

      braces.create = (input, options = {}) => {
        if (input === '' || input.length < 3) {
          return [input]
        }

        return options.expand !== true
          ? braces.compile(input, options)
          : braces.expand(input, options)
      }

      /**
       * Expose "braces"
       */

      module.exports = braces

      /***/
    },

    /***/ 9434: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fill = __nccwpck_require__(6330)
      const utils = __nccwpck_require__(5207)

      const compile = (ast, options = {}) => {
        let walk = (node, parent = {}) => {
          let invalidBlock = utils.isInvalidBrace(parent)
          let invalidNode =
            node.invalid === true && options.escapeInvalid === true
          let invalid = invalidBlock === true || invalidNode === true
          let prefix = options.escapeInvalid === true ? '\\' : ''
          let output = ''

          if (node.isOpen === true) {
            return prefix + node.value
          }
          if (node.isClose === true) {
            return prefix + node.value
          }

          if (node.type === 'open') {
            return invalid ? prefix + node.value : '('
          }

          if (node.type === 'close') {
            return invalid ? prefix + node.value : ')'
          }

          if (node.type === 'comma') {
            return node.prev.type === 'comma' ? '' : invalid ? node.value : '|'
          }

          if (node.value) {
            return node.value
          }

          if (node.nodes && node.ranges > 0) {
            let args = utils.reduce(node.nodes)
            let range = fill(...args, {
              ...options,
              wrap: false,
              toRegex: true,
            })

            if (range.length !== 0) {
              return args.length > 1 && range.length > 1 ? `(${range})` : range
            }
          }

          if (node.nodes) {
            for (let child of node.nodes) {
              output += walk(child, node)
            }
          }
          return output
        }

        return walk(ast)
      }

      module.exports = compile

      /***/
    },

    /***/ 8774: /***/ module => {
      'use strict'

      module.exports = {
        MAX_LENGTH: 1024 * 64,

        // Digits
        CHAR_0: '0' /* 0 */,
        CHAR_9: '9' /* 9 */,

        // Alphabet chars.
        CHAR_UPPERCASE_A: 'A' /* A */,
        CHAR_LOWERCASE_A: 'a' /* a */,
        CHAR_UPPERCASE_Z: 'Z' /* Z */,
        CHAR_LOWERCASE_Z: 'z' /* z */,

        CHAR_LEFT_PARENTHESES: '(' /* ( */,
        CHAR_RIGHT_PARENTHESES: ')' /* ) */,

        CHAR_ASTERISK: '*' /* * */,

        // Non-alphabetic chars.
        CHAR_AMPERSAND: '&' /* & */,
        CHAR_AT: '@' /* @ */,
        CHAR_BACKSLASH: '\\' /* \ */,
        CHAR_BACKTICK: '`' /* ` */,
        CHAR_CARRIAGE_RETURN: '\r' /* \r */,
        CHAR_CIRCUMFLEX_ACCENT: '^' /* ^ */,
        CHAR_COLON: ':' /* : */,
        CHAR_COMMA: ',' /* , */,
        CHAR_DOLLAR: '$' /* . */,
        CHAR_DOT: '.' /* . */,
        CHAR_DOUBLE_QUOTE: '"' /* " */,
        CHAR_EQUAL: '=' /* = */,
        CHAR_EXCLAMATION_MARK: '!' /* ! */,
        CHAR_FORM_FEED: '\f' /* \f */,
        CHAR_FORWARD_SLASH: '/' /* / */,
        CHAR_HASH: '#' /* # */,
        CHAR_HYPHEN_MINUS: '-' /* - */,
        CHAR_LEFT_ANGLE_BRACKET: '<' /* < */,
        CHAR_LEFT_CURLY_BRACE: '{' /* { */,
        CHAR_LEFT_SQUARE_BRACKET: '[' /* [ */,
        CHAR_LINE_FEED: '\n' /* \n */,
        CHAR_NO_BREAK_SPACE: '\u00A0' /* \u00A0 */,
        CHAR_PERCENT: '%' /* % */,
        CHAR_PLUS: '+' /* + */,
        CHAR_QUESTION_MARK: '?' /* ? */,
        CHAR_RIGHT_ANGLE_BRACKET: '>' /* > */,
        CHAR_RIGHT_CURLY_BRACE: '}' /* } */,
        CHAR_RIGHT_SQUARE_BRACKET: ']' /* ] */,
        CHAR_SEMICOLON: ';' /* ; */,
        CHAR_SINGLE_QUOTE: "'" /* ' */,
        CHAR_SPACE: ' ' /*   */,
        CHAR_TAB: '\t' /* \t */,
        CHAR_UNDERSCORE: '_' /* _ */,
        CHAR_VERTICAL_LINE: '|' /* | */,
        CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\uFEFF' /* \uFEFF */,
      }

      /***/
    },

    /***/ 5873: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fill = __nccwpck_require__(6330)
      const stringify = __nccwpck_require__(8750)
      const utils = __nccwpck_require__(5207)

      const append = (queue = '', stash = '', enclose = false) => {
        let result = []

        queue = [].concat(queue)
        stash = [].concat(stash)

        if (!stash.length) return queue
        if (!queue.length) {
          return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash
        }

        for (let item of queue) {
          if (Array.isArray(item)) {
            for (let value of item) {
              result.push(append(value, stash, enclose))
            }
          } else {
            for (let ele of stash) {
              if (enclose === true && typeof ele === 'string') ele = `{${ele}}`
              result.push(
                Array.isArray(ele) ? append(item, ele, enclose) : item + ele
              )
            }
          }
        }
        return utils.flatten(result)
      }

      const expand = (ast, options = {}) => {
        let rangeLimit =
          options.rangeLimit === void 0 ? 1000 : options.rangeLimit

        let walk = (node, parent = {}) => {
          node.queue = []

          let p = parent
          let q = parent.queue

          while (p.type !== 'brace' && p.type !== 'root' && p.parent) {
            p = p.parent
            q = p.queue
          }

          if (node.invalid || node.dollar) {
            q.push(append(q.pop(), stringify(node, options)))
            return
          }

          if (
            node.type === 'brace' &&
            node.invalid !== true &&
            node.nodes.length === 2
          ) {
            q.push(append(q.pop(), ['{}']))
            return
          }

          if (node.nodes && node.ranges > 0) {
            let args = utils.reduce(node.nodes)

            if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
              throw new RangeError(
                'expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.'
              )
            }

            let range = fill(...args, options)
            if (range.length === 0) {
              range = stringify(node, options)
            }

            q.push(append(q.pop(), range))
            node.nodes = []
            return
          }

          let enclose = utils.encloseBrace(node)
          let queue = node.queue
          let block = node

          while (
            block.type !== 'brace' &&
            block.type !== 'root' &&
            block.parent
          ) {
            block = block.parent
            queue = block.queue
          }

          for (let i = 0; i < node.nodes.length; i++) {
            let child = node.nodes[i]

            if (child.type === 'comma' && node.type === 'brace') {
              if (i === 1) queue.push('')
              queue.push('')
              continue
            }

            if (child.type === 'close') {
              q.push(append(q.pop(), queue, enclose))
              continue
            }

            if (child.value && child.type !== 'open') {
              queue.push(append(queue.pop(), child.value))
              continue
            }

            if (child.nodes) {
              walk(child, node)
            }
          }

          return queue
        }

        return utils.flatten(walk(ast))
      }

      module.exports = expand

      /***/
    },

    /***/ 6477: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const stringify = __nccwpck_require__(8750)

      /**
       * Constants
       */

      const {
        MAX_LENGTH,
        CHAR_BACKSLASH /* \ */,
        CHAR_BACKTICK /* ` */,
        CHAR_COMMA /* , */,
        CHAR_DOT /* . */,
        CHAR_LEFT_PARENTHESES /* ( */,
        CHAR_RIGHT_PARENTHESES /* ) */,
        CHAR_LEFT_CURLY_BRACE /* { */,
        CHAR_RIGHT_CURLY_BRACE /* } */,
        CHAR_LEFT_SQUARE_BRACKET /* [ */,
        CHAR_RIGHT_SQUARE_BRACKET /* ] */,
        CHAR_DOUBLE_QUOTE /* " */,
        CHAR_SINGLE_QUOTE /* ' */,
        CHAR_NO_BREAK_SPACE,
        CHAR_ZERO_WIDTH_NOBREAK_SPACE,
      } = __nccwpck_require__(8774)

      /**
       * parse
       */

      const parse = (input, options = {}) => {
        if (typeof input !== 'string') {
          throw new TypeError('Expected a string')
        }

        let opts = options || {}
        let max =
          typeof opts.maxLength === 'number'
            ? Math.min(MAX_LENGTH, opts.maxLength)
            : MAX_LENGTH
        if (input.length > max) {
          throw new SyntaxError(
            `Input length (${input.length}), exceeds max characters (${max})`
          )
        }

        let ast = { type: 'root', input, nodes: [] }
        let stack = [ast]
        let block = ast
        let prev = ast
        let brackets = 0
        let length = input.length
        let index = 0
        let depth = 0
        let value
        let memo = {}

        /**
         * Helpers
         */

        const advance = () => input[index++]
        const push = node => {
          if (node.type === 'text' && prev.type === 'dot') {
            prev.type = 'text'
          }

          if (prev && prev.type === 'text' && node.type === 'text') {
            prev.value += node.value
            return
          }

          block.nodes.push(node)
          node.parent = block
          node.prev = prev
          prev = node
          return node
        }

        push({ type: 'bos' })

        while (index < length) {
          block = stack[stack.length - 1]
          value = advance()

          /**
           * Invalid chars
           */

          if (
            value === CHAR_ZERO_WIDTH_NOBREAK_SPACE ||
            value === CHAR_NO_BREAK_SPACE
          ) {
            continue
          }

          /**
           * Escaped chars
           */

          if (value === CHAR_BACKSLASH) {
            push({
              type: 'text',
              value: (options.keepEscaping ? value : '') + advance(),
            })
            continue
          }

          /**
           * Right square bracket (literal): ']'
           */

          if (value === CHAR_RIGHT_SQUARE_BRACKET) {
            push({ type: 'text', value: '\\' + value })
            continue
          }

          /**
           * Left square bracket: '['
           */

          if (value === CHAR_LEFT_SQUARE_BRACKET) {
            brackets++

            let closed = true
            let next

            while (index < length && (next = advance())) {
              value += next

              if (next === CHAR_LEFT_SQUARE_BRACKET) {
                brackets++
                continue
              }

              if (next === CHAR_BACKSLASH) {
                value += advance()
                continue
              }

              if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                brackets--

                if (brackets === 0) {
                  break
                }
              }
            }

            push({ type: 'text', value })
            continue
          }

          /**
           * Parentheses
           */

          if (value === CHAR_LEFT_PARENTHESES) {
            block = push({ type: 'paren', nodes: [] })
            stack.push(block)
            push({ type: 'text', value })
            continue
          }

          if (value === CHAR_RIGHT_PARENTHESES) {
            if (block.type !== 'paren') {
              push({ type: 'text', value })
              continue
            }
            block = stack.pop()
            push({ type: 'text', value })
            block = stack[stack.length - 1]
            continue
          }

          /**
           * Quotes: '|"|`
           */

          if (
            value === CHAR_DOUBLE_QUOTE ||
            value === CHAR_SINGLE_QUOTE ||
            value === CHAR_BACKTICK
          ) {
            let open = value
            let next

            if (options.keepQuotes !== true) {
              value = ''
            }

            while (index < length && (next = advance())) {
              if (next === CHAR_BACKSLASH) {
                value += next + advance()
                continue
              }

              if (next === open) {
                if (options.keepQuotes === true) value += next
                break
              }

              value += next
            }

            push({ type: 'text', value })
            continue
          }

          /**
           * Left curly brace: '{'
           */

          if (value === CHAR_LEFT_CURLY_BRACE) {
            depth++

            let dollar =
              (prev.value && prev.value.slice(-1) === '$') ||
              block.dollar === true
            let brace = {
              type: 'brace',
              open: true,
              close: false,
              dollar,
              depth,
              commas: 0,
              ranges: 0,
              nodes: [],
            }

            block = push(brace)
            stack.push(block)
            push({ type: 'open', value })
            continue
          }

          /**
           * Right curly brace: '}'
           */

          if (value === CHAR_RIGHT_CURLY_BRACE) {
            if (block.type !== 'brace') {
              push({ type: 'text', value })
              continue
            }

            let type = 'close'
            block = stack.pop()
            block.close = true

            push({ type, value })
            depth--

            block = stack[stack.length - 1]
            continue
          }

          /**
           * Comma: ','
           */

          if (value === CHAR_COMMA && depth > 0) {
            if (block.ranges > 0) {
              block.ranges = 0
              let open = block.nodes.shift()
              block.nodes = [open, { type: 'text', value: stringify(block) }]
            }

            push({ type: 'comma', value })
            block.commas++
            continue
          }

          /**
           * Dot: '.'
           */

          if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
            let siblings = block.nodes

            if (depth === 0 || siblings.length === 0) {
              push({ type: 'text', value })
              continue
            }

            if (prev.type === 'dot') {
              block.range = []
              prev.value += value
              prev.type = 'range'

              if (block.nodes.length !== 3 && block.nodes.length !== 5) {
                block.invalid = true
                block.ranges = 0
                prev.type = 'text'
                continue
              }

              block.ranges++
              block.args = []
              continue
            }

            if (prev.type === 'range') {
              siblings.pop()

              let before = siblings[siblings.length - 1]
              before.value += prev.value + value
              prev = before
              block.ranges--
              continue
            }

            push({ type: 'dot', value })
            continue
          }

          /**
           * Text
           */

          push({ type: 'text', value })
        }

        // Mark imbalanced braces and brackets as invalid
        do {
          block = stack.pop()

          if (block.type !== 'root') {
            block.nodes.forEach(node => {
              if (!node.nodes) {
                if (node.type === 'open') node.isOpen = true
                if (node.type === 'close') node.isClose = true
                if (!node.nodes) node.type = 'text'
                node.invalid = true
              }
            })

            // get the location of the block on parent.nodes (block's siblings)
            let parent = stack[stack.length - 1]
            let index = parent.nodes.indexOf(block)
            // replace the (invalid) block with it's nodes
            parent.nodes.splice(index, 1, ...block.nodes)
          }
        } while (stack.length > 0)

        push({ type: 'eos' })
        return ast
      }

      module.exports = parse

      /***/
    },

    /***/ 8750: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const utils = __nccwpck_require__(5207)

      module.exports = (ast, options = {}) => {
        let stringify = (node, parent = {}) => {
          let invalidBlock =
            options.escapeInvalid && utils.isInvalidBrace(parent)
          let invalidNode =
            node.invalid === true && options.escapeInvalid === true
          let output = ''

          if (node.value) {
            if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
              return '\\' + node.value
            }
            return node.value
          }

          if (node.value) {
            return node.value
          }

          if (node.nodes) {
            for (let child of node.nodes) {
              output += stringify(child)
            }
          }
          return output
        }

        return stringify(ast)
      }

      /***/
    },

    /***/ 5207: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      exports.isInteger = num => {
        if (typeof num === 'number') {
          return Number.isInteger(num)
        }
        if (typeof num === 'string' && num.trim() !== '') {
          return Number.isInteger(Number(num))
        }
        return false
      }

      /**
       * Find a node of the given type
       */

      exports.find = (node, type) => node.nodes.find(node => node.type === type)

      /**
       * Find a node of the given type
       */

      exports.exceedsLimit = (min, max, step = 1, limit) => {
        if (limit === false) return false
        if (!exports.isInteger(min) || !exports.isInteger(max)) return false
        return (Number(max) - Number(min)) / Number(step) >= limit
      }

      /**
       * Escape the given node with '\\' before node.value
       */

      exports.escapeNode = (block, n = 0, type) => {
        let node = block.nodes[n]
        if (!node) return

        if (
          (type && node.type === type) ||
          node.type === 'open' ||
          node.type === 'close'
        ) {
          if (node.escaped !== true) {
            node.value = '\\' + node.value
            node.escaped = true
          }
        }
      }

      /**
       * Returns true if the given brace node should be enclosed in literal braces
       */

      exports.encloseBrace = node => {
        if (node.type !== 'brace') return false
        if ((node.commas >> (0 + node.ranges)) >> 0 === 0) {
          node.invalid = true
          return true
        }
        return false
      }

      /**
       * Returns true if a brace node is invalid.
       */

      exports.isInvalidBrace = block => {
        if (block.type !== 'brace') return false
        if (block.invalid === true || block.dollar) return true
        if ((block.commas >> (0 + block.ranges)) >> 0 === 0) {
          block.invalid = true
          return true
        }
        if (block.open !== true || block.close !== true) {
          block.invalid = true
          return true
        }
        return false
      }

      /**
       * Returns true if a node is an open or close node
       */

      exports.isOpenOrClose = node => {
        if (node.type === 'open' || node.type === 'close') {
          return true
        }
        return node.open === true || node.close === true
      }

      /**
       * Reduce an array of text nodes.
       */

      exports.reduce = nodes =>
        nodes.reduce((acc, node) => {
          if (node.type === 'text') acc.push(node.value)
          if (node.type === 'range') node.type = 'text'
          return acc
        }, [])

      /**
       * Flatten an array
       */

      exports.flatten = (...args) => {
        const result = []
        const flat = arr => {
          for (let i = 0; i < arr.length; i++) {
            let ele = arr[i]
            Array.isArray(ele)
              ? flat(ele, result)
              : ele !== void 0 && result.push(ele)
          }
          return result
        }
        flat(args)
        return result
      }

      /***/
    },

    /***/ 2738: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const path = __nccwpck_require__(1017)
      const pathType = __nccwpck_require__(3433)

      const getExtensions = extensions =>
        extensions.length > 1 ? `{${extensions.join(',')}}` : extensions[0]

      const getPath = (filepath, cwd) => {
        const pth = filepath[0] === '!' ? filepath.slice(1) : filepath
        return path.isAbsolute(pth) ? pth : path.join(cwd, pth)
      }

      const addExtensions = (file, extensions) => {
        if (path.extname(file)) {
          return `**/${file}`
        }

        return `**/${file}.${getExtensions(extensions)}`
      }

      const getGlob = (directory, options) => {
        if (options.files && !Array.isArray(options.files)) {
          throw new TypeError(
            `Expected \`files\` to be of type \`Array\` but received type \`${typeof options.files}\``
          )
        }

        if (options.extensions && !Array.isArray(options.extensions)) {
          throw new TypeError(
            `Expected \`extensions\` to be of type \`Array\` but received type \`${typeof options.extensions}\``
          )
        }

        if (options.files && options.extensions) {
          return options.files.map(x =>
            path.posix.join(directory, addExtensions(x, options.extensions))
          )
        }

        if (options.files) {
          return options.files.map(x => path.posix.join(directory, `**/${x}`))
        }

        if (options.extensions) {
          return [
            path.posix.join(
              directory,
              `**/*.${getExtensions(options.extensions)}`
            ),
          ]
        }

        return [path.posix.join(directory, '**')]
      }

      module.exports = async (input, options) => {
        options = {
          cwd: process.cwd(),
          ...options,
        }

        if (typeof options.cwd !== 'string') {
          throw new TypeError(
            `Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``
          )
        }

        const globs = await Promise.all(
          [].concat(input).map(async x => {
            const isDirectory = await pathType.isDirectory(
              getPath(x, options.cwd)
            )
            return isDirectory ? getGlob(x, options) : x
          })
        )

        return [].concat.apply([], globs) // eslint-disable-line prefer-spread
      }

      module.exports.sync = (input, options) => {
        options = {
          cwd: process.cwd(),
          ...options,
        }

        if (typeof options.cwd !== 'string') {
          throw new TypeError(
            `Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``
          )
        }

        const globs = []
          .concat(input)
          .map(x =>
            pathType.isDirectorySync(getPath(x, options.cwd))
              ? getGlob(x, options)
              : x
          )

        return [].concat.apply([], globs) // eslint-disable-line prefer-spread
      }

      /***/
    },

    /***/ 8691: /***/ module => {
      'use strict'

      var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g

      module.exports = function (str) {
        if (typeof str !== 'string') {
          throw new TypeError('Expected a string')
        }

        return str.replace(matchOperatorsRe, '\\$&')
      }

      /***/
    },

    /***/ 8355: /***/ function (__unused_webpack_module, exports) {
      'use strict'

      var __extends =
        (this && this.__extends) ||
        (function () {
          var extendStatics =
            Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array &&
              function (d, b) {
                d.__proto__ = b
              }) ||
            function (d, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]
            }
          return function (d, b) {
            extendStatics(d, b)
            function __() {
              this.constructor = d
            }
            d.prototype =
              b === null
                ? Object.create(b)
                : ((__.prototype = b.prototype), new __())
          }
        })()
      Object.defineProperty(exports, '__esModule', { value: true })
      var ExtendableError = /** @class */ (function (_super) {
        __extends(ExtendableError, _super)
        function ExtendableError(message) {
          var _newTarget = this.constructor
          if (message === void 0) {
            message = ''
          }
          var _this = _super.call(this, message) || this
          _this.message = message
          Object.setPrototypeOf(_this, _newTarget.prototype)
          delete _this.stack
          _this.name = _newTarget.name
          _this._error = new Error()
          return _this
        }
        Object.defineProperty(ExtendableError.prototype, 'stack', {
          get: function () {
            if (this._stack) {
              return this._stack
            }
            var prototype = Object.getPrototypeOf(this)
            var depth = 1
            loop: while (prototype) {
              switch (prototype) {
                case ExtendableError.prototype:
                  break loop
                case Object.prototype:
                  depth = 1
                  break loop
                default:
                  depth++
                  break
              }
              prototype = Object.getPrototypeOf(prototype)
            }
            var stackLines = (this._error.stack || '').match(/.+/g) || []
            var nameLine = this.name
            if (this.message) {
              nameLine += ': ' + this.message
            }
            stackLines.splice(0, depth + 1, nameLine)
            return (this._stack = stackLines.join('\n'))
          },
          enumerable: true,
          configurable: true,
        })
        return ExtendableError
      })(Error)
      exports.ExtendableError = ExtendableError
      exports['default'] = ExtendableError
      //# sourceMappingURL=index.js.map

      /***/
    },

    /***/ 3664: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const taskManager = __nccwpck_require__(2708)
      const patternManager = __nccwpck_require__(8306)
      const async_1 = __nccwpck_require__(5679)
      const stream_1 = __nccwpck_require__(4630)
      const sync_1 = __nccwpck_require__(2405)
      const settings_1 = __nccwpck_require__(952)
      const utils = __nccwpck_require__(5444)
      async function FastGlob(source, options) {
        assertPatternsInput(source)
        const works = getWorks(source, async_1.default, options)
        const result = await Promise.all(works)
        return utils.array.flatten(result)
      }
      // https://github.com/typescript-eslint/typescript-eslint/issues/60
      // eslint-disable-next-line no-redeclare
      ;(function (FastGlob) {
        function sync(source, options) {
          assertPatternsInput(source)
          const works = getWorks(source, sync_1.default, options)
          return utils.array.flatten(works)
        }
        FastGlob.sync = sync
        function stream(source, options) {
          assertPatternsInput(source)
          const works = getWorks(source, stream_1.default, options)
          /**
           * The stream returned by the provider cannot work with an asynchronous iterator.
           * To support asynchronous iterators, regardless of the number of tasks, we always multiplex streams.
           * This affects performance (+25%). I don't see best solution right now.
           */
          return utils.stream.merge(works)
        }
        FastGlob.stream = stream
        function generateTasks(source, options) {
          assertPatternsInput(source)
          const patterns = patternManager.transform([].concat(source))
          const settings = new settings_1.default(options)
          return taskManager.generate(patterns, settings)
        }
        FastGlob.generateTasks = generateTasks
        function isDynamicPattern(source, options) {
          assertPatternsInput(source)
          const settings = new settings_1.default(options)
          return utils.pattern.isDynamicPattern(source, settings)
        }
        FastGlob.isDynamicPattern = isDynamicPattern
        function escapePath(source) {
          assertPatternsInput(source)
          return utils.path.escape(source)
        }
        FastGlob.escapePath = escapePath
      })(FastGlob || (FastGlob = {}))
      function getWorks(source, _Provider, options) {
        const patterns = patternManager.transform([].concat(source))
        const settings = new settings_1.default(options)
        const tasks = taskManager.generate(patterns, settings)
        const provider = new _Provider(settings)
        return tasks.map(provider.read, provider)
      }
      function assertPatternsInput(input) {
        const source = [].concat(input)
        const isValidSource = source.every(
          item => utils.string.isString(item) && !utils.string.isEmpty(item)
        )
        if (!isValidSource) {
          throw new TypeError(
            'Patterns must be a string (non empty) or an array of strings'
          )
        }
      }
      module.exports = FastGlob

      /***/
    },

    /***/ 8306: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.removeDuplicateSlashes = exports.transform = void 0
      /**
       * Matches a sequence of two or more consecutive slashes, excluding the first two slashes at the beginning of the string.
       * The latter is due to the presence of the device path at the beginning of the UNC path.
       * @todo rewrite to negative lookbehind with the next major release.
       */
      const DOUBLE_SLASH_RE = /(?!^)\/{2,}/g
      function transform(patterns) {
        return patterns.map(pattern => removeDuplicateSlashes(pattern))
      }
      exports.transform = transform
      /**
       * This package only works with forward slashes as a path separator.
       * Because of this, we cannot use the standard `path.normalize` method, because on Windows platform it will use of backslashes.
       */
      function removeDuplicateSlashes(pattern) {
        return pattern.replace(DOUBLE_SLASH_RE, '/')
      }
      exports.removeDuplicateSlashes = removeDuplicateSlashes

      /***/
    },

    /***/ 2708: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.convertPatternGroupToTask =
        exports.convertPatternGroupsToTasks =
        exports.groupPatternsByBaseDirectory =
        exports.getNegativePatternsAsPositive =
        exports.getPositivePatterns =
        exports.convertPatternsToTasks =
        exports.generate =
          void 0
      const utils = __nccwpck_require__(5444)
      function generate(patterns, settings) {
        const positivePatterns = getPositivePatterns(patterns)
        const negativePatterns = getNegativePatternsAsPositive(
          patterns,
          settings.ignore
        )
        const staticPatterns = positivePatterns.filter(pattern =>
          utils.pattern.isStaticPattern(pattern, settings)
        )
        const dynamicPatterns = positivePatterns.filter(pattern =>
          utils.pattern.isDynamicPattern(pattern, settings)
        )
        const staticTasks = convertPatternsToTasks(
          staticPatterns,
          negativePatterns,
          /* dynamic */ false
        )
        const dynamicTasks = convertPatternsToTasks(
          dynamicPatterns,
          negativePatterns,
          /* dynamic */ true
        )
        return staticTasks.concat(dynamicTasks)
      }
      exports.generate = generate
      /**
       * Returns tasks grouped by basic pattern directories.
       *
       * Patterns that can be found inside (`./`) and outside (`../`) the current directory are handled separately.
       * This is necessary because directory traversal starts at the base directory and goes deeper.
       */
      function convertPatternsToTasks(positive, negative, dynamic) {
        const tasks = []
        const patternsOutsideCurrentDirectory =
          utils.pattern.getPatternsOutsideCurrentDirectory(positive)
        const patternsInsideCurrentDirectory =
          utils.pattern.getPatternsInsideCurrentDirectory(positive)
        const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(
          patternsOutsideCurrentDirectory
        )
        const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(
          patternsInsideCurrentDirectory
        )
        tasks.push(
          ...convertPatternGroupsToTasks(
            outsideCurrentDirectoryGroup,
            negative,
            dynamic
          )
        )
        /*
         * For the sake of reducing future accesses to the file system, we merge all tasks within the current directory
         * into a global task, if at least one pattern refers to the root (`.`). In this case, the global task covers the rest.
         */
        if ('.' in insideCurrentDirectoryGroup) {
          tasks.push(
            convertPatternGroupToTask(
              '.',
              patternsInsideCurrentDirectory,
              negative,
              dynamic
            )
          )
        } else {
          tasks.push(
            ...convertPatternGroupsToTasks(
              insideCurrentDirectoryGroup,
              negative,
              dynamic
            )
          )
        }
        return tasks
      }
      exports.convertPatternsToTasks = convertPatternsToTasks
      function getPositivePatterns(patterns) {
        return utils.pattern.getPositivePatterns(patterns)
      }
      exports.getPositivePatterns = getPositivePatterns
      function getNegativePatternsAsPositive(patterns, ignore) {
        const negative = utils.pattern
          .getNegativePatterns(patterns)
          .concat(ignore)
        const positive = negative.map(utils.pattern.convertToPositivePattern)
        return positive
      }
      exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive
      function groupPatternsByBaseDirectory(patterns) {
        const group = {}
        return patterns.reduce((collection, pattern) => {
          const base = utils.pattern.getBaseDirectory(pattern)
          if (base in collection) {
            collection[base].push(pattern)
          } else {
            collection[base] = [pattern]
          }
          return collection
        }, group)
      }
      exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory
      function convertPatternGroupsToTasks(positive, negative, dynamic) {
        return Object.keys(positive).map(base => {
          return convertPatternGroupToTask(
            base,
            positive[base],
            negative,
            dynamic
          )
        })
      }
      exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks
      function convertPatternGroupToTask(base, positive, negative, dynamic) {
        return {
          dynamic,
          positive,
          negative,
          base,
          patterns: [].concat(
            positive,
            negative.map(utils.pattern.convertToNegativePattern)
          ),
        }
      }
      exports.convertPatternGroupToTask = convertPatternGroupToTask

      /***/
    },

    /***/ 5679: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const stream_1 = __nccwpck_require__(2083)
      const provider_1 = __nccwpck_require__(257)
      class ProviderAsync extends provider_1.default {
        constructor() {
          super(...arguments)
          this._reader = new stream_1.default(this._settings)
        }
        read(task) {
          const root = this._getRootDirectory(task)
          const options = this._getReaderOptions(task)
          const entries = []
          return new Promise((resolve, reject) => {
            const stream = this.api(root, task, options)
            stream.once('error', reject)
            stream.on('data', entry => entries.push(options.transform(entry)))
            stream.once('end', () => resolve(entries))
          })
        }
        api(root, task, options) {
          if (task.dynamic) {
            return this._reader.dynamic(root, options)
          }
          return this._reader.static(task.patterns, options)
        }
      }
      exports['default'] = ProviderAsync

      /***/
    },

    /***/ 6983: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const utils = __nccwpck_require__(5444)
      const partial_1 = __nccwpck_require__(5295)
      class DeepFilter {
        constructor(_settings, _micromatchOptions) {
          this._settings = _settings
          this._micromatchOptions = _micromatchOptions
        }
        getFilter(basePath, positive, negative) {
          const matcher = this._getMatcher(positive)
          const negativeRe = this._getNegativePatternsRe(negative)
          return entry => this._filter(basePath, entry, matcher, negativeRe)
        }
        _getMatcher(patterns) {
          return new partial_1.default(
            patterns,
            this._settings,
            this._micromatchOptions
          )
        }
        _getNegativePatternsRe(patterns) {
          const affectDepthOfReadingPatterns = patterns.filter(
            utils.pattern.isAffectDepthOfReadingPattern
          )
          return utils.pattern.convertPatternsToRe(
            affectDepthOfReadingPatterns,
            this._micromatchOptions
          )
        }
        _filter(basePath, entry, matcher, negativeRe) {
          if (this._isSkippedByDeep(basePath, entry.path)) {
            return false
          }
          if (this._isSkippedSymbolicLink(entry)) {
            return false
          }
          const filepath = utils.path.removeLeadingDotSegment(entry.path)
          if (this._isSkippedByPositivePatterns(filepath, matcher)) {
            return false
          }
          return this._isSkippedByNegativePatterns(filepath, negativeRe)
        }
        _isSkippedByDeep(basePath, entryPath) {
          /**
           * Avoid unnecessary depth calculations when it doesn't matter.
           */
          if (this._settings.deep === Infinity) {
            return false
          }
          return this._getEntryLevel(basePath, entryPath) >= this._settings.deep
        }
        _getEntryLevel(basePath, entryPath) {
          const entryPathDepth = entryPath.split('/').length
          if (basePath === '') {
            return entryPathDepth
          }
          const basePathDepth = basePath.split('/').length
          return entryPathDepth - basePathDepth
        }
        _isSkippedSymbolicLink(entry) {
          return (
            !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink()
          )
        }
        _isSkippedByPositivePatterns(entryPath, matcher) {
          return !this._settings.baseNameMatch && !matcher.match(entryPath)
        }
        _isSkippedByNegativePatterns(entryPath, patternsRe) {
          return !utils.pattern.matchAny(entryPath, patternsRe)
        }
      }
      exports['default'] = DeepFilter

      /***/
    },

    /***/ 1343: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const utils = __nccwpck_require__(5444)
      class EntryFilter {
        constructor(_settings, _micromatchOptions) {
          this._settings = _settings
          this._micromatchOptions = _micromatchOptions
          this.index = new Map()
        }
        getFilter(positive, negative) {
          const positiveRe = utils.pattern.convertPatternsToRe(
            positive,
            this._micromatchOptions
          )
          const negativeRe = utils.pattern.convertPatternsToRe(
            negative,
            this._micromatchOptions
          )
          return entry => this._filter(entry, positiveRe, negativeRe)
        }
        _filter(entry, positiveRe, negativeRe) {
          if (this._settings.unique && this._isDuplicateEntry(entry)) {
            return false
          }
          if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
            return false
          }
          if (
            this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)
          ) {
            return false
          }
          const filepath = this._settings.baseNameMatch
            ? entry.name
            : entry.path
          const isMatched =
            this._isMatchToPatterns(filepath, positiveRe) &&
            !this._isMatchToPatterns(entry.path, negativeRe)
          if (this._settings.unique && isMatched) {
            this._createIndexRecord(entry)
          }
          return isMatched
        }
        _isDuplicateEntry(entry) {
          return this.index.has(entry.path)
        }
        _createIndexRecord(entry) {
          this.index.set(entry.path, undefined)
        }
        _onlyFileFilter(entry) {
          return this._settings.onlyFiles && !entry.dirent.isFile()
        }
        _onlyDirectoryFilter(entry) {
          return this._settings.onlyDirectories && !entry.dirent.isDirectory()
        }
        _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
          if (!this._settings.absolute) {
            return false
          }
          const fullpath = utils.path.makeAbsolute(
            this._settings.cwd,
            entryPath
          )
          return utils.pattern.matchAny(fullpath, patternsRe)
        }
        /**
         * First, just trying to apply patterns to the path.
         * Second, trying to apply patterns to the path with final slash.
         */
        _isMatchToPatterns(entryPath, patternsRe) {
          const filepath = utils.path.removeLeadingDotSegment(entryPath)
          return (
            utils.pattern.matchAny(filepath, patternsRe) ||
            utils.pattern.matchAny(filepath + '/', patternsRe)
          )
        }
      }
      exports['default'] = EntryFilter

      /***/
    },

    /***/ 6654: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const utils = __nccwpck_require__(5444)
      class ErrorFilter {
        constructor(_settings) {
          this._settings = _settings
        }
        getFilter() {
          return error => this._isNonFatalError(error)
        }
        _isNonFatalError(error) {
          return (
            utils.errno.isEnoentCodeError(error) ||
            this._settings.suppressErrors
          )
        }
      }
      exports['default'] = ErrorFilter

      /***/
    },

    /***/ 2576: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const utils = __nccwpck_require__(5444)
      class Matcher {
        constructor(_patterns, _settings, _micromatchOptions) {
          this._patterns = _patterns
          this._settings = _settings
          this._micromatchOptions = _micromatchOptions
          this._storage = []
          this._fillStorage()
        }
        _fillStorage() {
          /**
           * The original pattern may include `{,*,**,a/*}`, which will lead to problems with matching (unresolved level).
           * So, before expand patterns with brace expansion into separated patterns.
           */
          const patterns = utils.pattern.expandPatternsWithBraceExpansion(
            this._patterns
          )
          for (const pattern of patterns) {
            const segments = this._getPatternSegments(pattern)
            const sections = this._splitSegmentsIntoSections(segments)
            this._storage.push({
              complete: sections.length <= 1,
              pattern,
              segments,
              sections,
            })
          }
        }
        _getPatternSegments(pattern) {
          const parts = utils.pattern.getPatternParts(
            pattern,
            this._micromatchOptions
          )
          return parts.map(part => {
            const dynamic = utils.pattern.isDynamicPattern(part, this._settings)
            if (!dynamic) {
              return {
                dynamic: false,
                pattern: part,
              }
            }
            return {
              dynamic: true,
              pattern: part,
              patternRe: utils.pattern.makeRe(part, this._micromatchOptions),
            }
          })
        }
        _splitSegmentsIntoSections(segments) {
          return utils.array.splitWhen(
            segments,
            segment =>
              segment.dynamic && utils.pattern.hasGlobStar(segment.pattern)
          )
        }
      }
      exports['default'] = Matcher

      /***/
    },

    /***/ 5295: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const matcher_1 = __nccwpck_require__(2576)
      class PartialMatcher extends matcher_1.default {
        match(filepath) {
          const parts = filepath.split('/')
          const levels = parts.length
          const patterns = this._storage.filter(
            info => !info.complete || info.segments.length > levels
          )
          for (const pattern of patterns) {
            const section = pattern.sections[0]
            /**
             * In this case, the pattern has a globstar and we must read all directories unconditionally,
             * but only if the level has reached the end of the first group.
             *
             * fixtures/{a,b}/**
             *  ^ true/false  ^ always true
             */
            if (!pattern.complete && levels > section.length) {
              return true
            }
            const match = parts.every((part, index) => {
              const segment = pattern.segments[index]
              if (segment.dynamic && segment.patternRe.test(part)) {
                return true
              }
              if (!segment.dynamic && segment.pattern === part) {
                return true
              }
              return false
            })
            if (match) {
              return true
            }
          }
          return false
        }
      }
      exports['default'] = PartialMatcher

      /***/
    },

    /***/ 257: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const path = __nccwpck_require__(1017)
      const deep_1 = __nccwpck_require__(6983)
      const entry_1 = __nccwpck_require__(1343)
      const error_1 = __nccwpck_require__(6654)
      const entry_2 = __nccwpck_require__(4029)
      class Provider {
        constructor(_settings) {
          this._settings = _settings
          this.errorFilter = new error_1.default(this._settings)
          this.entryFilter = new entry_1.default(
            this._settings,
            this._getMicromatchOptions()
          )
          this.deepFilter = new deep_1.default(
            this._settings,
            this._getMicromatchOptions()
          )
          this.entryTransformer = new entry_2.default(this._settings)
        }
        _getRootDirectory(task) {
          return path.resolve(this._settings.cwd, task.base)
        }
        _getReaderOptions(task) {
          const basePath = task.base === '.' ? '' : task.base
          return {
            basePath,
            pathSegmentSeparator: '/',
            concurrency: this._settings.concurrency,
            deepFilter: this.deepFilter.getFilter(
              basePath,
              task.positive,
              task.negative
            ),
            entryFilter: this.entryFilter.getFilter(
              task.positive,
              task.negative
            ),
            errorFilter: this.errorFilter.getFilter(),
            followSymbolicLinks: this._settings.followSymbolicLinks,
            fs: this._settings.fs,
            stats: this._settings.stats,
            throwErrorOnBrokenSymbolicLink:
              this._settings.throwErrorOnBrokenSymbolicLink,
            transform: this.entryTransformer.getTransformer(),
          }
        }
        _getMicromatchOptions() {
          return {
            dot: this._settings.dot,
            matchBase: this._settings.baseNameMatch,
            nobrace: !this._settings.braceExpansion,
            nocase: !this._settings.caseSensitiveMatch,
            noext: !this._settings.extglob,
            noglobstar: !this._settings.globstar,
            posix: true,
            strictSlashes: false,
          }
        }
      }
      exports['default'] = Provider

      /***/
    },

    /***/ 4630: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const stream_1 = __nccwpck_require__(2781)
      const stream_2 = __nccwpck_require__(2083)
      const provider_1 = __nccwpck_require__(257)
      class ProviderStream extends provider_1.default {
        constructor() {
          super(...arguments)
          this._reader = new stream_2.default(this._settings)
        }
        read(task) {
          const root = this._getRootDirectory(task)
          const options = this._getReaderOptions(task)
          const source = this.api(root, task, options)
          const destination = new stream_1.Readable({
            objectMode: true,
            read: () => {},
          })
          source
            .once('error', error => destination.emit('error', error))
            .on('data', entry =>
              destination.emit('data', options.transform(entry))
            )
            .once('end', () => destination.emit('end'))
          destination.once('close', () => source.destroy())
          return destination
        }
        api(root, task, options) {
          if (task.dynamic) {
            return this._reader.dynamic(root, options)
          }
          return this._reader.static(task.patterns, options)
        }
      }
      exports['default'] = ProviderStream

      /***/
    },

    /***/ 2405: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const sync_1 = __nccwpck_require__(6234)
      const provider_1 = __nccwpck_require__(257)
      class ProviderSync extends provider_1.default {
        constructor() {
          super(...arguments)
          this._reader = new sync_1.default(this._settings)
        }
        read(task) {
          const root = this._getRootDirectory(task)
          const options = this._getReaderOptions(task)
          const entries = this.api(root, task, options)
          return entries.map(options.transform)
        }
        api(root, task, options) {
          if (task.dynamic) {
            return this._reader.dynamic(root, options)
          }
          return this._reader.static(task.patterns, options)
        }
      }
      exports['default'] = ProviderSync

      /***/
    },

    /***/ 4029: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const utils = __nccwpck_require__(5444)
      class EntryTransformer {
        constructor(_settings) {
          this._settings = _settings
        }
        getTransformer() {
          return entry => this._transform(entry)
        }
        _transform(entry) {
          let filepath = entry.path
          if (this._settings.absolute) {
            filepath = utils.path.makeAbsolute(this._settings.cwd, filepath)
            filepath = utils.path.unixify(filepath)
          }
          if (this._settings.markDirectories && entry.dirent.isDirectory()) {
            filepath += '/'
          }
          if (!this._settings.objectMode) {
            return filepath
          }
          return Object.assign(Object.assign({}, entry), { path: filepath })
        }
      }
      exports['default'] = EntryTransformer

      /***/
    },

    /***/ 5582: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const path = __nccwpck_require__(1017)
      const fsStat = __nccwpck_require__(109)
      const utils = __nccwpck_require__(5444)
      class Reader {
        constructor(_settings) {
          this._settings = _settings
          this._fsStatSettings = new fsStat.Settings({
            followSymbolicLink: this._settings.followSymbolicLinks,
            fs: this._settings.fs,
            throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks,
          })
        }
        _getFullEntryPath(filepath) {
          return path.resolve(this._settings.cwd, filepath)
        }
        _makeEntry(stats, pattern) {
          const entry = {
            name: pattern,
            path: pattern,
            dirent: utils.fs.createDirentFromStats(pattern, stats),
          }
          if (this._settings.stats) {
            entry.stats = stats
          }
          return entry
        }
        _isFatalError(error) {
          return (
            !utils.errno.isEnoentCodeError(error) &&
            !this._settings.suppressErrors
          )
        }
      }
      exports['default'] = Reader

      /***/
    },

    /***/ 2083: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const stream_1 = __nccwpck_require__(2781)
      const fsStat = __nccwpck_require__(109)
      const fsWalk = __nccwpck_require__(6026)
      const reader_1 = __nccwpck_require__(5582)
      class ReaderStream extends reader_1.default {
        constructor() {
          super(...arguments)
          this._walkStream = fsWalk.walkStream
          this._stat = fsStat.stat
        }
        dynamic(root, options) {
          return this._walkStream(root, options)
        }
        static(patterns, options) {
          const filepaths = patterns.map(this._getFullEntryPath, this)
          const stream = new stream_1.PassThrough({ objectMode: true })
          stream._write = (index, _enc, done) => {
            return this._getEntry(filepaths[index], patterns[index], options)
              .then(entry => {
                if (entry !== null && options.entryFilter(entry)) {
                  stream.push(entry)
                }
                if (index === filepaths.length - 1) {
                  stream.end()
                }
                done()
              })
              .catch(done)
          }
          for (let i = 0; i < filepaths.length; i++) {
            stream.write(i)
          }
          return stream
        }
        _getEntry(filepath, pattern, options) {
          return this._getStat(filepath)
            .then(stats => this._makeEntry(stats, pattern))
            .catch(error => {
              if (options.errorFilter(error)) {
                return null
              }
              throw error
            })
        }
        _getStat(filepath) {
          return new Promise((resolve, reject) => {
            this._stat(filepath, this._fsStatSettings, (error, stats) => {
              return error === null ? resolve(stats) : reject(error)
            })
          })
        }
      }
      exports['default'] = ReaderStream

      /***/
    },

    /***/ 6234: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      const fsStat = __nccwpck_require__(109)
      const fsWalk = __nccwpck_require__(6026)
      const reader_1 = __nccwpck_require__(5582)
      class ReaderSync extends reader_1.default {
        constructor() {
          super(...arguments)
          this._walkSync = fsWalk.walkSync
          this._statSync = fsStat.statSync
        }
        dynamic(root, options) {
          return this._walkSync(root, options)
        }
        static(patterns, options) {
          const entries = []
          for (const pattern of patterns) {
            const filepath = this._getFullEntryPath(pattern)
            const entry = this._getEntry(filepath, pattern, options)
            if (entry === null || !options.entryFilter(entry)) {
              continue
            }
            entries.push(entry)
          }
          return entries
        }
        _getEntry(filepath, pattern, options) {
          try {
            const stats = this._getStat(filepath)
            return this._makeEntry(stats, pattern)
          } catch (error) {
            if (options.errorFilter(error)) {
              return null
            }
            throw error
          }
        }
        _getStat(filepath) {
          return this._statSync(filepath, this._fsStatSettings)
        }
      }
      exports['default'] = ReaderSync

      /***/
    },

    /***/ 952: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0
      const fs = __nccwpck_require__(7147)
      const os = __nccwpck_require__(2037)
      /**
       * The `os.cpus` method can return zero. We expect the number of cores to be greater than zero.
       * https://github.com/nodejs/node/blob/7faeddf23a98c53896f8b574a6e66589e8fb1eb8/lib/os.js#L106-L107
       */
      const CPU_COUNT = Math.max(os.cpus().length, 1)
      exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
        lstat: fs.lstat,
        lstatSync: fs.lstatSync,
        stat: fs.stat,
        statSync: fs.statSync,
        readdir: fs.readdir,
        readdirSync: fs.readdirSync,
      }
      class Settings {
        constructor(_options = {}) {
          this._options = _options
          this.absolute = this._getValue(this._options.absolute, false)
          this.baseNameMatch = this._getValue(
            this._options.baseNameMatch,
            false
          )
          this.braceExpansion = this._getValue(
            this._options.braceExpansion,
            true
          )
          this.caseSensitiveMatch = this._getValue(
            this._options.caseSensitiveMatch,
            true
          )
          this.concurrency = this._getValue(
            this._options.concurrency,
            CPU_COUNT
          )
          this.cwd = this._getValue(this._options.cwd, process.cwd())
          this.deep = this._getValue(this._options.deep, Infinity)
          this.dot = this._getValue(this._options.dot, false)
          this.extglob = this._getValue(this._options.extglob, true)
          this.followSymbolicLinks = this._getValue(
            this._options.followSymbolicLinks,
            true
          )
          this.fs = this._getFileSystemMethods(this._options.fs)
          this.globstar = this._getValue(this._options.globstar, true)
          this.ignore = this._getValue(this._options.ignore, [])
          this.markDirectories = this._getValue(
            this._options.markDirectories,
            false
          )
          this.objectMode = this._getValue(this._options.objectMode, false)
          this.onlyDirectories = this._getValue(
            this._options.onlyDirectories,
            false
          )
          this.onlyFiles = this._getValue(this._options.onlyFiles, true)
          this.stats = this._getValue(this._options.stats, false)
          this.suppressErrors = this._getValue(
            this._options.suppressErrors,
            false
          )
          this.throwErrorOnBrokenSymbolicLink = this._getValue(
            this._options.throwErrorOnBrokenSymbolicLink,
            false
          )
          this.unique = this._getValue(this._options.unique, true)
          if (this.onlyDirectories) {
            this.onlyFiles = false
          }
          if (this.stats) {
            this.objectMode = true
          }
        }
        _getValue(option, value) {
          return option === undefined ? value : option
        }
        _getFileSystemMethods(methods = {}) {
          return Object.assign(
            Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER),
            methods
          )
        }
      }
      exports['default'] = Settings

      /***/
    },

    /***/ 5325: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.splitWhen = exports.flatten = void 0
      function flatten(items) {
        return items.reduce(
          (collection, item) => [].concat(collection, item),
          []
        )
      }
      exports.flatten = flatten
      function splitWhen(items, predicate) {
        const result = [[]]
        let groupIndex = 0
        for (const item of items) {
          if (predicate(item)) {
            groupIndex++
            result[groupIndex] = []
          } else {
            result[groupIndex].push(item)
          }
        }
        return result
      }
      exports.splitWhen = splitWhen

      /***/
    },

    /***/ 1230: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.isEnoentCodeError = void 0
      function isEnoentCodeError(error) {
        return error.code === 'ENOENT'
      }
      exports.isEnoentCodeError = isEnoentCodeError

      /***/
    },

    /***/ 7543: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.createDirentFromStats = void 0
      class DirentFromStats {
        constructor(name, stats) {
          this.name = name
          this.isBlockDevice = stats.isBlockDevice.bind(stats)
          this.isCharacterDevice = stats.isCharacterDevice.bind(stats)
          this.isDirectory = stats.isDirectory.bind(stats)
          this.isFIFO = stats.isFIFO.bind(stats)
          this.isFile = stats.isFile.bind(stats)
          this.isSocket = stats.isSocket.bind(stats)
          this.isSymbolicLink = stats.isSymbolicLink.bind(stats)
        }
      }
      function createDirentFromStats(name, stats) {
        return new DirentFromStats(name, stats)
      }
      exports.createDirentFromStats = createDirentFromStats

      /***/
    },

    /***/ 5444: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.string =
        exports.stream =
        exports.pattern =
        exports.path =
        exports.fs =
        exports.errno =
        exports.array =
          void 0
      const array = __nccwpck_require__(5325)
      exports.array = array
      const errno = __nccwpck_require__(1230)
      exports.errno = errno
      const fs = __nccwpck_require__(7543)
      exports.fs = fs
      const path = __nccwpck_require__(3873)
      exports.path = path
      const pattern = __nccwpck_require__(1221)
      exports.pattern = pattern
      const stream = __nccwpck_require__(8382)
      exports.stream = stream
      const string = __nccwpck_require__(2203)
      exports.string = string

      /***/
    },

    /***/ 3873: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.removeLeadingDotSegment =
        exports.escape =
        exports.makeAbsolute =
        exports.unixify =
          void 0
      const path = __nccwpck_require__(1017)
      const LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2 // ./ or .\\
      const UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g
      /**
       * Designed to work only with simple paths: `dir\\file`.
       */
      function unixify(filepath) {
        return filepath.replace(/\\/g, '/')
      }
      exports.unixify = unixify
      function makeAbsolute(cwd, filepath) {
        return path.resolve(cwd, filepath)
      }
      exports.makeAbsolute = makeAbsolute
      function escape(pattern) {
        return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, '\\$2')
      }
      exports.escape = escape
      function removeLeadingDotSegment(entry) {
        // We do not use `startsWith` because this is 10x slower than current implementation for some cases.
        // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
        if (entry.charAt(0) === '.') {
          const secondCharactery = entry.charAt(1)
          if (secondCharactery === '/' || secondCharactery === '\\') {
            return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT)
          }
        }
        return entry
      }
      exports.removeLeadingDotSegment = removeLeadingDotSegment

      /***/
    },

    /***/ 1221: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.matchAny =
        exports.convertPatternsToRe =
        exports.makeRe =
        exports.getPatternParts =
        exports.expandBraceExpansion =
        exports.expandPatternsWithBraceExpansion =
        exports.isAffectDepthOfReadingPattern =
        exports.endsWithSlashGlobStar =
        exports.hasGlobStar =
        exports.getBaseDirectory =
        exports.isPatternRelatedToParentDirectory =
        exports.getPatternsOutsideCurrentDirectory =
        exports.getPatternsInsideCurrentDirectory =
        exports.getPositivePatterns =
        exports.getNegativePatterns =
        exports.isPositivePattern =
        exports.isNegativePattern =
        exports.convertToNegativePattern =
        exports.convertToPositivePattern =
        exports.isDynamicPattern =
        exports.isStaticPattern =
          void 0
      const path = __nccwpck_require__(1017)
      const globParent = __nccwpck_require__(4655)
      const micromatch = __nccwpck_require__(6228)
      const GLOBSTAR = '**'
      const ESCAPE_SYMBOL = '\\'
      const COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/
      const REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/
      const REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/
      const GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/
      const BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./
      function isStaticPattern(pattern, options = {}) {
        return !isDynamicPattern(pattern, options)
      }
      exports.isStaticPattern = isStaticPattern
      function isDynamicPattern(pattern, options = {}) {
        /**
         * A special case with an empty string is necessary for matching patterns that start with a forward slash.
         * An empty string cannot be a dynamic pattern.
         * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.
         */
        if (pattern === '') {
          return false
        }
        /**
         * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check
         * filepath directly (without read directory).
         */
        if (
          options.caseSensitiveMatch === false ||
          pattern.includes(ESCAPE_SYMBOL)
        ) {
          return true
        }
        if (
          COMMON_GLOB_SYMBOLS_RE.test(pattern) ||
          REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) ||
          REGEX_GROUP_SYMBOLS_RE.test(pattern)
        ) {
          return true
        }
        if (
          options.extglob !== false &&
          GLOB_EXTENSION_SYMBOLS_RE.test(pattern)
        ) {
          return true
        }
        if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {
          return true
        }
        return false
      }
      exports.isDynamicPattern = isDynamicPattern
      function hasBraceExpansion(pattern) {
        const openingBraceIndex = pattern.indexOf('{')
        if (openingBraceIndex === -1) {
          return false
        }
        const closingBraceIndex = pattern.indexOf('}', openingBraceIndex + 1)
        if (closingBraceIndex === -1) {
          return false
        }
        const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex)
        return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent)
      }
      function convertToPositivePattern(pattern) {
        return isNegativePattern(pattern) ? pattern.slice(1) : pattern
      }
      exports.convertToPositivePattern = convertToPositivePattern
      function convertToNegativePattern(pattern) {
        return '!' + pattern
      }
      exports.convertToNegativePattern = convertToNegativePattern
      function isNegativePattern(pattern) {
        return pattern.startsWith('!') && pattern[1] !== '('
      }
      exports.isNegativePattern = isNegativePattern
      function isPositivePattern(pattern) {
        return !isNegativePattern(pattern)
      }
      exports.isPositivePattern = isPositivePattern
      function getNegativePatterns(patterns) {
        return patterns.filter(isNegativePattern)
      }
      exports.getNegativePatterns = getNegativePatterns
      function getPositivePatterns(patterns) {
        return patterns.filter(isPositivePattern)
      }
      exports.getPositivePatterns = getPositivePatterns
      /**
       * Returns patterns that can be applied inside the current directory.
       *
       * @example
       * // ['./*', '*', 'a/*']
       * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])
       */
      function getPatternsInsideCurrentDirectory(patterns) {
        return patterns.filter(
          pattern => !isPatternRelatedToParentDirectory(pattern)
        )
      }
      exports.getPatternsInsideCurrentDirectory =
        getPatternsInsideCurrentDirectory
      /**
       * Returns patterns to be expanded relative to (outside) the current directory.
       *
       * @example
       * // ['../*', './../*']
       * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])
       */
      function getPatternsOutsideCurrentDirectory(patterns) {
        return patterns.filter(isPatternRelatedToParentDirectory)
      }
      exports.getPatternsOutsideCurrentDirectory =
        getPatternsOutsideCurrentDirectory
      function isPatternRelatedToParentDirectory(pattern) {
        return pattern.startsWith('..') || pattern.startsWith('./..')
      }
      exports.isPatternRelatedToParentDirectory =
        isPatternRelatedToParentDirectory
      function getBaseDirectory(pattern) {
        return globParent(pattern, { flipBackslashes: false })
      }
      exports.getBaseDirectory = getBaseDirectory
      function hasGlobStar(pattern) {
        return pattern.includes(GLOBSTAR)
      }
      exports.hasGlobStar = hasGlobStar
      function endsWithSlashGlobStar(pattern) {
        return pattern.endsWith('/' + GLOBSTAR)
      }
      exports.endsWithSlashGlobStar = endsWithSlashGlobStar
      function isAffectDepthOfReadingPattern(pattern) {
        const basename = path.basename(pattern)
        return endsWithSlashGlobStar(pattern) || isStaticPattern(basename)
      }
      exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern
      function expandPatternsWithBraceExpansion(patterns) {
        return patterns.reduce((collection, pattern) => {
          return collection.concat(expandBraceExpansion(pattern))
        }, [])
      }
      exports.expandPatternsWithBraceExpansion =
        expandPatternsWithBraceExpansion
      function expandBraceExpansion(pattern) {
        return micromatch.braces(pattern, {
          expand: true,
          nodupes: true,
        })
      }
      exports.expandBraceExpansion = expandBraceExpansion
      function getPatternParts(pattern, options) {
        let { parts } = micromatch.scan(
          pattern,
          Object.assign(Object.assign({}, options), { parts: true })
        )
        /**
         * The scan method returns an empty array in some cases.
         * See micromatch/picomatch#58 for more details.
         */
        if (parts.length === 0) {
          parts = [pattern]
        }
        /**
         * The scan method does not return an empty part for the pattern with a forward slash.
         * This is another part of micromatch/picomatch#58.
         */
        if (parts[0].startsWith('/')) {
          parts[0] = parts[0].slice(1)
          parts.unshift('')
        }
        return parts
      }
      exports.getPatternParts = getPatternParts
      function makeRe(pattern, options) {
        return micromatch.makeRe(pattern, options)
      }
      exports.makeRe = makeRe
      function convertPatternsToRe(patterns, options) {
        return patterns.map(pattern => makeRe(pattern, options))
      }
      exports.convertPatternsToRe = convertPatternsToRe
      function matchAny(entry, patternsRe) {
        return patternsRe.some(patternRe => patternRe.test(entry))
      }
      exports.matchAny = matchAny

      /***/
    },

    /***/ 8382: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.merge = void 0
      const merge2 = __nccwpck_require__(2578)
      function merge(streams) {
        const mergedStream = merge2(streams)
        streams.forEach(stream => {
          stream.once('error', error => mergedStream.emit('error', error))
        })
        mergedStream.once('close', () => propagateCloseEventToSources(streams))
        mergedStream.once('end', () => propagateCloseEventToSources(streams))
        return mergedStream
      }
      exports.merge = merge
      function propagateCloseEventToSources(streams) {
        streams.forEach(stream => stream.emit('close'))
      }

      /***/
    },

    /***/ 2203: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', { value: true })
      exports.isEmpty = exports.isString = void 0
      function isString(input) {
        return typeof input === 'string'
      }
      exports.isString = isString
      function isEmpty(input) {
        return input === ''
      }
      exports.isEmpty = isEmpty

      /***/
    },

    /***/ 7340: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      /* eslint-disable no-var */

      var reusify = __nccwpck_require__(2113)

      function fastqueue(context, worker, concurrency) {
        if (typeof context === 'function') {
          concurrency = worker
          worker = context
          context = null
        }

        if (concurrency < 1) {
          throw new Error('fastqueue concurrency must be greater than 1')
        }

        var cache = reusify(Task)
        var queueHead = null
        var queueTail = null
        var _running = 0
        var errorHandler = null

        var self = {
          push: push,
          drain: noop,
          saturated: noop,
          pause: pause,
          paused: false,
          concurrency: concurrency,
          running: running,
          resume: resume,
          idle: idle,
          length: length,
          getQueue: getQueue,
          unshift: unshift,
          empty: noop,
          kill: kill,
          killAndDrain: killAndDrain,
          error: error,
        }

        return self

        function running() {
          return _running
        }

        function pause() {
          self.paused = true
        }

        function length() {
          var current = queueHead
          var counter = 0

          while (current) {
            current = current.next
            counter++
          }

          return counter
        }

        function getQueue() {
          var current = queueHead
          var tasks = []

          while (current) {
            tasks.push(current.value)
            current = current.next
          }

          return tasks
        }

        function resume() {
          if (!self.paused) return
          self.paused = false
          for (var i = 0; i < self.concurrency; i++) {
            _running++
            release()
          }
        }

        function idle() {
          return _running === 0 && self.length() === 0
        }

        function push(value, done) {
          var current = cache.get()

          current.context = context
          current.release = release
          current.value = value
          current.callback = done || noop
          current.errorHandler = errorHandler

          if (_running === self.concurrency || self.paused) {
            if (queueTail) {
              queueTail.next = current
              queueTail = current
            } else {
              queueHead = current
              queueTail = current
              self.saturated()
            }
          } else {
            _running++
            worker.call(context, current.value, current.worked)
          }
        }

        function unshift(value, done) {
          var current = cache.get()

          current.context = context
          current.release = release
          current.value = value
          current.callback = done || noop

          if (_running === self.concurrency || self.paused) {
            if (queueHead) {
              current.next = queueHead
              queueHead = current
            } else {
              queueHead = current
              queueTail = current
              self.saturated()
            }
          } else {
            _running++
            worker.call(context, current.value, current.worked)
          }
        }

        function release(holder) {
          if (holder) {
            cache.release(holder)
          }
          var next = queueHead
          if (next) {
            if (!self.paused) {
              if (queueTail === queueHead) {
                queueTail = null
              }
              queueHead = next.next
              next.next = null
              worker.call(context, next.value, next.worked)
              if (queueTail === null) {
                self.empty()
              }
            } else {
              _running--
            }
          } else if (--_running === 0) {
            self.drain()
          }
        }

        function kill() {
          queueHead = null
          queueTail = null
          self.drain = noop
        }

        function killAndDrain() {
          queueHead = null
          queueTail = null
          self.drain()
          self.drain = noop
        }

        function error(handler) {
          errorHandler = handler
        }
      }

      function noop() {}

      function Task() {
        this.value = null
        this.callback = noop
        this.next = null
        this.release = noop
        this.context = null
        this.errorHandler = null

        var self = this

        this.worked = function worked(err, result) {
          var callback = self.callback
          var errorHandler = self.errorHandler
          var val = self.value
          self.value = null
          self.callback = noop
          if (self.errorHandler) {
            errorHandler(err, val)
          }
          callback.call(self.context, err, result)
          self.release(self)
        }
      }

      function queueAsPromised(context, worker, concurrency) {
        if (typeof context === 'function') {
          concurrency = worker
          worker = context
          context = null
        }

        function asyncWrapper(arg, cb) {
          worker.call(this, arg).then(function (res) {
            cb(null, res)
          }, cb)
        }

        var queue = fastqueue(context, asyncWrapper, concurrency)

        var pushCb = queue.push
        var unshiftCb = queue.unshift

        queue.push = push
        queue.unshift = unshift
        queue.drained = drained

        return queue

        function push(value) {
          var p = new Promise(function (resolve, reject) {
            pushCb(value, function (err, result) {
              if (err) {
                reject(err)
                return
              }
              resolve(result)
            })
          })

          // Let's fork the promise chain to
          // make the error bubble up to the user but
          // not lead to a unhandledRejection
          p.catch(noop)

          return p
        }

        function unshift(value) {
          var p = new Promise(function (resolve, reject) {
            unshiftCb(value, function (err, result) {
              if (err) {
                reject(err)
                return
              }
              resolve(result)
            })
          })

          // Let's fork the promise chain to
          // make the error bubble up to the user but
          // not lead to a unhandledRejection
          p.catch(noop)

          return p
        }

        function drained() {
          var previousDrain = queue.drain

          var p = new Promise(function (resolve) {
            queue.drain = function () {
              previousDrain()
              resolve()
            }
          })

          return p
        }
      }

      module.exports = fastqueue
      module.exports.promise = queueAsPromised

      /***/
    },

    /***/ 6330: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'
      /*!
       * fill-range <https://github.com/jonschlinkert/fill-range>
       *
       * Copyright (c) 2014-present, Jon Schlinkert.
       * Licensed under the MIT License.
       */

      const util = __nccwpck_require__(3837)
      const toRegexRange = __nccwpck_require__(1861)

      const isObject = val =>
        val !== null && typeof val === 'object' && !Array.isArray(val)

      const transform = toNumber => {
        return value => (toNumber === true ? Number(value) : String(value))
      }

      const isValidValue = value => {
        return (
          typeof value === 'number' ||
          (typeof value === 'string' && value !== '')
        )
      }

      const isNumber = num => Number.isInteger(+num)

      const zeros = input => {
        let value = `${input}`
        let index = -1
        if (value[0] === '-') value = value.slice(1)
        if (value === '0') return false
        while (value[++index] === '0');
        return index > 0
      }

      const stringify = (start, end, options) => {
        if (typeof start === 'string' || typeof end === 'string') {
          return true
        }
        return options.stringify === true
      }

      const pad = (input, maxLength, toNumber) => {
        if (maxLength > 0) {
          let dash = input[0] === '-' ? '-' : ''
          if (dash) input = input.slice(1)
          input = dash + input.padStart(dash ? maxLength - 1 : maxLength, '0')
        }
        if (toNumber === false) {
          return String(input)
        }
        return input
      }

      const toMaxLen = (input, maxLength) => {
        let negative = input[0] === '-' ? '-' : ''
        if (negative) {
          input = input.slice(1)
          maxLength--
        }
        while (input.length < maxLength) input = '0' + input
        return negative ? '-' + input : input
      }

      const toSequence = (parts, options) => {
        parts.negatives.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0))
        parts.positives.sort((a, b) => (a < b ? -1 : a > b ? 1 : 0))

        let prefix = options.capture ? '' : '?:'
        let positives = ''
        let negatives = ''
        let result

        if (parts.positives.length) {
          positives = parts.positives.join('|')
        }

        if (parts.negatives.length) {
          negatives = `-(${prefix}${parts.negatives.join('|')})`
        }

        if (positives && negatives) {
          result = `${positives}|${negatives}`
        } else {
          result = positives || negatives
        }

        if (options.wrap) {
          return `(${prefix}${result})`
        }

        return result
      }

      const toRange = (a, b, isNumbers, options) => {
        if (isNumbers) {
          return toRegexRange(a, b, { wrap: false, ...options })
        }

        let start = String.fromCharCode(a)
        if (a === b) return start

        let stop = String.fromCharCode(b)
        return `[${start}-${stop}]`
      }

      const toRegex = (start, end, options) => {
        if (Array.isArray(start)) {
          let wrap = options.wrap === true
          let prefix = options.capture ? '' : '?:'
          return wrap ? `(${prefix}${start.join('|')})` : start.join('|')
        }
        return toRegexRange(start, end, options)
      }

      const rangeError = (...args) => {
        return new RangeError(
          'Invalid range arguments: ' + util.inspect(...args)
        )
      }

      const invalidRange = (start, end, options) => {
        if (options.strictRanges === true) throw rangeError([start, end])
        return []
      }

      const invalidStep = (step, options) => {
        if (options.strictRanges === true) {
          throw new TypeError(`Expected step "${step}" to be a number`)
        }
        return []
      }

      const fillNumbers = (start, end, step = 1, options = {}) => {
        let a = Number(start)
        let b = Number(end)

        if (!Number.isInteger(a) || !Number.isInteger(b)) {
          if (options.strictRanges === true) throw rangeError([start, end])
          return []
        }

        // fix negative zero
        if (a === 0) a = 0
        if (b === 0) b = 0

        let descending = a > b
        let startString = String(start)
        let endString = String(end)
        let stepString = String(step)
        step = Math.max(Math.abs(step), 1)

        let padded = zeros(startString) || zeros(endString) || zeros(stepString)
        let maxLen = padded
          ? Math.max(startString.length, endString.length, stepString.length)
          : 0
        let toNumber =
          padded === false && stringify(start, end, options) === false
        let format = options.transform || transform(toNumber)

        if (options.toRegex && step === 1) {
          return toRange(
            toMaxLen(start, maxLen),
            toMaxLen(end, maxLen),
            true,
            options
          )
        }

        let parts = { negatives: [], positives: [] }
        let push = num =>
          parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num))
        let range = []
        let index = 0

        while (descending ? a >= b : a <= b) {
          if (options.toRegex === true && step > 1) {
            push(a)
          } else {
            range.push(pad(format(a, index), maxLen, toNumber))
          }
          a = descending ? a - step : a + step
          index++
        }

        if (options.toRegex === true) {
          return step > 1
            ? toSequence(parts, options)
            : toRegex(range, null, { wrap: false, ...options })
        }

        return range
      }

      const fillLetters = (start, end, step = 1, options = {}) => {
        if (
          (!isNumber(start) && start.length > 1) ||
          (!isNumber(end) && end.length > 1)
        ) {
          return invalidRange(start, end, options)
        }

        let format = options.transform || (val => String.fromCharCode(val))
        let a = `${start}`.charCodeAt(0)
        let b = `${end}`.charCodeAt(0)

        let descending = a > b
        let min = Math.min(a, b)
        let max = Math.max(a, b)

        if (options.toRegex && step === 1) {
          return toRange(min, max, false, options)
        }

        let range = []
        let index = 0

        while (descending ? a >= b : a <= b) {
          range.push(format(a, index))
          a = descending ? a - step : a + step
          index++
        }

        if (options.toRegex === true) {
          return toRegex(range, null, { wrap: false, options })
        }

        return range
      }

      const fill = (start, end, step, options = {}) => {
        if (end == null && isValidValue(start)) {
          return [start]
        }

        if (!isValidValue(start) || !isValidValue(end)) {
          return invalidRange(start, end, options)
        }

        if (typeof step === 'function') {
          return fill(start, end, 1, { transform: step })
        }

        if (isObject(step)) {
          return fill(start, end, 0, step)
        }

        let opts = { ...options }
        if (opts.capture === true) opts.wrap = true
        step = step || opts.step || 1

        if (!isNumber(step)) {
          if (step != null && !isObject(step)) return invalidStep(step, opts)
          return fill(start, end, 1, step)
        }

        if (isNumber(start) && isNumber(end)) {
          return fillNumbers(start, end, step, opts)
        }

        return fillLetters(start, end, Math.max(Math.abs(step), 1), opts)
      }

      module.exports = fill

      /***/
    },

    /***/ 9486: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const path = __nccwpck_require__(1017)
      const locatePath = __nccwpck_require__(3447)
      const pathExists = __nccwpck_require__(6978)

      const stop = Symbol('findUp.stop')

      module.exports = async (name, options = {}) => {
        let directory = path.resolve(options.cwd || '')
        const { root } = path.parse(directory)
        const paths = [].concat(name)

        const runMatcher = async locateOptions => {
          if (typeof name !== 'function') {
            return locatePath(paths, locateOptions)
          }

          const foundPath = await name(locateOptions.cwd)
          if (typeof foundPath === 'string') {
            return locatePath([foundPath], locateOptions)
          }

          return foundPath
        }

        // eslint-disable-next-line no-constant-condition
        while (true) {
          // eslint-disable-next-line no-await-in-loop
          const foundPath = await runMatcher({ ...options, cwd: directory })

          if (foundPath === stop) {
            return
          }

          if (foundPath) {
            return path.resolve(directory, foundPath)
          }

          if (directory === root) {
            return
          }

          directory = path.dirname(directory)
        }
      }

      module.exports.sync = (name, options = {}) => {
        let directory = path.resolve(options.cwd || '')
        const { root } = path.parse(directory)
        const paths = [].concat(name)

        const runMatcher = locateOptions => {
          if (typeof name !== 'function') {
            return locatePath.sync(paths, locateOptions)
          }

          const foundPath = name(locateOptions.cwd)
          if (typeof foundPath === 'string') {
            return locatePath.sync([foundPath], locateOptions)
          }

          return foundPath
        }

        // eslint-disable-next-line no-constant-condition
        while (true) {
          const foundPath = runMatcher({ ...options, cwd: directory })

          if (foundPath === stop) {
            return
          }

          if (foundPath) {
            return path.resolve(directory, foundPath)
          }

          if (directory === root) {
            return
          }

          directory = path.dirname(directory)
        }
      }

      module.exports.exists = pathExists

      module.exports.sync.exists = pathExists.sync

      module.exports.stop = stop

      /***/
    },

    /***/ 3338: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const mkdirpSync = __nccwpck_require__(8605).mkdirsSync
      const utimesSync = __nccwpck_require__(2548).utimesMillisSync

      const notExist = Symbol('notExist')

      function copySync(src, dest, opts) {
        if (typeof opts === 'function') {
          opts = { filter: opts }
        }

        opts = opts || {}
        opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now
        opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber

        // Warn about using preserveTimestamps on 32-bit node
        if (opts.preserveTimestamps && process.arch === 'ia32') {
          console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`)
        }

        const destStat = checkPaths(src, dest)

        if (opts.filter && !opts.filter(src, dest)) return

        const destParent = path.dirname(dest)
        if (!fs.existsSync(destParent)) mkdirpSync(destParent)
        return startCopy(destStat, src, dest, opts)
      }

      function startCopy(destStat, src, dest, opts) {
        if (opts.filter && !opts.filter(src, dest)) return
        return getStats(destStat, src, dest, opts)
      }

      function getStats(destStat, src, dest, opts) {
        const statSync = opts.dereference ? fs.statSync : fs.lstatSync
        const srcStat = statSync(src)

        if (srcStat.isDirectory())
          return onDir(srcStat, destStat, src, dest, opts)
        else if (
          srcStat.isFile() ||
          srcStat.isCharacterDevice() ||
          srcStat.isBlockDevice()
        )
          return onFile(srcStat, destStat, src, dest, opts)
        else if (srcStat.isSymbolicLink())
          return onLink(destStat, src, dest, opts)
      }

      function onFile(srcStat, destStat, src, dest, opts) {
        if (destStat === notExist) return copyFile(srcStat, src, dest, opts)
        return mayCopyFile(srcStat, src, dest, opts)
      }

      function mayCopyFile(srcStat, src, dest, opts) {
        if (opts.overwrite) {
          fs.unlinkSync(dest)
          return copyFile(srcStat, src, dest, opts)
        } else if (opts.errorOnExist) {
          throw new Error(`'${dest}' already exists`)
        }
      }

      function copyFile(srcStat, src, dest, opts) {
        if (typeof fs.copyFileSync === 'function') {
          fs.copyFileSync(src, dest)
          fs.chmodSync(dest, srcStat.mode)
          if (opts.preserveTimestamps) {
            return utimesSync(dest, srcStat.atime, srcStat.mtime)
          }
          return
        }
        return copyFileFallback(srcStat, src, dest, opts)
      }

      function copyFileFallback(srcStat, src, dest, opts) {
        const BUF_LENGTH = 64 * 1024
        const _buff = __nccwpck_require__(7696)(BUF_LENGTH)

        const fdr = fs.openSync(src, 'r')
        const fdw = fs.openSync(dest, 'w', srcStat.mode)
        let pos = 0

        while (pos < srcStat.size) {
          const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)
          fs.writeSync(fdw, _buff, 0, bytesRead)
          pos += bytesRead
        }

        if (opts.preserveTimestamps)
          fs.futimesSync(fdw, srcStat.atime, srcStat.mtime)

        fs.closeSync(fdr)
        fs.closeSync(fdw)
      }

      function onDir(srcStat, destStat, src, dest, opts) {
        if (destStat === notExist) return mkDirAndCopy(srcStat, src, dest, opts)
        if (destStat && !destStat.isDirectory()) {
          throw new Error(
            `Cannot overwrite non-directory '${dest}' with directory '${src}'.`
          )
        }
        return copyDir(src, dest, opts)
      }

      function mkDirAndCopy(srcStat, src, dest, opts) {
        fs.mkdirSync(dest)
        copyDir(src, dest, opts)
        return fs.chmodSync(dest, srcStat.mode)
      }

      function copyDir(src, dest, opts) {
        fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))
      }

      function copyDirItem(item, src, dest, opts) {
        const srcItem = path.join(src, item)
        const destItem = path.join(dest, item)
        const destStat = checkPaths(srcItem, destItem)
        return startCopy(destStat, srcItem, destItem, opts)
      }

      function onLink(destStat, src, dest, opts) {
        let resolvedSrc = fs.readlinkSync(src)

        if (opts.dereference) {
          resolvedSrc = path.resolve(process.cwd(), resolvedSrc)
        }

        if (destStat === notExist) {
          return fs.symlinkSync(resolvedSrc, dest)
        } else {
          let resolvedDest
          try {
            resolvedDest = fs.readlinkSync(dest)
          } catch (err) {
            // dest exists and is a regular file or directory,
            // Windows may throw UNKNOWN error. If dest already exists,
            // fs throws error anyway, so no need to guard against it here.
            if (err.code === 'EINVAL' || err.code === 'UNKNOWN')
              return fs.symlinkSync(resolvedSrc, dest)
            throw err
          }
          if (opts.dereference) {
            resolvedDest = path.resolve(process.cwd(), resolvedDest)
          }
          if (isSrcSubdir(resolvedSrc, resolvedDest)) {
            throw new Error(
              `Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`
            )
          }

          // prevent copy if src is a subdir of dest since unlinking
          // dest in this case would result in removing src contents
          // and therefore a broken symlink would be created.
          if (
            fs.statSync(dest).isDirectory() &&
            isSrcSubdir(resolvedDest, resolvedSrc)
          ) {
            throw new Error(
              `Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`
            )
          }
          return copyLink(resolvedSrc, dest)
        }
      }

      function copyLink(resolvedSrc, dest) {
        fs.unlinkSync(dest)
        return fs.symlinkSync(resolvedSrc, dest)
      }

      // return true if dest is a subdir of src, otherwise false.
      function isSrcSubdir(src, dest) {
        const srcArray = path.resolve(src).split(path.sep)
        const destArray = path.resolve(dest).split(path.sep)
        return srcArray.reduce(
          (acc, current, i) => acc && destArray[i] === current,
          true
        )
      }

      function checkStats(src, dest) {
        const srcStat = fs.statSync(src)
        let destStat
        try {
          destStat = fs.statSync(dest)
        } catch (err) {
          if (err.code === 'ENOENT') return { srcStat, destStat: notExist }
          throw err
        }
        return { srcStat, destStat }
      }

      function checkPaths(src, dest) {
        const { srcStat, destStat } = checkStats(src, dest)
        if (destStat.ino && destStat.ino === srcStat.ino) {
          throw new Error('Source and destination must not be the same.')
        }
        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
          throw new Error(
            `Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`
          )
        }
        return destStat
      }

      module.exports = copySync

      /***/
    },

    /***/ 1135: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      module.exports = {
        copySync: __nccwpck_require__(3338),
      }

      /***/
    },

    /***/ 8834: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const mkdirp = __nccwpck_require__(8605).mkdirs
      const pathExists = __nccwpck_require__(3835).pathExists
      const utimes = __nccwpck_require__(2548).utimesMillis

      const notExist = Symbol('notExist')

      function copy(src, dest, opts, cb) {
        if (typeof opts === 'function' && !cb) {
          cb = opts
          opts = {}
        } else if (typeof opts === 'function') {
          opts = { filter: opts }
        }

        cb = cb || function () {}
        opts = opts || {}

        opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now
        opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber

        // Warn about using preserveTimestamps on 32-bit node
        if (opts.preserveTimestamps && process.arch === 'ia32') {
          console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`)
        }

        checkPaths(src, dest, (err, destStat) => {
          if (err) return cb(err)
          if (opts.filter)
            return handleFilter(checkParentDir, destStat, src, dest, opts, cb)
          return checkParentDir(destStat, src, dest, opts, cb)
        })
      }

      function checkParentDir(destStat, src, dest, opts, cb) {
        const destParent = path.dirname(dest)
        pathExists(destParent, (err, dirExists) => {
          if (err) return cb(err)
          if (dirExists) return startCopy(destStat, src, dest, opts, cb)
          mkdirp(destParent, err => {
            if (err) return cb(err)
            return startCopy(destStat, src, dest, opts, cb)
          })
        })
      }

      function handleFilter(onInclude, destStat, src, dest, opts, cb) {
        Promise.resolve(opts.filter(src, dest)).then(
          include => {
            if (include) {
              if (destStat) return onInclude(destStat, src, dest, opts, cb)
              return onInclude(src, dest, opts, cb)
            }
            return cb()
          },
          error => cb(error)
        )
      }

      function startCopy(destStat, src, dest, opts, cb) {
        if (opts.filter)
          return handleFilter(getStats, destStat, src, dest, opts, cb)
        return getStats(destStat, src, dest, opts, cb)
      }

      function getStats(destStat, src, dest, opts, cb) {
        const stat = opts.dereference ? fs.stat : fs.lstat
        stat(src, (err, srcStat) => {
          if (err) return cb(err)

          if (srcStat.isDirectory())
            return onDir(srcStat, destStat, src, dest, opts, cb)
          else if (
            srcStat.isFile() ||
            srcStat.isCharacterDevice() ||
            srcStat.isBlockDevice()
          )
            return onFile(srcStat, destStat, src, dest, opts, cb)
          else if (srcStat.isSymbolicLink())
            return onLink(destStat, src, dest, opts, cb)
        })
      }

      function onFile(srcStat, destStat, src, dest, opts, cb) {
        if (destStat === notExist) return copyFile(srcStat, src, dest, opts, cb)
        return mayCopyFile(srcStat, src, dest, opts, cb)
      }

      function mayCopyFile(srcStat, src, dest, opts, cb) {
        if (opts.overwrite) {
          fs.unlink(dest, err => {
            if (err) return cb(err)
            return copyFile(srcStat, src, dest, opts, cb)
          })
        } else if (opts.errorOnExist) {
          return cb(new Error(`'${dest}' already exists`))
        } else return cb()
      }

      function copyFile(srcStat, src, dest, opts, cb) {
        if (typeof fs.copyFile === 'function') {
          return fs.copyFile(src, dest, err => {
            if (err) return cb(err)
            return setDestModeAndTimestamps(srcStat, dest, opts, cb)
          })
        }
        return copyFileFallback(srcStat, src, dest, opts, cb)
      }

      function copyFileFallback(srcStat, src, dest, opts, cb) {
        const rs = fs.createReadStream(src)
        rs.on('error', err => cb(err)).once('open', () => {
          const ws = fs.createWriteStream(dest, { mode: srcStat.mode })
          ws.on('error', err => cb(err))
            .on('open', () => rs.pipe(ws))
            .once('close', () =>
              setDestModeAndTimestamps(srcStat, dest, opts, cb)
            )
        })
      }

      function setDestModeAndTimestamps(srcStat, dest, opts, cb) {
        fs.chmod(dest, srcStat.mode, err => {
          if (err) return cb(err)
          if (opts.preserveTimestamps) {
            return utimes(dest, srcStat.atime, srcStat.mtime, cb)
          }
          return cb()
        })
      }

      function onDir(srcStat, destStat, src, dest, opts, cb) {
        if (destStat === notExist)
          return mkDirAndCopy(srcStat, src, dest, opts, cb)
        if (destStat && !destStat.isDirectory()) {
          return cb(
            new Error(
              `Cannot overwrite non-directory '${dest}' with directory '${src}'.`
            )
          )
        }
        return copyDir(src, dest, opts, cb)
      }

      function mkDirAndCopy(srcStat, src, dest, opts, cb) {
        fs.mkdir(dest, err => {
          if (err) return cb(err)
          copyDir(src, dest, opts, err => {
            if (err) return cb(err)
            return fs.chmod(dest, srcStat.mode, cb)
          })
        })
      }

      function copyDir(src, dest, opts, cb) {
        fs.readdir(src, (err, items) => {
          if (err) return cb(err)
          return copyDirItems(items, src, dest, opts, cb)
        })
      }

      function copyDirItems(items, src, dest, opts, cb) {
        const item = items.pop()
        if (!item) return cb()
        return copyDirItem(items, item, src, dest, opts, cb)
      }

      function copyDirItem(items, item, src, dest, opts, cb) {
        const srcItem = path.join(src, item)
        const destItem = path.join(dest, item)
        checkPaths(srcItem, destItem, (err, destStat) => {
          if (err) return cb(err)
          startCopy(destStat, srcItem, destItem, opts, err => {
            if (err) return cb(err)
            return copyDirItems(items, src, dest, opts, cb)
          })
        })
      }

      function onLink(destStat, src, dest, opts, cb) {
        fs.readlink(src, (err, resolvedSrc) => {
          if (err) return cb(err)

          if (opts.dereference) {
            resolvedSrc = path.resolve(process.cwd(), resolvedSrc)
          }

          if (destStat === notExist) {
            return fs.symlink(resolvedSrc, dest, cb)
          } else {
            fs.readlink(dest, (err, resolvedDest) => {
              if (err) {
                // dest exists and is a regular file or directory,
                // Windows may throw UNKNOWN error. If dest already exists,
                // fs throws error anyway, so no need to guard against it here.
                if (err.code === 'EINVAL' || err.code === 'UNKNOWN')
                  return fs.symlink(resolvedSrc, dest, cb)
                return cb(err)
              }
              if (opts.dereference) {
                resolvedDest = path.resolve(process.cwd(), resolvedDest)
              }
              if (isSrcSubdir(resolvedSrc, resolvedDest)) {
                return cb(
                  new Error(
                    `Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`
                  )
                )
              }

              // do not copy if src is a subdir of dest since unlinking
              // dest in this case would result in removing src contents
              // and therefore a broken symlink would be created.
              if (
                destStat.isDirectory() &&
                isSrcSubdir(resolvedDest, resolvedSrc)
              ) {
                return cb(
                  new Error(
                    `Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`
                  )
                )
              }
              return copyLink(resolvedSrc, dest, cb)
            })
          }
        })
      }

      function copyLink(resolvedSrc, dest, cb) {
        fs.unlink(dest, err => {
          if (err) return cb(err)
          return fs.symlink(resolvedSrc, dest, cb)
        })
      }

      // return true if dest is a subdir of src, otherwise false.
      function isSrcSubdir(src, dest) {
        const srcArray = path.resolve(src).split(path.sep)
        const destArray = path.resolve(dest).split(path.sep)
        return srcArray.reduce(
          (acc, current, i) => acc && destArray[i] === current,
          true
        )
      }

      function checkStats(src, dest, cb) {
        fs.stat(src, (err, srcStat) => {
          if (err) return cb(err)
          fs.stat(dest, (err, destStat) => {
            if (err) {
              if (err.code === 'ENOENT')
                return cb(null, { srcStat, destStat: notExist })
              return cb(err)
            }
            return cb(null, { srcStat, destStat })
          })
        })
      }

      function checkPaths(src, dest, cb) {
        checkStats(src, dest, (err, stats) => {
          if (err) return cb(err)
          const { srcStat, destStat } = stats
          if (destStat.ino && destStat.ino === srcStat.ino) {
            return cb(new Error('Source and destination must not be the same.'))
          }
          if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
            return cb(
              new Error(
                `Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`
              )
            )
          }
          return cb(null, destStat)
        })
      }

      module.exports = copy

      /***/
    },

    /***/ 1335: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      module.exports = {
        copy: u(__nccwpck_require__(8834)),
      }

      /***/
    },

    /***/ 6970: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const fs = __nccwpck_require__(7147)
      const path = __nccwpck_require__(1017)
      const mkdir = __nccwpck_require__(8605)
      const remove = __nccwpck_require__(7357)

      const emptyDir = u(function emptyDir(dir, callback) {
        callback = callback || function () {}
        fs.readdir(dir, (err, items) => {
          if (err) return mkdir.mkdirs(dir, callback)

          items = items.map(item => path.join(dir, item))

          deleteItem()

          function deleteItem() {
            const item = items.pop()
            if (!item) return callback()
            remove.remove(item, err => {
              if (err) return callback(err)
              deleteItem()
            })
          }
        })
      })

      function emptyDirSync(dir) {
        let items
        try {
          items = fs.readdirSync(dir)
        } catch (err) {
          return mkdir.mkdirsSync(dir)
        }

        items.forEach(item => {
          item = path.join(dir, item)
          remove.removeSync(item)
        })
      }

      module.exports = {
        emptyDirSync,
        emptydirSync: emptyDirSync,
        emptyDir,
        emptydir: emptyDir,
      }

      /***/
    },

    /***/ 2164: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const path = __nccwpck_require__(1017)
      const fs = __nccwpck_require__(7758)
      const mkdir = __nccwpck_require__(8605)
      const pathExists = __nccwpck_require__(3835).pathExists

      function createFile(file, callback) {
        function makeFile() {
          fs.writeFile(file, '', err => {
            if (err) return callback(err)
            callback()
          })
        }

        fs.stat(file, (err, stats) => {
          // eslint-disable-line handle-callback-err
          if (!err && stats.isFile()) return callback()
          const dir = path.dirname(file)
          pathExists(dir, (err, dirExists) => {
            if (err) return callback(err)
            if (dirExists) return makeFile()
            mkdir.mkdirs(dir, err => {
              if (err) return callback(err)
              makeFile()
            })
          })
        })
      }

      function createFileSync(file) {
        let stats
        try {
          stats = fs.statSync(file)
        } catch (e) {}
        if (stats && stats.isFile()) return

        const dir = path.dirname(file)
        if (!fs.existsSync(dir)) {
          mkdir.mkdirsSync(dir)
        }

        fs.writeFileSync(file, '')
      }

      module.exports = {
        createFile: u(createFile),
        createFileSync,
      }

      /***/
    },

    /***/ 55: /***/ (module, __unused_webpack_exports, __nccwpck_require__) => {
      'use strict'

      const file = __nccwpck_require__(2164)
      const link = __nccwpck_require__(3797)
      const symlink = __nccwpck_require__(2549)

      module.exports = {
        // file
        createFile: file.createFile,
        createFileSync: file.createFileSync,
        ensureFile: file.createFile,
        ensureFileSync: file.createFileSync,
        // link
        createLink: link.createLink,
        createLinkSync: link.createLinkSync,
        ensureLink: link.createLink,
        ensureLinkSync: link.createLinkSync,
        // symlink
        createSymlink: symlink.createSymlink,
        createSymlinkSync: symlink.createSymlinkSync,
        ensureSymlink: symlink.createSymlink,
        ensureSymlinkSync: symlink.createSymlinkSync,
      }

      /***/
    },

    /***/ 3797: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const path = __nccwpck_require__(1017)
      const fs = __nccwpck_require__(7758)
      const mkdir = __nccwpck_require__(8605)
      const pathExists = __nccwpck_require__(3835).pathExists

      function createLink(srcpath, dstpath, callback) {
        function makeLink(srcpath, dstpath) {
          fs.link(srcpath, dstpath, err => {
            if (err) return callback(err)
            callback(null)
          })
        }

        pathExists(dstpath, (err, destinationExists) => {
          if (err) return callback(err)
          if (destinationExists) return callback(null)
          fs.lstat(srcpath, err => {
            if (err) {
              err.message = err.message.replace('lstat', 'ensureLink')
              return callback(err)
            }

            const dir = path.dirname(dstpath)
            pathExists(dir, (err, dirExists) => {
              if (err) return callback(err)
              if (dirExists) return makeLink(srcpath, dstpath)
              mkdir.mkdirs(dir, err => {
                if (err) return callback(err)
                makeLink(srcpath, dstpath)
              })
            })
          })
        })
      }

      function createLinkSync(srcpath, dstpath) {
        const destinationExists = fs.existsSync(dstpath)
        if (destinationExists) return undefined

        try {
          fs.lstatSync(srcpath)
        } catch (err) {
          err.message = err.message.replace('lstat', 'ensureLink')
          throw err
        }

        const dir = path.dirname(dstpath)
        const dirExists = fs.existsSync(dir)
        if (dirExists) return fs.linkSync(srcpath, dstpath)
        mkdir.mkdirsSync(dir)

        return fs.linkSync(srcpath, dstpath)
      }

      module.exports = {
        createLink: u(createLink),
        createLinkSync,
      }

      /***/
    },

    /***/ 3727: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const path = __nccwpck_require__(1017)
      const fs = __nccwpck_require__(7758)
      const pathExists = __nccwpck_require__(3835).pathExists

      /**
       * Function that returns two types of paths, one relative to symlink, and one
       * relative to the current working directory. Checks if path is absolute or
       * relative. If the path is relative, this function checks if the path is
       * relative to symlink or relative to current working directory. This is an
       * initiative to find a smarter `srcpath` to supply when building symlinks.
       * This allows you to determine which path to use out of one of three possible
       * types of source paths. The first is an absolute path. This is detected by
       * `path.isAbsolute()`. When an absolute path is provided, it is checked to
       * see if it exists. If it does it's used, if not an error is returned
       * (callback)/ thrown (sync). The other two options for `srcpath` are a
       * relative url. By default Node's `fs.symlink` works by creating a symlink
       * using `dstpath` and expects the `srcpath` to be relative to the newly
       * created symlink. If you provide a `srcpath` that does not exist on the file
       * system it results in a broken symlink. To minimize this, the function
       * checks to see if the 'relative to symlink' source file exists, and if it
       * does it will use it. If it does not, it checks if there's a file that
       * exists that is relative to the current working directory, if does its used.
       * This preserves the expectations of the original fs.symlink spec and adds
       * the ability to pass in `relative to current working direcotry` paths.
       */

      function symlinkPaths(srcpath, dstpath, callback) {
        if (path.isAbsolute(srcpath)) {
          return fs.lstat(srcpath, err => {
            if (err) {
              err.message = err.message.replace('lstat', 'ensureSymlink')
              return callback(err)
            }
            return callback(null, {
              toCwd: srcpath,
              toDst: srcpath,
            })
          })
        } else {
          const dstdir = path.dirname(dstpath)
          const relativeToDst = path.join(dstdir, srcpath)
          return pathExists(relativeToDst, (err, exists) => {
            if (err) return callback(err)
            if (exists) {
              return callback(null, {
                toCwd: relativeToDst,
                toDst: srcpath,
              })
            } else {
              return fs.lstat(srcpath, err => {
                if (err) {
                  err.message = err.message.replace('lstat', 'ensureSymlink')
                  return callback(err)
                }
                return callback(null, {
                  toCwd: srcpath,
                  toDst: path.relative(dstdir, srcpath),
                })
              })
            }
          })
        }
      }

      function symlinkPathsSync(srcpath, dstpath) {
        let exists
        if (path.isAbsolute(srcpath)) {
          exists = fs.existsSync(srcpath)
          if (!exists) throw new Error('absolute srcpath does not exist')
          return {
            toCwd: srcpath,
            toDst: srcpath,
          }
        } else {
          const dstdir = path.dirname(dstpath)
          const relativeToDst = path.join(dstdir, srcpath)
          exists = fs.existsSync(relativeToDst)
          if (exists) {
            return {
              toCwd: relativeToDst,
              toDst: srcpath,
            }
          } else {
            exists = fs.existsSync(srcpath)
            if (!exists) throw new Error('relative srcpath does not exist')
            return {
              toCwd: srcpath,
              toDst: path.relative(dstdir, srcpath),
            }
          }
        }
      }

      module.exports = {
        symlinkPaths,
        symlinkPathsSync,
      }

      /***/
    },

    /***/ 8254: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)

      function symlinkType(srcpath, type, callback) {
        callback = typeof type === 'function' ? type : callback
        type = typeof type === 'function' ? false : type
        if (type) return callback(null, type)
        fs.lstat(srcpath, (err, stats) => {
          if (err) return callback(null, 'file')
          type = stats && stats.isDirectory() ? 'dir' : 'file'
          callback(null, type)
        })
      }

      function symlinkTypeSync(srcpath, type) {
        let stats

        if (type) return type
        try {
          stats = fs.lstatSync(srcpath)
        } catch (e) {
          return 'file'
        }
        return stats && stats.isDirectory() ? 'dir' : 'file'
      }

      module.exports = {
        symlinkType,
        symlinkTypeSync,
      }

      /***/
    },

    /***/ 2549: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const path = __nccwpck_require__(1017)
      const fs = __nccwpck_require__(7758)
      const _mkdirs = __nccwpck_require__(8605)
      const mkdirs = _mkdirs.mkdirs
      const mkdirsSync = _mkdirs.mkdirsSync

      const _symlinkPaths = __nccwpck_require__(3727)
      const symlinkPaths = _symlinkPaths.symlinkPaths
      const symlinkPathsSync = _symlinkPaths.symlinkPathsSync

      const _symlinkType = __nccwpck_require__(8254)
      const symlinkType = _symlinkType.symlinkType
      const symlinkTypeSync = _symlinkType.symlinkTypeSync

      const pathExists = __nccwpck_require__(3835).pathExists

      function createSymlink(srcpath, dstpath, type, callback) {
        callback = typeof type === 'function' ? type : callback
        type = typeof type === 'function' ? false : type

        pathExists(dstpath, (err, destinationExists) => {
          if (err) return callback(err)
          if (destinationExists) return callback(null)
          symlinkPaths(srcpath, dstpath, (err, relative) => {
            if (err) return callback(err)
            srcpath = relative.toDst
            symlinkType(relative.toCwd, type, (err, type) => {
              if (err) return callback(err)
              const dir = path.dirname(dstpath)
              pathExists(dir, (err, dirExists) => {
                if (err) return callback(err)
                if (dirExists)
                  return fs.symlink(srcpath, dstpath, type, callback)
                mkdirs(dir, err => {
                  if (err) return callback(err)
                  fs.symlink(srcpath, dstpath, type, callback)
                })
              })
            })
          })
        })
      }

      function createSymlinkSync(srcpath, dstpath, type) {
        const destinationExists = fs.existsSync(dstpath)
        if (destinationExists) return undefined

        const relative = symlinkPathsSync(srcpath, dstpath)
        srcpath = relative.toDst
        type = symlinkTypeSync(relative.toCwd, type)
        const dir = path.dirname(dstpath)
        const exists = fs.existsSync(dir)
        if (exists) return fs.symlinkSync(srcpath, dstpath, type)
        mkdirsSync(dir)
        return fs.symlinkSync(srcpath, dstpath, type)
      }

      module.exports = {
        createSymlink: u(createSymlink),
        createSymlinkSync,
      }

      /***/
    },

    /***/ 1176: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      // This is adapted from https://github.com/normalize/mz
      // Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const fs = __nccwpck_require__(7758)

      const api = [
        'access',
        'appendFile',
        'chmod',
        'chown',
        'close',
        'copyFile',
        'fchmod',
        'fchown',
        'fdatasync',
        'fstat',
        'fsync',
        'ftruncate',
        'futimes',
        'lchown',
        'lchmod',
        'link',
        'lstat',
        'mkdir',
        'mkdtemp',
        'open',
        'readFile',
        'readdir',
        'readlink',
        'realpath',
        'rename',
        'rmdir',
        'stat',
        'symlink',
        'truncate',
        'unlink',
        'utimes',
        'writeFile',
      ].filter(key => {
        // Some commands are not available on some systems. Ex:
        // fs.copyFile was added in Node.js v8.5.0
        // fs.mkdtemp was added in Node.js v5.10.0
        // fs.lchown is not available on at least some Linux
        return typeof fs[key] === 'function'
      })

      // Export all keys:
      Object.keys(fs).forEach(key => {
        if (key === 'promises') {
          // fs.promises is a getter property that triggers ExperimentalWarning
          // Don't re-export it here, the getter is defined in "lib/index.js"
          return
        }
        exports[key] = fs[key]
      })

      // Universalify async methods:
      api.forEach(method => {
        exports[method] = u(fs[method])
      })

      // We differ from mz/fs in that we still ship the old, broken, fs.exists()
      // since we are a drop-in replacement for the native module
      exports.exists = function (filename, callback) {
        if (typeof callback === 'function') {
          return fs.exists(filename, callback)
        }
        return new Promise(resolve => {
          return fs.exists(filename, resolve)
        })
      }

      // fs.read() & fs.write need special treatment due to multiple callback args

      exports.read = function (fd, buffer, offset, length, position, callback) {
        if (typeof callback === 'function') {
          return fs.read(fd, buffer, offset, length, position, callback)
        }
        return new Promise((resolve, reject) => {
          fs.read(
            fd,
            buffer,
            offset,
            length,
            position,
            (err, bytesRead, buffer) => {
              if (err) return reject(err)
              resolve({ bytesRead, buffer })
            }
          )
        })
      }

      // Function signature can be
      // fs.write(fd, buffer[, offset[, length[, position]]], callback)
      // OR
      // fs.write(fd, string[, position[, encoding]], callback)
      // We need to handle both cases, so we use ...args
      exports.write = function (fd, buffer, ...args) {
        if (typeof args[args.length - 1] === 'function') {
          return fs.write(fd, buffer, ...args)
        }

        return new Promise((resolve, reject) => {
          fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
            if (err) return reject(err)
            resolve({ bytesWritten, buffer })
          })
        })
      }

      /***/
    },

    /***/ 5630: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      module.exports = Object.assign(
        {},
        // Export promiseified graceful-fs:
        __nccwpck_require__(1176),
        // Export extra methods:
        __nccwpck_require__(1135),
        __nccwpck_require__(1335),
        __nccwpck_require__(6970),
        __nccwpck_require__(55),
        __nccwpck_require__(213),
        __nccwpck_require__(8605),
        __nccwpck_require__(9665),
        __nccwpck_require__(1497),
        __nccwpck_require__(6570),
        __nccwpck_require__(3835),
        __nccwpck_require__(7357)
      )

      // Export fs.promises as a getter property so that we don't trigger
      // ExperimentalWarning before fs.promises is actually accessed.
      const fs = __nccwpck_require__(7147)
      if (Object.getOwnPropertyDescriptor(fs, 'promises')) {
        Object.defineProperty(module.exports, 'promises', {
          get() {
            return fs.promises
          },
        })
      }

      /***/
    },

    /***/ 213: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const jsonFile = __nccwpck_require__(8970)

      jsonFile.outputJson = u(__nccwpck_require__(531))
      jsonFile.outputJsonSync = __nccwpck_require__(9421)
      // aliases
      jsonFile.outputJSON = jsonFile.outputJson
      jsonFile.outputJSONSync = jsonFile.outputJsonSync
      jsonFile.writeJSON = jsonFile.writeJson
      jsonFile.writeJSONSync = jsonFile.writeJsonSync
      jsonFile.readJSON = jsonFile.readJson
      jsonFile.readJSONSync = jsonFile.readJsonSync

      module.exports = jsonFile

      /***/
    },

    /***/ 8970: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const jsonFile = __nccwpck_require__(6160)

      module.exports = {
        // jsonfile exports
        readJson: u(jsonFile.readFile),
        readJsonSync: jsonFile.readFileSync,
        writeJson: u(jsonFile.writeFile),
        writeJsonSync: jsonFile.writeFileSync,
      }

      /***/
    },

    /***/ 9421: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const mkdir = __nccwpck_require__(8605)
      const jsonFile = __nccwpck_require__(8970)

      function outputJsonSync(file, data, options) {
        const dir = path.dirname(file)

        if (!fs.existsSync(dir)) {
          mkdir.mkdirsSync(dir)
        }

        jsonFile.writeJsonSync(file, data, options)
      }

      module.exports = outputJsonSync

      /***/
    },

    /***/ 531: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const path = __nccwpck_require__(1017)
      const mkdir = __nccwpck_require__(8605)
      const pathExists = __nccwpck_require__(3835).pathExists
      const jsonFile = __nccwpck_require__(8970)

      function outputJson(file, data, options, callback) {
        if (typeof options === 'function') {
          callback = options
          options = {}
        }

        const dir = path.dirname(file)

        pathExists(dir, (err, itDoes) => {
          if (err) return callback(err)
          if (itDoes) return jsonFile.writeJson(file, data, options, callback)

          mkdir.mkdirs(dir, err => {
            if (err) return callback(err)
            jsonFile.writeJson(file, data, options, callback)
          })
        })
      }

      module.exports = outputJson

      /***/
    },

    /***/ 8605: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const mkdirs = u(__nccwpck_require__(9677))
      const mkdirsSync = __nccwpck_require__(684)

      module.exports = {
        mkdirs,
        mkdirsSync,
        // alias
        mkdirp: mkdirs,
        mkdirpSync: mkdirsSync,
        ensureDir: mkdirs,
        ensureDirSync: mkdirsSync,
      }

      /***/
    },

    /***/ 684: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const invalidWin32Path = __nccwpck_require__(1590).invalidWin32Path

      const o777 = parseInt('0777', 8)

      function mkdirsSync(p, opts, made) {
        if (!opts || typeof opts !== 'object') {
          opts = { mode: opts }
        }

        let mode = opts.mode
        const xfs = opts.fs || fs

        if (process.platform === 'win32' && invalidWin32Path(p)) {
          const errInval = new Error(
            p + ' contains invalid WIN32 path characters.'
          )
          errInval.code = 'EINVAL'
          throw errInval
        }

        if (mode === undefined) {
          mode = o777 & ~process.umask()
        }
        if (!made) made = null

        p = path.resolve(p)

        try {
          xfs.mkdirSync(p, mode)
          made = made || p
        } catch (err0) {
          if (err0.code === 'ENOENT') {
            if (path.dirname(p) === p) throw err0
            made = mkdirsSync(path.dirname(p), opts, made)
            mkdirsSync(p, opts, made)
          } else {
            // In the case of any other error, just see if there's a dir there
            // already. If so, then hooray!  If not, then something is borked.
            let stat
            try {
              stat = xfs.statSync(p)
            } catch (err1) {
              throw err0
            }
            if (!stat.isDirectory()) throw err0
          }
        }

        return made
      }

      module.exports = mkdirsSync

      /***/
    },

    /***/ 9677: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const invalidWin32Path = __nccwpck_require__(1590).invalidWin32Path

      const o777 = parseInt('0777', 8)

      function mkdirs(p, opts, callback, made) {
        if (typeof opts === 'function') {
          callback = opts
          opts = {}
        } else if (!opts || typeof opts !== 'object') {
          opts = { mode: opts }
        }

        if (process.platform === 'win32' && invalidWin32Path(p)) {
          const errInval = new Error(
            p + ' contains invalid WIN32 path characters.'
          )
          errInval.code = 'EINVAL'
          return callback(errInval)
        }

        let mode = opts.mode
        const xfs = opts.fs || fs

        if (mode === undefined) {
          mode = o777 & ~process.umask()
        }
        if (!made) made = null

        callback = callback || function () {}
        p = path.resolve(p)

        xfs.mkdir(p, mode, er => {
          if (!er) {
            made = made || p
            return callback(null, made)
          }
          switch (er.code) {
            case 'ENOENT':
              if (path.dirname(p) === p) return callback(er)
              mkdirs(path.dirname(p), opts, (er, made) => {
                if (er) callback(er, made)
                else mkdirs(p, opts, callback, made)
              })
              break

            // In the case of any other error, just see if there's a dir
            // there already.  If so, then hooray!  If not, then something
            // is borked.
            default:
              xfs.stat(p, (er2, stat) => {
                // if the stat fails, then that's super weird.
                // let the original error be the failure reason.
                if (er2 || !stat.isDirectory()) callback(er, made)
                else callback(null, made)
              })
              break
          }
        })
      }

      module.exports = mkdirs

      /***/
    },

    /***/ 1590: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const path = __nccwpck_require__(1017)

      // get drive on windows
      function getRootPath(p) {
        p = path.normalize(path.resolve(p)).split(path.sep)
        if (p.length > 0) return p[0]
        return null
      }

      // http://stackoverflow.com/a/62888/10333 contains more accurate
      // TODO: expand to include the rest
      const INVALID_PATH_CHARS = /[<>:"|?*]/

      function invalidWin32Path(p) {
        const rp = getRootPath(p)
        p = p.replace(rp, '')
        return INVALID_PATH_CHARS.test(p)
      }

      module.exports = {
        getRootPath,
        invalidWin32Path,
      }

      /***/
    },

    /***/ 9665: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const copySync = __nccwpck_require__(1135).copySync
      const removeSync = __nccwpck_require__(7357).removeSync
      const mkdirpSync = __nccwpck_require__(8605).mkdirsSync
      const buffer = __nccwpck_require__(7696)

      function moveSync(src, dest, options) {
        options = options || {}
        const overwrite = options.overwrite || options.clobber || false

        src = path.resolve(src)
        dest = path.resolve(dest)

        if (src === dest) return fs.accessSync(src)

        if (isSrcSubdir(src, dest))
          throw new Error(`Cannot move '${src}' into itself '${dest}'.`)

        mkdirpSync(path.dirname(dest))
        tryRenameSync()

        function tryRenameSync() {
          if (overwrite) {
            try {
              return fs.renameSync(src, dest)
            } catch (err) {
              if (
                err.code === 'ENOTEMPTY' ||
                err.code === 'EEXIST' ||
                err.code === 'EPERM'
              ) {
                removeSync(dest)
                options.overwrite = false // just overwriteed it, no need to do it again
                return moveSync(src, dest, options)
              }

              if (err.code !== 'EXDEV') throw err
              return moveSyncAcrossDevice(src, dest, overwrite)
            }
          } else {
            try {
              fs.linkSync(src, dest)
              return fs.unlinkSync(src)
            } catch (err) {
              if (
                err.code === 'EXDEV' ||
                err.code === 'EISDIR' ||
                err.code === 'EPERM' ||
                err.code === 'ENOTSUP'
              ) {
                return moveSyncAcrossDevice(src, dest, overwrite)
              }
              throw err
            }
          }
        }
      }

      function moveSyncAcrossDevice(src, dest, overwrite) {
        const stat = fs.statSync(src)

        if (stat.isDirectory()) {
          return moveDirSyncAcrossDevice(src, dest, overwrite)
        } else {
          return moveFileSyncAcrossDevice(src, dest, overwrite)
        }
      }

      function moveFileSyncAcrossDevice(src, dest, overwrite) {
        const BUF_LENGTH = 64 * 1024
        const _buff = buffer(BUF_LENGTH)

        const flags = overwrite ? 'w' : 'wx'

        const fdr = fs.openSync(src, 'r')
        const stat = fs.fstatSync(fdr)
        const fdw = fs.openSync(dest, flags, stat.mode)
        let pos = 0

        while (pos < stat.size) {
          const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)
          fs.writeSync(fdw, _buff, 0, bytesRead)
          pos += bytesRead
        }

        fs.closeSync(fdr)
        fs.closeSync(fdw)
        return fs.unlinkSync(src)
      }

      function moveDirSyncAcrossDevice(src, dest, overwrite) {
        const options = {
          overwrite: false,
        }

        if (overwrite) {
          removeSync(dest)
          tryCopySync()
        } else {
          tryCopySync()
        }

        function tryCopySync() {
          copySync(src, dest, options)
          return removeSync(src)
        }
      }

      // return true if dest is a subdir of src, otherwise false.
      // extract dest base dir and check if that is the same as src basename
      function isSrcSubdir(src, dest) {
        try {
          return (
            fs.statSync(src).isDirectory() &&
            src !== dest &&
            dest.indexOf(src) > -1 &&
            dest.split(path.dirname(src) + path.sep)[1].split(path.sep)[0] ===
              path.basename(src)
          )
        } catch (e) {
          return false
        }
      }

      module.exports = {
        moveSync,
      }

      /***/
    },

    /***/ 1497: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const copy = __nccwpck_require__(1335).copy
      const remove = __nccwpck_require__(7357).remove
      const mkdirp = __nccwpck_require__(8605).mkdirp
      const pathExists = __nccwpck_require__(3835).pathExists

      function move(src, dest, opts, cb) {
        if (typeof opts === 'function') {
          cb = opts
          opts = {}
        }

        const overwrite = opts.overwrite || opts.clobber || false

        src = path.resolve(src)
        dest = path.resolve(dest)

        if (src === dest) return fs.access(src, cb)

        fs.stat(src, (err, st) => {
          if (err) return cb(err)

          if (st.isDirectory() && isSrcSubdir(src, dest)) {
            return cb(
              new Error(
                `Cannot move '${src}' to a subdirectory of itself, '${dest}'.`
              )
            )
          }
          mkdirp(path.dirname(dest), err => {
            if (err) return cb(err)
            return doRename(src, dest, overwrite, cb)
          })
        })
      }

      function doRename(src, dest, overwrite, cb) {
        if (overwrite) {
          return remove(dest, err => {
            if (err) return cb(err)
            return rename(src, dest, overwrite, cb)
          })
        }
        pathExists(dest, (err, destExists) => {
          if (err) return cb(err)
          if (destExists) return cb(new Error('dest already exists.'))
          return rename(src, dest, overwrite, cb)
        })
      }

      function rename(src, dest, overwrite, cb) {
        fs.rename(src, dest, err => {
          if (!err) return cb()
          if (err.code !== 'EXDEV') return cb(err)
          return moveAcrossDevice(src, dest, overwrite, cb)
        })
      }

      function moveAcrossDevice(src, dest, overwrite, cb) {
        const opts = {
          overwrite,
          errorOnExist: true,
        }

        copy(src, dest, opts, err => {
          if (err) return cb(err)
          return remove(src, cb)
        })
      }

      function isSrcSubdir(src, dest) {
        const srcArray = src.split(path.sep)
        const destArray = dest.split(path.sep)

        return srcArray.reduce((acc, current, i) => {
          return acc && destArray[i] === current
        }, true)
      }

      module.exports = {
        move: u(move),
      }

      /***/
    },

    /***/ 6570: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const mkdir = __nccwpck_require__(8605)
      const pathExists = __nccwpck_require__(3835).pathExists

      function outputFile(file, data, encoding, callback) {
        if (typeof encoding === 'function') {
          callback = encoding
          encoding = 'utf8'
        }

        const dir = path.dirname(file)
        pathExists(dir, (err, itDoes) => {
          if (err) return callback(err)
          if (itDoes) return fs.writeFile(file, data, encoding, callback)

          mkdir.mkdirs(dir, err => {
            if (err) return callback(err)

            fs.writeFile(file, data, encoding, callback)
          })
        })
      }

      function outputFileSync(file, ...args) {
        const dir = path.dirname(file)
        if (fs.existsSync(dir)) {
          return fs.writeFileSync(file, ...args)
        }
        mkdir.mkdirsSync(dir)
        fs.writeFileSync(file, ...args)
      }

      module.exports = {
        outputFile: u(outputFile),
        outputFileSync,
      }

      /***/
    },

    /***/ 3835: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromPromise */.p
      const fs = __nccwpck_require__(1176)

      function pathExists(path) {
        return fs
          .access(path)
          .then(() => true)
          .catch(() => false)
      }

      module.exports = {
        pathExists: u(pathExists),
        pathExistsSync: fs.existsSync,
      }

      /***/
    },

    /***/ 7357: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const u = __nccwpck_require__(9046) /* .fromCallback */.E
      const rimraf = __nccwpck_require__(8761)

      module.exports = {
        remove: u(rimraf),
        removeSync: rimraf.sync,
      }

      /***/
    },

    /***/ 8761: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const path = __nccwpck_require__(1017)
      const assert = __nccwpck_require__(9491)

      const isWindows = process.platform === 'win32'

      function defaults(options) {
        const methods = ['unlink', 'chmod', 'stat', 'lstat', 'rmdir', 'readdir']
        methods.forEach(m => {
          options[m] = options[m] || fs[m]
          m = m + 'Sync'
          options[m] = options[m] || fs[m]
        })

        options.maxBusyTries = options.maxBusyTries || 3
      }

      function rimraf(p, options, cb) {
        let busyTries = 0

        if (typeof options === 'function') {
          cb = options
          options = {}
        }

        assert(p, 'rimraf: missing path')
        assert.strictEqual(
          typeof p,
          'string',
          'rimraf: path should be a string'
        )
        assert.strictEqual(
          typeof cb,
          'function',
          'rimraf: callback function required'
        )
        assert(options, 'rimraf: invalid options argument provided')
        assert.strictEqual(
          typeof options,
          'object',
          'rimraf: options should be object'
        )

        defaults(options)

        rimraf_(p, options, function CB(er) {
          if (er) {
            if (
              (er.code === 'EBUSY' ||
                er.code === 'ENOTEMPTY' ||
                er.code === 'EPERM') &&
              busyTries < options.maxBusyTries
            ) {
              busyTries++
              const time = busyTries * 100
              // try again, with the same exact callback as this one.
              return setTimeout(() => rimraf_(p, options, CB), time)
            }

            // already gone
            if (er.code === 'ENOENT') er = null
          }

          cb(er)
        })
      }

      // Two possible strategies.
      // 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
      // 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
      //
      // Both result in an extra syscall when you guess wrong.  However, there
      // are likely far more normal files in the world than directories.  This
      // is based on the assumption that a the average number of files per
      // directory is >= 1.
      //
      // If anyone ever complains about this, then I guess the strategy could
      // be made configurable somehow.  But until then, YAGNI.
      function rimraf_(p, options, cb) {
        assert(p)
        assert(options)
        assert(typeof cb === 'function')

        // sunos lets the root user unlink directories, which is... weird.
        // so we have to lstat here and make sure it's not a dir.
        options.lstat(p, (er, st) => {
          if (er && er.code === 'ENOENT') {
            return cb(null)
          }

          // Windows can EPERM on stat.  Life is suffering.
          if (er && er.code === 'EPERM' && isWindows) {
            return fixWinEPERM(p, options, er, cb)
          }

          if (st && st.isDirectory()) {
            return rmdir(p, options, er, cb)
          }

          options.unlink(p, er => {
            if (er) {
              if (er.code === 'ENOENT') {
                return cb(null)
              }
              if (er.code === 'EPERM') {
                return isWindows
                  ? fixWinEPERM(p, options, er, cb)
                  : rmdir(p, options, er, cb)
              }
              if (er.code === 'EISDIR') {
                return rmdir(p, options, er, cb)
              }
            }
            return cb(er)
          })
        })
      }

      function fixWinEPERM(p, options, er, cb) {
        assert(p)
        assert(options)
        assert(typeof cb === 'function')
        if (er) {
          assert(er instanceof Error)
        }

        options.chmod(p, 0o666, er2 => {
          if (er2) {
            cb(er2.code === 'ENOENT' ? null : er)
          } else {
            options.stat(p, (er3, stats) => {
              if (er3) {
                cb(er3.code === 'ENOENT' ? null : er)
              } else if (stats.isDirectory()) {
                rmdir(p, options, er, cb)
              } else {
                options.unlink(p, cb)
              }
            })
          }
        })
      }

      function fixWinEPERMSync(p, options, er) {
        let stats

        assert(p)
        assert(options)
        if (er) {
          assert(er instanceof Error)
        }

        try {
          options.chmodSync(p, 0o666)
        } catch (er2) {
          if (er2.code === 'ENOENT') {
            return
          } else {
            throw er
          }
        }

        try {
          stats = options.statSync(p)
        } catch (er3) {
          if (er3.code === 'ENOENT') {
            return
          } else {
            throw er
          }
        }

        if (stats.isDirectory()) {
          rmdirSync(p, options, er)
        } else {
          options.unlinkSync(p)
        }
      }

      function rmdir(p, options, originalEr, cb) {
        assert(p)
        assert(options)
        if (originalEr) {
          assert(originalEr instanceof Error)
        }
        assert(typeof cb === 'function')

        // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
        // if we guessed wrong, and it's not a directory, then
        // raise the original error.
        options.rmdir(p, er => {
          if (
            er &&
            (er.code === 'ENOTEMPTY' ||
              er.code === 'EEXIST' ||
              er.code === 'EPERM')
          ) {
            rmkids(p, options, cb)
          } else if (er && er.code === 'ENOTDIR') {
            cb(originalEr)
          } else {
            cb(er)
          }
        })
      }

      function rmkids(p, options, cb) {
        assert(p)
        assert(options)
        assert(typeof cb === 'function')

        options.readdir(p, (er, files) => {
          if (er) return cb(er)

          let n = files.length
          let errState

          if (n === 0) return options.rmdir(p, cb)

          files.forEach(f => {
            rimraf(path.join(p, f), options, er => {
              if (errState) {
                return
              }
              if (er) return cb((errState = er))
              if (--n === 0) {
                options.rmdir(p, cb)
              }
            })
          })
        })
      }

      // this looks simpler, and is strictly *faster*, but will
      // tie up the JavaScript thread and fail on excessively
      // deep directory trees.
      function rimrafSync(p, options) {
        let st

        options = options || {}
        defaults(options)

        assert(p, 'rimraf: missing path')
        assert.strictEqual(
          typeof p,
          'string',
          'rimraf: path should be a string'
        )
        assert(options, 'rimraf: missing options')
        assert.strictEqual(
          typeof options,
          'object',
          'rimraf: options should be object'
        )

        try {
          st = options.lstatSync(p)
        } catch (er) {
          if (er.code === 'ENOENT') {
            return
          }

          // Windows can EPERM on stat.  Life is suffering.
          if (er.code === 'EPERM' && isWindows) {
            fixWinEPERMSync(p, options, er)
          }
        }

        try {
          // sunos lets the root user unlink directories, which is... weird.
          if (st && st.isDirectory()) {
            rmdirSync(p, options, null)
          } else {
            options.unlinkSync(p)
          }
        } catch (er) {
          if (er.code === 'ENOENT') {
            return
          } else if (er.code === 'EPERM') {
            return isWindows
              ? fixWinEPERMSync(p, options, er)
              : rmdirSync(p, options, er)
          } else if (er.code !== 'EISDIR') {
            throw er
          }
          rmdirSync(p, options, er)
        }
      }

      function rmdirSync(p, options, originalEr) {
        assert(p)
        assert(options)
        if (originalEr) {
          assert(originalEr instanceof Error)
        }

        try {
          options.rmdirSync(p)
        } catch (er) {
          if (er.code === 'ENOTDIR') {
            throw originalEr
          } else if (
            er.code === 'ENOTEMPTY' ||
            er.code === 'EEXIST' ||
            er.code === 'EPERM'
          ) {
            rmkidsSync(p, options)
          } else if (er.code !== 'ENOENT') {
            throw er
          }
        }
      }

      function rmkidsSync(p, options) {
        assert(p)
        assert(options)
        options
          .readdirSync(p)
          .forEach(f => rimrafSync(path.join(p, f), options))

        if (isWindows) {
          // We only end up here once we got ENOTEMPTY at least once, and
          // at this point, we are guaranteed to have removed all the kids.
          // So, we know that it won't be ENOENT or ENOTDIR or anything else.
          // try really hard to delete stuff on windows, because it has a
          // PROFOUNDLY annoying habit of not closing handles promptly when
          // files are deleted, resulting in spurious ENOTEMPTY errors.
          const startTime = Date.now()
          do {
            try {
              const ret = options.rmdirSync(p, options)
              return ret
            } catch (er) {}
          } while (Date.now() - startTime < 500) // give up after 500ms
        } else {
          const ret = options.rmdirSync(p, options)
          return ret
        }
      }

      module.exports = rimraf
      rimraf.sync = rimrafSync

      /***/
    },

    /***/ 7696: /***/ module => {
      'use strict'

      /* eslint-disable node/no-deprecated-api */
      module.exports = function (size) {
        if (typeof Buffer.allocUnsafe === 'function') {
          try {
            return Buffer.allocUnsafe(size)
          } catch (e) {
            return new Buffer(size)
          }
        }
        return new Buffer(size)
      }

      /***/
    },

    /***/ 2548: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const os = __nccwpck_require__(2037)
      const path = __nccwpck_require__(1017)

      // HFS, ext{2,3}, FAT do not, Node.js v0.10 does not
      function hasMillisResSync() {
        let tmpfile = path.join(
          'millis-test-sync' +
            Date.now().toString() +
            Math.random().toString().slice(2)
        )
        tmpfile = path.join(os.tmpdir(), tmpfile)

        // 550 millis past UNIX epoch
        const d = new Date(1435410243862)
        fs.writeFileSync(
          tmpfile,
          'https://github.com/jprichardson/node-fs-extra/pull/141'
        )
        const fd = fs.openSync(tmpfile, 'r+')
        fs.futimesSync(fd, d, d)
        fs.closeSync(fd)
        return fs.statSync(tmpfile).mtime > 1435410243000
      }

      function hasMillisRes(callback) {
        let tmpfile = path.join(
          'millis-test' +
            Date.now().toString() +
            Math.random().toString().slice(2)
        )
        tmpfile = path.join(os.tmpdir(), tmpfile)

        // 550 millis past UNIX epoch
        const d = new Date(1435410243862)
        fs.writeFile(
          tmpfile,
          'https://github.com/jprichardson/node-fs-extra/pull/141',
          err => {
            if (err) return callback(err)
            fs.open(tmpfile, 'r+', (err, fd) => {
              if (err) return callback(err)
              fs.futimes(fd, d, d, err => {
                if (err) return callback(err)
                fs.close(fd, err => {
                  if (err) return callback(err)
                  fs.stat(tmpfile, (err, stats) => {
                    if (err) return callback(err)
                    callback(null, stats.mtime > 1435410243000)
                  })
                })
              })
            })
          }
        )
      }

      function timeRemoveMillis(timestamp) {
        if (typeof timestamp === 'number') {
          return Math.floor(timestamp / 1000) * 1000
        } else if (timestamp instanceof Date) {
          return new Date(Math.floor(timestamp.getTime() / 1000) * 1000)
        } else {
          throw new Error('fs-extra: timeRemoveMillis() unknown parameter type')
        }
      }

      function utimesMillis(path, atime, mtime, callback) {
        // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
        fs.open(path, 'r+', (err, fd) => {
          if (err) return callback(err)
          fs.futimes(fd, atime, mtime, futimesErr => {
            fs.close(fd, closeErr => {
              if (callback) callback(futimesErr || closeErr)
            })
          })
        })
      }

      function utimesMillisSync(path, atime, mtime) {
        const fd = fs.openSync(path, 'r+')
        fs.futimesSync(fd, atime, mtime)
        return fs.closeSync(fd)
      }

      module.exports = {
        hasMillisRes,
        hasMillisResSync,
        timeRemoveMillis,
        utimesMillis,
        utimesMillisSync,
      }

      /***/
    },

    /***/ 4655: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var isGlob = __nccwpck_require__(4466)
      var pathPosixDirname = __nccwpck_require__(1017).posix.dirname
      var isWin32 = __nccwpck_require__(2037).platform() === 'win32'

      var slash = '/'
      var backslash = /\\/g
      var enclosure = /[\{\[].*[\}\]]$/
      var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/
      var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g

      /**
       * @param {string} str
       * @param {Object} opts
       * @param {boolean} [opts.flipBackslashes=true]
       * @returns {string}
       */
      module.exports = function globParent(str, opts) {
        var options = Object.assign({ flipBackslashes: true }, opts)

        // flip windows path separators
        if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
          str = str.replace(backslash, slash)
        }

        // special case for strings ending in enclosure containing path separator
        if (enclosure.test(str)) {
          str += slash
        }

        // preserves full path in case of trailing path separator
        str += 'a'

        // remove path parts that are globby
        do {
          str = pathPosixDirname(str)
        } while (isGlob(str) || globby.test(str))

        // remove escape chars and return result
        return str.replace(escaped, '$1')
      }

      /***/
    },

    /***/ 9038: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const { promisify } = __nccwpck_require__(3837)
      const fs = __nccwpck_require__(7147)
      const path = __nccwpck_require__(1017)
      const fastGlob = __nccwpck_require__(3664)
      const gitIgnore = __nccwpck_require__(4777)
      const slash = __nccwpck_require__(4111)

      const DEFAULT_IGNORE = [
        '**/node_modules/**',
        '**/flow-typed/**',
        '**/coverage/**',
        '**/.git',
      ]

      const readFileP = promisify(fs.readFile)

      const mapGitIgnorePatternTo = base => ignore => {
        if (ignore.startsWith('!')) {
          return '!' + path.posix.join(base, ignore.slice(1))
        }

        return path.posix.join(base, ignore)
      }

      const parseGitIgnore = (content, options) => {
        const base = slash(
          path.relative(options.cwd, path.dirname(options.fileName))
        )

        return content
          .split(/\r?\n/)
          .filter(Boolean)
          .filter(line => !line.startsWith('#'))
          .map(mapGitIgnorePatternTo(base))
      }

      const reduceIgnore = files => {
        const ignores = gitIgnore()
        for (const file of files) {
          ignores.add(
            parseGitIgnore(file.content, {
              cwd: file.cwd,
              fileName: file.filePath,
            })
          )
        }

        return ignores
      }

      const ensureAbsolutePathForCwd = (cwd, p) => {
        cwd = slash(cwd)
        if (path.isAbsolute(p)) {
          if (slash(p).startsWith(cwd)) {
            return p
          }

          throw new Error(`Path ${p} is not in cwd ${cwd}`)
        }

        return path.join(cwd, p)
      }

      const getIsIgnoredPredecate = (ignores, cwd) => {
        return p =>
          ignores.ignores(
            slash(
              path.relative(cwd, ensureAbsolutePathForCwd(cwd, p.path || p))
            )
          )
      }

      const getFile = async (file, cwd) => {
        const filePath = path.join(cwd, file)
        const content = await readFileP(filePath, 'utf8')

        return {
          cwd,
          filePath,
          content,
        }
      }

      const getFileSync = (file, cwd) => {
        const filePath = path.join(cwd, file)
        const content = fs.readFileSync(filePath, 'utf8')

        return {
          cwd,
          filePath,
          content,
        }
      }

      const normalizeOptions = ({
        ignore = [],
        cwd = slash(process.cwd()),
      } = {}) => {
        return { ignore, cwd }
      }

      module.exports = async options => {
        options = normalizeOptions(options)

        const paths = await fastGlob('**/.gitignore', {
          ignore: DEFAULT_IGNORE.concat(options.ignore),
          cwd: options.cwd,
        })

        const files = await Promise.all(
          paths.map(file => getFile(file, options.cwd))
        )
        const ignores = reduceIgnore(files)

        return getIsIgnoredPredecate(ignores, options.cwd)
      }

      module.exports.sync = options => {
        options = normalizeOptions(options)

        const paths = fastGlob.sync('**/.gitignore', {
          ignore: DEFAULT_IGNORE.concat(options.ignore),
          cwd: options.cwd,
        })

        const files = paths.map(file => getFileSync(file, options.cwd))
        const ignores = reduceIgnore(files)

        return getIsIgnoredPredecate(ignores, options.cwd)
      }

      /***/
    },

    /***/ 3398: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7147)
      const arrayUnion = __nccwpck_require__(9600)
      const merge2 = __nccwpck_require__(2578)
      const fastGlob = __nccwpck_require__(3664)
      const dirGlob = __nccwpck_require__(2738)
      const gitignore = __nccwpck_require__(9038)
      const { FilterStream, UniqueStream } = __nccwpck_require__(2408)

      const DEFAULT_FILTER = () => false

      const isNegative = pattern => pattern[0] === '!'

      const assertPatternsInput = patterns => {
        if (!patterns.every(pattern => typeof pattern === 'string')) {
          throw new TypeError(
            'Patterns must be a string or an array of strings'
          )
        }
      }

      const checkCwdOption = (options = {}) => {
        if (!options.cwd) {
          return
        }

        let stat
        try {
          stat = fs.statSync(options.cwd)
        } catch {
          return
        }

        if (!stat.isDirectory()) {
          throw new Error('The `cwd` option must be a path to a directory')
        }
      }

      const getPathString = p => (p.stats instanceof fs.Stats ? p.path : p)

      const generateGlobTasks = (patterns, taskOptions) => {
        patterns = arrayUnion([].concat(patterns))
        assertPatternsInput(patterns)
        checkCwdOption(taskOptions)

        const globTasks = []

        taskOptions = {
          ignore: [],
          expandDirectories: true,
          ...taskOptions,
        }

        for (const [index, pattern] of patterns.entries()) {
          if (isNegative(pattern)) {
            continue
          }

          const ignore = patterns
            .slice(index)
            .filter(pattern => isNegative(pattern))
            .map(pattern => pattern.slice(1))

          const options = {
            ...taskOptions,
            ignore: taskOptions.ignore.concat(ignore),
          }

          globTasks.push({ pattern, options })
        }

        return globTasks
      }

      const globDirs = (task, fn) => {
        let options = {}
        if (task.options.cwd) {
          options.cwd = task.options.cwd
        }

        if (Array.isArray(task.options.expandDirectories)) {
          options = {
            ...options,
            files: task.options.expandDirectories,
          }
        } else if (typeof task.options.expandDirectories === 'object') {
          options = {
            ...options,
            ...task.options.expandDirectories,
          }
        }

        return fn(task.pattern, options)
      }

      const getPattern = (task, fn) =>
        task.options.expandDirectories ? globDirs(task, fn) : [task.pattern]

      const getFilterSync = options => {
        return options && options.gitignore
          ? gitignore.sync({ cwd: options.cwd, ignore: options.ignore })
          : DEFAULT_FILTER
      }

      const globToTask = task => glob => {
        const { options } = task
        if (
          options.ignore &&
          Array.isArray(options.ignore) &&
          options.expandDirectories
        ) {
          options.ignore = dirGlob.sync(options.ignore)
        }

        return {
          pattern: glob,
          options,
        }
      }

      module.exports = async (patterns, options) => {
        const globTasks = generateGlobTasks(patterns, options)

        const getFilter = async () => {
          return options && options.gitignore
            ? gitignore({ cwd: options.cwd, ignore: options.ignore })
            : DEFAULT_FILTER
        }

        const getTasks = async () => {
          const tasks = await Promise.all(
            globTasks.map(async task => {
              const globs = await getPattern(task, dirGlob)
              return Promise.all(globs.map(globToTask(task)))
            })
          )

          return arrayUnion(...tasks)
        }

        const [filter, tasks] = await Promise.all([getFilter(), getTasks()])
        const paths = await Promise.all(
          tasks.map(task => fastGlob(task.pattern, task.options))
        )

        return arrayUnion(...paths).filter(
          path_ => !filter(getPathString(path_))
        )
      }

      module.exports.sync = (patterns, options) => {
        const globTasks = generateGlobTasks(patterns, options)

        const tasks = []
        for (const task of globTasks) {
          const newTask = getPattern(task, dirGlob.sync).map(globToTask(task))
          tasks.push(...newTask)
        }

        const filter = getFilterSync(options)

        let matches = []
        for (const task of tasks) {
          matches = arrayUnion(
            matches,
            fastGlob.sync(task.pattern, task.options)
          )
        }

        return matches.filter(path_ => !filter(path_))
      }

      module.exports.stream = (patterns, options) => {
        const globTasks = generateGlobTasks(patterns, options)

        const tasks = []
        for (const task of globTasks) {
          const newTask = getPattern(task, dirGlob.sync).map(globToTask(task))
          tasks.push(...newTask)
        }

        const filter = getFilterSync(options)
        const filterStream = new FilterStream(p => !filter(p))
        const uniqueStream = new UniqueStream()

        return merge2(
          tasks.map(task => fastGlob.stream(task.pattern, task.options))
        )
          .pipe(filterStream)
          .pipe(uniqueStream)
      }

      module.exports.generateGlobTasks = generateGlobTasks

      module.exports.hasMagic = (patterns, options) =>
        []
          .concat(patterns)
          .some(pattern => fastGlob.isDynamicPattern(pattern, options))

      module.exports.gitignore = gitignore

      /***/
    },

    /***/ 2408: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const { Transform } = __nccwpck_require__(2781)

      class ObjectTransform extends Transform {
        constructor() {
          super({
            objectMode: true,
          })
        }
      }

      class FilterStream extends ObjectTransform {
        constructor(filter) {
          super()
          this._filter = filter
        }

        _transform(data, encoding, callback) {
          if (this._filter(data)) {
            this.push(data)
          }

          callback()
        }
      }

      class UniqueStream extends ObjectTransform {
        constructor() {
          super()
          this._pushed = new Set()
        }

        _transform(data, encoding, callback) {
          if (!this._pushed.has(data)) {
            this.push(data)
            this._pushed.add(data)
          }

          callback()
        }
      }

      module.exports = {
        FilterStream,
        UniqueStream,
      }

      /***/
    },

    /***/ 7356: /***/ module => {
      'use strict'

      module.exports = clone

      var getPrototypeOf =
        Object.getPrototypeOf ||
        function (obj) {
          return obj.__proto__
        }

      function clone(obj) {
        if (obj === null || typeof obj !== 'object') return obj

        if (obj instanceof Object) var copy = { __proto__: getPrototypeOf(obj) }
        else var copy = Object.create(null)

        Object.getOwnPropertyNames(obj).forEach(function (key) {
          Object.defineProperty(
            copy,
            key,
            Object.getOwnPropertyDescriptor(obj, key)
          )
        })

        return copy
      }

      /***/
    },

    /***/ 7758: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      var fs = __nccwpck_require__(7147)
      var polyfills = __nccwpck_require__(263)
      var legacy = __nccwpck_require__(3086)
      var clone = __nccwpck_require__(7356)

      var util = __nccwpck_require__(3837)

      /* istanbul ignore next - node 0.x polyfill */
      var gracefulQueue
      var previousSymbol

      /* istanbul ignore else - node 0.x polyfill */
      if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
        gracefulQueue = Symbol.for('graceful-fs.queue')
        // This is used in testing by future versions
        previousSymbol = Symbol.for('graceful-fs.previous')
      } else {
        gracefulQueue = '___graceful-fs.queue'
        previousSymbol = '___graceful-fs.previous'
      }

      function noop() {}

      function publishQueue(context, queue) {
        Object.defineProperty(context, gracefulQueue, {
          get: function () {
            return queue
          },
        })
      }

      var debug = noop
      if (util.debuglog) debug = util.debuglog('gfs4')
      else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
        debug = function () {
          var m = util.format.apply(util, arguments)
          m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ')
          console.error(m)
        }

      // Once time initialization
      if (!fs[gracefulQueue]) {
        // This queue can be shared by multiple loaded instances
        var queue = global[gracefulQueue] || []
        publishQueue(fs, queue)

        // Patch fs.close/closeSync to shared queue version, because we need
        // to retry() whenever a close happens *anywhere* in the program.
        // This is essential when multiple graceful-fs instances are
        // in play at the same time.
        fs.close = (function (fs$close) {
          function close(fd, cb) {
            return fs$close.call(fs, fd, function (err) {
              // This function uses the graceful-fs shared queue
              if (!err) {
                resetQueue()
              }

              if (typeof cb === 'function') cb.apply(this, arguments)
            })
          }

          Object.defineProperty(close, previousSymbol, {
            value: fs$close,
          })
          return close
        })(fs.close)

        fs.closeSync = (function (fs$closeSync) {
          function closeSync(fd) {
            // This function uses the graceful-fs shared queue
            fs$closeSync.apply(fs, arguments)
            resetQueue()
          }

          Object.defineProperty(closeSync, previousSymbol, {
            value: fs$closeSync,
          })
          return closeSync
        })(fs.closeSync)

        if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
          process.on('exit', function () {
            debug(fs[gracefulQueue])
            __nccwpck_require__(9491).equal(fs[gracefulQueue].length, 0)
          })
        }
      }

      if (!global[gracefulQueue]) {
        publishQueue(global, fs[gracefulQueue])
      }

      module.exports = patch(clone(fs))
      if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
        module.exports = patch(fs)
        fs.__patched = true
      }

      function patch(fs) {
        // Everything that references the open() function needs to be in here
        polyfills(fs)
        fs.gracefulify = patch

        fs.createReadStream = createReadStream
        fs.createWriteStream = createWriteStream
        var fs$readFile = fs.readFile
        fs.readFile = readFile
        function readFile(path, options, cb) {
          if (typeof options === 'function') (cb = options), (options = null)

          return go$readFile(path, options, cb)

          function go$readFile(path, options, cb, startTime) {
            return fs$readFile(path, options, function (err) {
              if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
                enqueue([
                  go$readFile,
                  [path, options, cb],
                  err,
                  startTime || Date.now(),
                  Date.now(),
                ])
              else {
                if (typeof cb === 'function') cb.apply(this, arguments)
              }
            })
          }
        }

        var fs$writeFile = fs.writeFile
        fs.writeFile = writeFile
        function writeFile(path, data, options, cb) {
          if (typeof options === 'function') (cb = options), (options = null)

          return go$writeFile(path, data, options, cb)

          function go$writeFile(path, data, options, cb, startTime) {
            return fs$writeFile(path, data, options, function (err) {
              if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
                enqueue([
                  go$writeFile,
                  [path, data, options, cb],
                  err,
                  startTime || Date.now(),
                  Date.now(),
                ])
              else {
                if (typeof cb === 'function') cb.apply(this, arguments)
              }
            })
          }
        }

        var fs$appendFile = fs.appendFile
        if (fs$appendFile) fs.appendFile = appendFile
        function appendFile(path, data, options, cb) {
          if (typeof options === 'function') (cb = options), (options = null)

          return go$appendFile(path, data, options, cb)

          function go$appendFile(path, data, options, cb, startTime) {
            return fs$appendFile(path, data, options, function (err) {
              if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
                enqueue([
                  go$appendFile,
                  [path, data, options, cb],
                  err,
                  startTime || Date.now(),
                  Date.now(),
                ])
              else {
                if (typeof cb === 'function') cb.apply(this, arguments)
              }
            })
          }
        }

        var fs$copyFile = fs.copyFile
        if (fs$copyFile) fs.copyFile = copyFile
        function copyFile(src, dest, flags, cb) {
          if (typeof flags === 'function') {
            cb = flags
            flags = 0
          }
          return go$copyFile(src, dest, flags, cb)

          function go$copyFile(src, dest, flags, cb, startTime) {
            return fs$copyFile(src, dest, flags, function (err) {
              if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
                enqueue([
                  go$copyFile,
                  [src, dest, flags, cb],
                  err,
                  startTime || Date.now(),
                  Date.now(),
                ])
              else {
                if (typeof cb === 'function') cb.apply(this, arguments)
              }
            })
          }
        }

        var fs$readdir = fs.readdir
        fs.readdir = readdir
        var noReaddirOptionVersions = /^v[0-5]\./
        function readdir(path, options, cb) {
          if (typeof options === 'function') (cb = options), (options = null)

          var go$readdir = noReaddirOptionVersions.test(process.version)
            ? function go$readdir(path, options, cb, startTime) {
                return fs$readdir(
                  path,
                  fs$readdirCallback(path, options, cb, startTime)
                )
              }
            : function go$readdir(path, options, cb, startTime) {
                return fs$readdir(
                  path,
                  options,
                  fs$readdirCallback(path, options, cb, startTime)
                )
              }

          return go$readdir(path, options, cb)

          function fs$readdirCallback(path, options, cb, startTime) {
            return function (err, files) {
              if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
                enqueue([
                  go$readdir,
                  [path, options, cb],
                  err,
                  startTime || Date.now(),
                  Date.now(),
                ])
              else {
                if (files && files.sort) files.sort()

                if (typeof cb === 'function') cb.call(this, err, files)
              }
            }
          }
        }

        if (process.version.substr(0, 4) === 'v0.8') {
          var legStreams = legacy(fs)
          ReadStream = legStreams.ReadStream
          WriteStream = legStreams.WriteStream
        }

        var fs$ReadStream = fs.ReadStream
        if (fs$ReadStream) {
          ReadStream.prototype = Object.create(fs$ReadStream.prototype)
          ReadStream.prototype.open = ReadStream$open
        }

        var fs$WriteStream = fs.WriteStream
        if (fs$WriteStream) {
          WriteStream.prototype = Object.create(fs$WriteStream.prototype)
          WriteStream.prototype.open = WriteStream$open
        }

        Object.defineProperty(fs, 'ReadStream', {
          get: function () {
            return ReadStream
          },
          set: function (val) {
            ReadStream = val
          },
          enumerable: true,
          configurable: true,
        })
        Object.defineProperty(fs, 'WriteStream', {
          get: function () {
            return WriteStream
          },
          set: function (val) {
            WriteStream = val
          },
          enumerable: true,
          configurable: true,
        })

        // legacy names
        var FileReadStream = ReadStream
        Object.defineProperty(fs, 'FileReadStream', {
          get: function () {
            return FileReadStream
          },
          set: function (val) {
            FileReadStream = val
          },
          enumerable: true,
          configurable: true,
        })
        var FileWriteStream = WriteStream
        Object.defineProperty(fs, 'FileWriteStream', {
          get: function () {
            return FileWriteStream
          },
          set: function (val) {
            FileWriteStream = val
          },
          enumerable: true,
          configurable: true,
        })

        function ReadStream(path, options) {
          if (this instanceof ReadStream)
            return fs$ReadStream.apply(this, arguments), this
          else
            return ReadStream.apply(
              Object.create(ReadStream.prototype),
              arguments
            )
        }

        function ReadStream$open() {
          var that = this
          open(that.path, that.flags, that.mode, function (err, fd) {
            if (err) {
              if (that.autoClose) that.destroy()

              that.emit('error', err)
            } else {
              that.fd = fd
              that.emit('open', fd)
              that.read()
            }
          })
        }

        function WriteStream(path, options) {
          if (this instanceof WriteStream)
            return fs$WriteStream.apply(this, arguments), this
          else
            return WriteStream.apply(
              Object.create(WriteStream.prototype),
              arguments
            )
        }

        function WriteStream$open() {
          var that = this
          open(that.path, that.flags, that.mode, function (err, fd) {
            if (err) {
              that.destroy()
              that.emit('error', err)
            } else {
              that.fd = fd
              that.emit('open', fd)
            }
          })
        }

        function createReadStream(path, options) {
          return new fs.ReadStream(path, options)
        }

        function createWriteStream(path, options) {
          return new fs.WriteStream(path, options)
        }

        var fs$open = fs.open
        fs.open = open
        function open(path, flags, mode, cb) {
          if (typeof mode === 'function') (cb = mode), (mode = null)

          return go$open(path, flags, mode, cb)

          function go$open(path, flags, mode, cb, startTime) {
            return fs$open(path, flags, mode, function (err, fd) {
              if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
                enqueue([
                  go$open,
                  [path, flags, mode, cb],
                  err,
                  startTime || Date.now(),
                  Date.now(),
                ])
              else {
                if (typeof cb === 'function') cb.apply(this, arguments)
              }
            })
          }
        }

        return fs
      }

      function enqueue(elem) {
        debug('ENQUEUE', elem[0].name, elem[1])
        fs[gracefulQueue].push(elem)
        retry()
      }

      // keep track of the timeout between retry() calls
      var retryTimer

      // reset the startTime and lastTime to now
      // this resets the start of the 60 second overall timeout as well as the
      // delay between attempts so that we'll retry these jobs sooner
      function resetQueue() {
        var now = Date.now()
        for (var i = 0; i < fs[gracefulQueue].length; ++i) {
          // entries that are only a length of 2 are from an older version, don't
          // bother modifying those since they'll be retried anyway.
          if (fs[gracefulQueue][i].length > 2) {
            fs[gracefulQueue][i][3] = now // startTime
            fs[gracefulQueue][i][4] = now // lastTime
          }
        }
        // call retry to make sure we're actively processing the queue
        retry()
      }

      function retry() {
        // clear the timer and remove it to help prevent unintended concurrency
        clearTimeout(retryTimer)
        retryTimer = undefined

        if (fs[gracefulQueue].length === 0) return

        var elem = fs[gracefulQueue].shift()
        var fn = elem[0]
        var args = elem[1]
        // these items may be unset if they were added by an older graceful-fs
        var err = elem[2]
        var startTime = elem[3]
        var lastTime = elem[4]

        // if we don't have a startTime we have no way of knowing if we've waited
        // long enough, so go ahead and retry this item now
        if (startTime === undefined) {
          debug('RETRY', fn.name, args)
          fn.apply(null, args)
        } else if (Date.now() - startTime >= 60000) {
          // it's been more than 60 seconds total, bail now
          debug('TIMEOUT', fn.name, args)
          var cb = args.pop()
          if (typeof cb === 'function') cb.call(null, err)
        } else {
          // the amount of time between the last attempt and right now
          var sinceAttempt = Date.now() - lastTime
          // the amount of time between when we first tried, and when we last tried
          // rounded up to at least 1
          var sinceStart = Math.max(lastTime - startTime, 1)
          // backoff. wait longer than the total time we've been retrying, but only
          // up to a maximum of 100ms
          var desiredDelay = Math.min(sinceStart * 1.2, 100)
          // it's been long enough since the last retry, do it again
          if (sinceAttempt >= desiredDelay) {
            debug('RETRY', fn.name, args)
            fn.apply(null, args.concat([startTime]))
          } else {
            // if we can't do this job yet, push it to the end of the queue
            // and let the next iteration check again
            fs[gracefulQueue].push(elem)
          }
        }

        // schedule our next run if one isn't already scheduled
        if (retryTimer === undefined) {
          retryTimer = setTimeout(retry, 0)
        }
      }

      /***/
    },

    /***/ 3086: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      var Stream = __nccwpck_require__(2781).Stream

      module.exports = legacy

      function legacy(fs) {
        return {
          ReadStream: ReadStream,
          WriteStream: WriteStream,
        }

        function ReadStream(path, options) {
          if (!(this instanceof ReadStream))
            return new ReadStream(path, options)

          Stream.call(this)

          var self = this

          this.path = path
          this.fd = null
          this.readable = true
          this.paused = false

          this.flags = 'r'
          this.mode = 438 /*=0666*/
          this.bufferSize = 64 * 1024

          options = options || {}

          // Mixin options into this
          var keys = Object.keys(options)
          for (var index = 0, length = keys.length; index < length; index++) {
            var key = keys[index]
            this[key] = options[key]
          }

          if (this.encoding) this.setEncoding(this.encoding)

          if (this.start !== undefined) {
            if ('number' !== typeof this.start) {
              throw TypeError('start must be a Number')
            }
            if (this.end === undefined) {
              this.end = Infinity
            } else if ('number' !== typeof this.end) {
              throw TypeError('end must be a Number')
            }

            if (this.start > this.end) {
              throw new Error('start must be <= end')
            }

            this.pos = this.start
          }

          if (this.fd !== null) {
            process.nextTick(function () {
              self._read()
            })
            return
          }

          fs.open(this.path, this.flags, this.mode, function (err, fd) {
            if (err) {
              self.emit('error', err)
              self.readable = false
              return
            }

            self.fd = fd
            self.emit('open', fd)
            self._read()
          })
        }

        function WriteStream(path, options) {
          if (!(this instanceof WriteStream))
            return new WriteStream(path, options)

          Stream.call(this)

          this.path = path
          this.fd = null
          this.writable = true

          this.flags = 'w'
          this.encoding = 'binary'
          this.mode = 438 /*=0666*/
          this.bytesWritten = 0

          options = options || {}

          // Mixin options into this
          var keys = Object.keys(options)
          for (var index = 0, length = keys.length; index < length; index++) {
            var key = keys[index]
            this[key] = options[key]
          }

          if (this.start !== undefined) {
            if ('number' !== typeof this.start) {
              throw TypeError('start must be a Number')
            }
            if (this.start < 0) {
              throw new Error('start must be >= zero')
            }

            this.pos = this.start
          }

          this.busy = false
          this._queue = []

          if (this.fd === null) {
            this._open = fs.open
            this._queue.push([
              this._open,
              this.path,
              this.flags,
              this.mode,
              undefined,
            ])
            this.flush()
          }
        }
      }

      /***/
    },

    /***/ 263: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      var constants = __nccwpck_require__(2057)

      var origCwd = process.cwd
      var cwd = null

      var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform

      process.cwd = function () {
        if (!cwd) cwd = origCwd.call(process)
        return cwd
      }
      try {
        process.cwd()
      } catch (er) {}

      // This check is needed until node.js 12 is required
      if (typeof process.chdir === 'function') {
        var chdir = process.chdir
        process.chdir = function (d) {
          cwd = null
          chdir.call(process, d)
        }
        if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir)
      }

      module.exports = patch

      function patch(fs) {
        // (re-)implement some things that are known busted or missing.

        // lchmod, broken prior to 0.6.2
        // back-port the fix here.
        if (
          constants.hasOwnProperty('O_SYMLINK') &&
          process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)
        ) {
          patchLchmod(fs)
        }

        // lutimes implementation, or no-op
        if (!fs.lutimes) {
          patchLutimes(fs)
        }

        // https://github.com/isaacs/node-graceful-fs/issues/4
        // Chown should not fail on einval or eperm if non-root.
        // It should not fail on enosys ever, as this just indicates
        // that a fs doesn't support the intended operation.

        fs.chown = chownFix(fs.chown)
        fs.fchown = chownFix(fs.fchown)
        fs.lchown = chownFix(fs.lchown)

        fs.chmod = chmodFix(fs.chmod)
        fs.fchmod = chmodFix(fs.fchmod)
        fs.lchmod = chmodFix(fs.lchmod)

        fs.chownSync = chownFixSync(fs.chownSync)
        fs.fchownSync = chownFixSync(fs.fchownSync)
        fs.lchownSync = chownFixSync(fs.lchownSync)

        fs.chmodSync = chmodFixSync(fs.chmodSync)
        fs.fchmodSync = chmodFixSync(fs.fchmodSync)
        fs.lchmodSync = chmodFixSync(fs.lchmodSync)

        fs.stat = statFix(fs.stat)
        fs.fstat = statFix(fs.fstat)
        fs.lstat = statFix(fs.lstat)

        fs.statSync = statFixSync(fs.statSync)
        fs.fstatSync = statFixSync(fs.fstatSync)
        fs.lstatSync = statFixSync(fs.lstatSync)

        // if lchmod/lchown do not exist, then make them no-ops
        if (fs.chmod && !fs.lchmod) {
          fs.lchmod = function (path, mode, cb) {
            if (cb) process.nextTick(cb)
          }
          fs.lchmodSync = function () {}
        }
        if (fs.chown && !fs.lchown) {
          fs.lchown = function (path, uid, gid, cb) {
            if (cb) process.nextTick(cb)
          }
          fs.lchownSync = function () {}
        }

        // on Windows, A/V software can lock the directory, causing this
        // to fail with an EACCES or EPERM if the directory contains newly
        // created files.  Try again on failure, for up to 60 seconds.

        // Set the timeout this long because some Windows Anti-Virus, such as Parity
        // bit9, may lock files for up to a minute, causing npm package install
        // failures. Also, take care to yield the scheduler. Windows scheduling gives
        // CPU to a busy looping process, which can cause the program causing the lock
        // contention to be starved of CPU by node, so the contention doesn't resolve.
        if (platform === 'win32') {
          fs.rename =
            typeof fs.rename !== 'function'
              ? fs.rename
              : (function (fs$rename) {
                  function rename(from, to, cb) {
                    var start = Date.now()
                    var backoff = 0
                    fs$rename(from, to, function CB(er) {
                      if (
                        er &&
                        (er.code === 'EACCES' || er.code === 'EPERM') &&
                        Date.now() - start < 60000
                      ) {
                        setTimeout(function () {
                          fs.stat(to, function (stater, st) {
                            if (stater && stater.code === 'ENOENT')
                              fs$rename(from, to, CB)
                            else cb(er)
                          })
                        }, backoff)
                        if (backoff < 100) backoff += 10
                        return
                      }
                      if (cb) cb(er)
                    })
                  }
                  if (Object.setPrototypeOf)
                    Object.setPrototypeOf(rename, fs$rename)
                  return rename
                })(fs.rename)
        }

        // if read() returns EAGAIN, then just try it again.
        fs.read =
          typeof fs.read !== 'function'
            ? fs.read
            : (function (fs$read) {
                function read(fd, buffer, offset, length, position, callback_) {
                  var callback
                  if (callback_ && typeof callback_ === 'function') {
                    var eagCounter = 0
                    callback = function (er, _, __) {
                      if (er && er.code === 'EAGAIN' && eagCounter < 10) {
                        eagCounter++
                        return fs$read.call(
                          fs,
                          fd,
                          buffer,
                          offset,
                          length,
                          position,
                          callback
                        )
                      }
                      callback_.apply(this, arguments)
                    }
                  }
                  return fs$read.call(
                    fs,
                    fd,
                    buffer,
                    offset,
                    length,
                    position,
                    callback
                  )
                }

                // This ensures `util.promisify` works as it does for native `fs.read`.
                if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read)
                return read
              })(fs.read)

        fs.readSync =
          typeof fs.readSync !== 'function'
            ? fs.readSync
            : (function (fs$readSync) {
                return function (fd, buffer, offset, length, position) {
                  var eagCounter = 0
                  while (true) {
                    try {
                      return fs$readSync.call(
                        fs,
                        fd,
                        buffer,
                        offset,
                        length,
                        position
                      )
                    } catch (er) {
                      if (er.code === 'EAGAIN' && eagCounter < 10) {
                        eagCounter++
                        continue
                      }
                      throw er
                    }
                  }
                }
              })(fs.readSync)

        function patchLchmod(fs) {
          fs.lchmod = function (path, mode, callback) {
            fs.open(
              path,
              constants.O_WRONLY | constants.O_SYMLINK,
              mode,
              function (err, fd) {
                if (err) {
                  if (callback) callback(err)
                  return
                }
                // prefer to return the chmod error, if one occurs,
                // but still try to close, and report closing errors if they occur.
                fs.fchmod(fd, mode, function (err) {
                  fs.close(fd, function (err2) {
                    if (callback) callback(err || err2)
                  })
                })
              }
            )
          }

          fs.lchmodSync = function (path, mode) {
            var fd = fs.openSync(
              path,
              constants.O_WRONLY | constants.O_SYMLINK,
              mode
            )

            // prefer to return the chmod error, if one occurs,
            // but still try to close, and report closing errors if they occur.
            var threw = true
            var ret
            try {
              ret = fs.fchmodSync(fd, mode)
              threw = false
            } finally {
              if (threw) {
                try {
                  fs.closeSync(fd)
                } catch (er) {}
              } else {
                fs.closeSync(fd)
              }
            }
            return ret
          }
        }

        function patchLutimes(fs) {
          if (constants.hasOwnProperty('O_SYMLINK') && fs.futimes) {
            fs.lutimes = function (path, at, mt, cb) {
              fs.open(path, constants.O_SYMLINK, function (er, fd) {
                if (er) {
                  if (cb) cb(er)
                  return
                }
                fs.futimes(fd, at, mt, function (er) {
                  fs.close(fd, function (er2) {
                    if (cb) cb(er || er2)
                  })
                })
              })
            }

            fs.lutimesSync = function (path, at, mt) {
              var fd = fs.openSync(path, constants.O_SYMLINK)
              var ret
              var threw = true
              try {
                ret = fs.futimesSync(fd, at, mt)
                threw = false
              } finally {
                if (threw) {
                  try {
                    fs.closeSync(fd)
                  } catch (er) {}
                } else {
                  fs.closeSync(fd)
                }
              }
              return ret
            }
          } else if (fs.futimes) {
            fs.lutimes = function (_a, _b, _c, cb) {
              if (cb) process.nextTick(cb)
            }
            fs.lutimesSync = function () {}
          }
        }

        function chmodFix(orig) {
          if (!orig) return orig
          return function (target, mode, cb) {
            return orig.call(fs, target, mode, function (er) {
              if (chownErOk(er)) er = null
              if (cb) cb.apply(this, arguments)
            })
          }
        }

        function chmodFixSync(orig) {
          if (!orig) return orig
          return function (target, mode) {
            try {
              return orig.call(fs, target, mode)
            } catch (er) {
              if (!chownErOk(er)) throw er
            }
          }
        }

        function chownFix(orig) {
          if (!orig) return orig
          return function (target, uid, gid, cb) {
            return orig.call(fs, target, uid, gid, function (er) {
              if (chownErOk(er)) er = null
              if (cb) cb.apply(this, arguments)
            })
          }
        }

        function chownFixSync(orig) {
          if (!orig) return orig
          return function (target, uid, gid) {
            try {
              return orig.call(fs, target, uid, gid)
            } catch (er) {
              if (!chownErOk(er)) throw er
            }
          }
        }

        function statFix(orig) {
          if (!orig) return orig
          // Older versions of Node erroneously returned signed integers for
          // uid + gid.
          return function (target, options, cb) {
            if (typeof options === 'function') {
              cb = options
              options = null
            }
            function callback(er, stats) {
              if (stats) {
                if (stats.uid < 0) stats.uid += 0x100000000
                if (stats.gid < 0) stats.gid += 0x100000000
              }
              if (cb) cb.apply(this, arguments)
            }
            return options
              ? orig.call(fs, target, options, callback)
              : orig.call(fs, target, callback)
          }
        }

        function statFixSync(orig) {
          if (!orig) return orig
          // Older versions of Node erroneously returned signed integers for
          // uid + gid.
          return function (target, options) {
            var stats = options
              ? orig.call(fs, target, options)
              : orig.call(fs, target)
            if (stats) {
              if (stats.uid < 0) stats.uid += 0x100000000
              if (stats.gid < 0) stats.gid += 0x100000000
            }
            return stats
          }
        }

        // ENOSYS means that the fs doesn't support the op. Just ignore
        // that, because it doesn't matter.
        //
        // if there's no getuid, or if getuid() is something other
        // than 0, and the error is EINVAL or EPERM, then just ignore
        // it.
        //
        // This specific case is a silent failure in cp, install, tar,
        // and most other unix tools that manage permissions.
        //
        // When running as root, or if other types of errors are
        // encountered, then it's strict.
        function chownErOk(er) {
          if (!er) return true

          if (er.code === 'ENOSYS') return true

          var nonroot = !process.getuid || process.getuid() !== 0
          if (nonroot) {
            if (er.code === 'EINVAL' || er.code === 'EPERM') return true
          }

          return false
        }
      }

      /***/
    },

    /***/ 4777: /***/ module => {
      // A simple implementation of make-array
      function makeArray(subject) {
        return Array.isArray(subject) ? subject : [subject]
      }

      const EMPTY = ''
      const SPACE = ' '
      const ESCAPE = '\\'
      const REGEX_TEST_BLANK_LINE = /^\s+$/
      const REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/
      const REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/
      const REGEX_SPLITALL_CRLF = /\r?\n/g
      // /foo,
      // ./foo,
      // ../foo,
      // .
      // ..
      const REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/

      const SLASH = '/'
      const KEY_IGNORE =
        typeof Symbol !== 'undefined'
          ? Symbol.for('node-ignore')
          : /* istanbul ignore next */
            'node-ignore'

      const define = (object, key, value) =>
        Object.defineProperty(object, key, { value })

      const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g

      const RETURN_FALSE = () => false

      // Sanitize the range of a regular expression
      // The cases are complicated, see test cases for details
      const sanitizeRange = range =>
        range.replace(REGEX_REGEXP_RANGE, (match, from, to) =>
          from.charCodeAt(0) <= to.charCodeAt(0)
            ? match
            : // Invalid range (out of order) which is ok for gitignore rules but
              //   fatal for JavaScript regular expression, so eliminate it.
              EMPTY
        )

      // See fixtures #59
      const cleanRangeBackSlash = slashes => {
        const { length } = slashes
        return slashes.slice(0, length - (length % 2))
      }

      // > If the pattern ends with a slash,
      // > it is removed for the purpose of the following description,
      // > but it would only find a match with a directory.
      // > In other words, foo/ will match a directory foo and paths underneath it,
      // > but will not match a regular file or a symbolic link foo
      // >  (this is consistent with the way how pathspec works in general in Git).
      // '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
      // -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
      //      you could use option `mark: true` with `glob`

      // '`foo/`' should not continue with the '`..`'
      const REPLACERS = [
        // > Trailing spaces are ignored unless they are quoted with backslash ("\")
        [
          // (a\ ) -> (a )
          // (a  ) -> (a)
          // (a \ ) -> (a  )
          /\\?\s+$/,
          match => (match.indexOf('\\') === 0 ? SPACE : EMPTY),
        ],

        // replace (\ ) with ' '
        [/\\\s/g, () => SPACE],

        // Escape metacharacters
        // which is written down by users but means special for regular expressions.

        // > There are 12 characters with special meanings:
        // > - the backslash \,
        // > - the caret ^,
        // > - the dollar sign $,
        // > - the period or dot .,
        // > - the vertical bar or pipe symbol |,
        // > - the question mark ?,
        // > - the asterisk or star *,
        // > - the plus sign +,
        // > - the opening parenthesis (,
        // > - the closing parenthesis ),
        // > - and the opening square bracket [,
        // > - the opening curly brace {,
        // > These special characters are often called "metacharacters".
        [/[\\$.|*+(){^]/g, match => `\\${match}`],

        [
          // > a question mark (?) matches a single character
          /(?!\\)\?/g,
          () => '[^/]',
        ],

        // leading slash
        [
          // > A leading slash matches the beginning of the pathname.
          // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
          // A leading slash matches the beginning of the pathname
          /^\//,
          () => '^',
        ],

        // replace special metacharacter slash after the leading slash
        [/\//g, () => '\\/'],

        [
          // > A leading "**" followed by a slash means match in all directories.
          // > For example, "**/foo" matches file or directory "foo" anywhere,
          // > the same as pattern "foo".
          // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
          // >   under directory "foo".
          // Notice that the '*'s have been replaced as '\\*'
          /^\^*\\\*\\\*\\\//,

          // '**/foo' <-> 'foo'
          () => '^(?:.*\\/)?',
        ],

        // starting
        [
          // there will be no leading '/'
          //   (which has been replaced by section "leading slash")
          // If starts with '**', adding a '^' to the regular expression also works
          /^(?=[^^])/,
          function startingReplacer() {
            // If has a slash `/` at the beginning or middle
            return !/\/(?!$)/.test(this)
              ? // > Prior to 2.22.1
                // > If the pattern does not contain a slash /,
                // >   Git treats it as a shell glob pattern
                // Actually, if there is only a trailing slash,
                //   git also treats it as a shell glob pattern

                // After 2.22.1 (compatible but clearer)
                // > If there is a separator at the beginning or middle (or both)
                // > of the pattern, then the pattern is relative to the directory
                // > level of the particular .gitignore file itself.
                // > Otherwise the pattern may also match at any level below
                // > the .gitignore level.
                '(?:^|\\/)'
              : // > Otherwise, Git treats the pattern as a shell glob suitable for
                // >   consumption by fnmatch(3)
                '^'
          },
        ],

        // two globstars
        [
          // Use lookahead assertions so that we could match more than one `'/**'`
          /\\\/\\\*\\\*(?=\\\/|$)/g,

          // Zero, one or several directories
          // should not use '*', or it will be replaced by the next replacer

          // Check if it is not the last `'/**'`
          (_, index, str) =>
            index + 6 < str.length
              ? // case: /**/
                // > A slash followed by two consecutive asterisks then a slash matches
                // >   zero or more directories.
                // > For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
                // '/**/'
                '(?:\\/[^\\/]+)*'
              : // case: /**
                // > A trailing `"/**"` matches everything inside.

                // #21: everything inside but it should not include the current folder
                '\\/.+',
        ],

        // intermediate wildcards
        [
          // Never replace escaped '*'
          // ignore rule '\*' will match the path '*'

          // 'abc.*/' -> go
          // 'abc.*'  -> skip this rule
          /(^|[^\\]+)\\\*(?=.+)/g,

          // '*.js' matches '.js'
          // '*.js' doesn't match 'abc'
          (_, p1) => `${p1}[^\\/]*`,
        ],

        [
          // unescape, revert step 3 except for back slash
          // For example, if a user escape a '\\*',
          // after step 3, the result will be '\\\\\\*'
          /\\\\\\(?=[$.|*+(){^])/g,
          () => ESCAPE,
        ],

        [
          // '\\\\' -> '\\'
          /\\\\/g,
          () => ESCAPE,
        ],

        [
          // > The range notation, e.g. [a-zA-Z],
          // > can be used to match one of the characters in a range.

          // `\` is escaped by step 3
          /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
          (match, leadEscape, range, endEscape, close) =>
            leadEscape === ESCAPE
              ? // '\\[bar]' -> '\\\\[bar\\]'
                `\\[${range}${cleanRangeBackSlash(endEscape)}${close}`
              : close === ']'
              ? endEscape.length % 2 === 0
                ? // A normal case, and it is a range notation
                  // '[bar]'
                  // '[bar\\\\]'
                  `[${sanitizeRange(range)}${endEscape}]`
                : // Invalid range notaton
                  // '[bar\\]' -> '[bar\\\\]'
                  '[]'
              : '[]',
        ],

        // ending
        [
          // 'js' will not match 'js.'
          // 'ab' will not match 'abc'
          /(?:[^*])$/,

          // WTF!
          // https://git-scm.com/docs/gitignore
          // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
          // which re-fixes #24, #38

          // > If there is a separator at the end of the pattern then the pattern
          // > will only match directories, otherwise the pattern can match both
          // > files and directories.

          // 'js*' will not match 'a.js'
          // 'js/' will not match 'a.js'
          // 'js' will match 'a.js' and 'a.js/'
          match =>
            /\/$/.test(match)
              ? // foo/ will not match 'foo'
                `${match}$`
              : // foo matches 'foo' and 'foo/'
                `${match}(?=$|\\/$)`,
        ],

        // trailing wildcard
        [
          /(\^|\\\/)?\\\*$/,
          (_, p1) => {
            const prefix = p1
              ? // '\^':
                // '/*' does not match EMPTY
                // '/*' does not match everything

                // '\\\/':
                // 'abc/*' does not match 'abc/'
                `${p1}[^/]+`
              : // 'a*' matches 'a'
                // 'a*' matches 'aa'
                '[^/]*'

            return `${prefix}(?=$|\\/$)`
          },
        ],
      ]

      // A simple cache, because an ignore rule only has only one certain meaning
      const regexCache = Object.create(null)

      // @param {pattern}
      const makeRegex = (pattern, ignoreCase) => {
        let source = regexCache[pattern]

        if (!source) {
          source = REPLACERS.reduce(
            (prev, current) =>
              prev.replace(current[0], current[1].bind(pattern)),
            pattern
          )
          regexCache[pattern] = source
        }

        return ignoreCase ? new RegExp(source, 'i') : new RegExp(source)
      }

      const isString = subject => typeof subject === 'string'

      // > A blank line matches no files, so it can serve as a separator for readability.
      const checkPattern = pattern =>
        pattern &&
        isString(pattern) &&
        !REGEX_TEST_BLANK_LINE.test(pattern) &&
        // > A line starting with # serves as a comment.
        pattern.indexOf('#') !== 0

      const splitPattern = pattern => pattern.split(REGEX_SPLITALL_CRLF)

      class IgnoreRule {
        constructor(origin, pattern, negative, regex) {
          this.origin = origin
          this.pattern = pattern
          this.negative = negative
          this.regex = regex
        }
      }

      const createRule = (pattern, ignoreCase) => {
        const origin = pattern
        let negative = false

        // > An optional prefix "!" which negates the pattern;
        if (pattern.indexOf('!') === 0) {
          negative = true
          pattern = pattern.substr(1)
        }

        pattern = pattern
          // > Put a backslash ("\") in front of the first "!" for patterns that
          // >   begin with a literal "!", for example, `"\!important!.txt"`.
          .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')
          // > Put a backslash ("\") in front of the first hash for patterns that
          // >   begin with a hash.
          .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#')

        const regex = makeRegex(pattern, ignoreCase)

        return new IgnoreRule(origin, pattern, negative, regex)
      }

      const throwError = (message, Ctor) => {
        throw new Ctor(message)
      }

      const checkPath = (path, originalPath, doThrow) => {
        if (!isString(path)) {
          return doThrow(
            `path must be a string, but got \`${originalPath}\``,
            TypeError
          )
        }

        // We don't know if we should ignore EMPTY, so throw
        if (!path) {
          return doThrow(`path must not be empty`, TypeError)
        }

        // Check if it is a relative path
        if (checkPath.isNotRelative(path)) {
          const r = '`path.relative()`d'
          return doThrow(
            `path should be a ${r} string, but got "${originalPath}"`,
            RangeError
          )
        }

        return true
      }

      const isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path)

      checkPath.isNotRelative = isNotRelative
      checkPath.convert = p => p

      class Ignore {
        constructor({
          ignorecase = true,
          ignoreCase = ignorecase,
          allowRelativePaths = false,
        } = {}) {
          define(this, KEY_IGNORE, true)

          this._rules = []
          this._ignoreCase = ignoreCase
          this._allowRelativePaths = allowRelativePaths
          this._initCache()
        }

        _initCache() {
          this._ignoreCache = Object.create(null)
          this._testCache = Object.create(null)
        }

        _addPattern(pattern) {
          // #32
          if (pattern && pattern[KEY_IGNORE]) {
            this._rules = this._rules.concat(pattern._rules)
            this._added = true
            return
          }

          if (checkPattern(pattern)) {
            const rule = createRule(pattern, this._ignoreCase)
            this._added = true
            this._rules.push(rule)
          }
        }

        // @param {Array<string> | string | Ignore} pattern
        add(pattern) {
          this._added = false

          makeArray(
            isString(pattern) ? splitPattern(pattern) : pattern
          ).forEach(this._addPattern, this)

          // Some rules have just added to the ignore,
          // making the behavior changed.
          if (this._added) {
            this._initCache()
          }

          return this
        }

        // legacy
        addPattern(pattern) {
          return this.add(pattern)
        }

        //          |           ignored : unignored
        // negative |   0:0   |   0:1   |   1:0   |   1:1
        // -------- | ------- | ------- | ------- | --------
        //     0    |  TEST   |  TEST   |  SKIP   |    X
        //     1    |  TESTIF |  SKIP   |  TEST   |    X

        // - SKIP: always skip
        // - TEST: always test
        // - TESTIF: only test if checkUnignored
        // - X: that never happen

        // @param {boolean} whether should check if the path is unignored,
        //   setting `checkUnignored` to `false` could reduce additional
        //   path matching.

        // @returns {TestResult} true if a file is ignored
        _testOne(path, checkUnignored) {
          let ignored = false
          let unignored = false

          this._rules.forEach(rule => {
            const { negative } = rule
            if (
              (unignored === negative && ignored !== unignored) ||
              (negative && !ignored && !unignored && !checkUnignored)
            ) {
              return
            }

            const matched = rule.regex.test(path)

            if (matched) {
              ignored = !negative
              unignored = negative
            }
          })

          return {
            ignored,
            unignored,
          }
        }

        // @returns {TestResult}
        _test(originalPath, cache, checkUnignored, slices) {
          const path =
            originalPath &&
            // Supports nullable path
            checkPath.convert(originalPath)

          checkPath(
            path,
            originalPath,
            this._allowRelativePaths ? RETURN_FALSE : throwError
          )

          return this._t(path, cache, checkUnignored, slices)
        }

        _t(path, cache, checkUnignored, slices) {
          if (path in cache) {
            return cache[path]
          }

          if (!slices) {
            // path/to/a.js
            // ['path', 'to', 'a.js']
            slices = path.split(SLASH)
          }

          slices.pop()

          // If the path has no parent directory, just test it
          if (!slices.length) {
            return (cache[path] = this._testOne(path, checkUnignored))
          }

          const parent = this._t(
            slices.join(SLASH) + SLASH,
            cache,
            checkUnignored,
            slices
          )

          // If the path contains a parent directory, check the parent first
          return (cache[path] = parent.ignored
            ? // > It is not possible to re-include a file if a parent directory of
              // >   that file is excluded.
              parent
            : this._testOne(path, checkUnignored))
        }

        ignores(path) {
          return this._test(path, this._ignoreCache, false).ignored
        }

        createFilter() {
          return path => !this.ignores(path)
        }

        filter(paths) {
          return makeArray(paths).filter(this.createFilter())
        }

        // @returns {TestResult}
        test(path) {
          return this._test(path, this._testCache, true)
        }
      }

      const factory = options => new Ignore(options)

      const isPathValid = path =>
        checkPath(path && checkPath.convert(path), path, RETURN_FALSE)

      factory.isPathValid = isPathValid

      // Fixes typescript
      factory.default = factory

      module.exports = factory

      // Windows
      // --------------------------------------------------------------
      /* istanbul ignore if  */
      if (
        // Detect `process` so that it can run in browsers.
        typeof process !== 'undefined' &&
        ((process.env && process.env.IGNORE_TEST_WIN32) ||
          process.platform === 'win32')
      ) {
        /* eslint no-control-regex: "off" */
        const makePosix = str =>
          /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str)
            ? str
            : str.replace(/\\/g, '/')

        checkPath.convert = makePosix

        // 'C:\\foo'     <- 'C:\\foo' has been converted to 'C:/'
        // 'd:\\foo'
        const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i
        checkPath.isNotRelative = path =>
          REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path)
      }

      /***/
    },

    /***/ 6435: /***/ module => {
      /*!
       * is-extglob <https://github.com/jonschlinkert/is-extglob>
       *
       * Copyright (c) 2014-2016, Jon Schlinkert.
       * Licensed under the MIT License.
       */

      module.exports = function isExtglob(str) {
        if (typeof str !== 'string' || str === '') {
          return false
        }

        var match
        while ((match = /(\\).|([@?!+*]\(.*\))/g.exec(str))) {
          if (match[2]) return true
          str = str.slice(match.index + match[0].length)
        }

        return false
      }

      /***/
    },

    /***/ 4466: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      /*!
       * is-glob <https://github.com/jonschlinkert/is-glob>
       *
       * Copyright (c) 2014-2017, Jon Schlinkert.
       * Released under the MIT License.
       */

      var isExtglob = __nccwpck_require__(6435)
      var chars = { '{': '}', '(': ')', '[': ']' }
      var strictCheck = function (str) {
        if (str[0] === '!') {
          return true
        }
        var index = 0
        var pipeIndex = -2
        var closeSquareIndex = -2
        var closeCurlyIndex = -2
        var closeParenIndex = -2
        var backSlashIndex = -2
        while (index < str.length) {
          if (str[index] === '*') {
            return true
          }

          if (str[index + 1] === '?' && /[\].+)]/.test(str[index])) {
            return true
          }

          if (
            closeSquareIndex !== -1 &&
            str[index] === '[' &&
            str[index + 1] !== ']'
          ) {
            if (closeSquareIndex < index) {
              closeSquareIndex = str.indexOf(']', index)
            }
            if (closeSquareIndex > index) {
              if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
                return true
              }
              backSlashIndex = str.indexOf('\\', index)
              if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
                return true
              }
            }
          }

          if (
            closeCurlyIndex !== -1 &&
            str[index] === '{' &&
            str[index + 1] !== '}'
          ) {
            closeCurlyIndex = str.indexOf('}', index)
            if (closeCurlyIndex > index) {
              backSlashIndex = str.indexOf('\\', index)
              if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
                return true
              }
            }
          }

          if (
            closeParenIndex !== -1 &&
            str[index] === '(' &&
            str[index + 1] === '?' &&
            /[:!=]/.test(str[index + 2]) &&
            str[index + 3] !== ')'
          ) {
            closeParenIndex = str.indexOf(')', index)
            if (closeParenIndex > index) {
              backSlashIndex = str.indexOf('\\', index)
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true
              }
            }
          }

          if (
            pipeIndex !== -1 &&
            str[index] === '(' &&
            str[index + 1] !== '|'
          ) {
            if (pipeIndex < index) {
              pipeIndex = str.indexOf('|', index)
            }
            if (pipeIndex !== -1 && str[pipeIndex + 1] !== ')') {
              closeParenIndex = str.indexOf(')', pipeIndex)
              if (closeParenIndex > pipeIndex) {
                backSlashIndex = str.indexOf('\\', pipeIndex)
                if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                  return true
                }
              }
            }
          }

          if (str[index] === '\\') {
            var open = str[index + 1]
            index += 2
            var close = chars[open]

            if (close) {
              var n = str.indexOf(close, index)
              if (n !== -1) {
                index = n + 1
              }
            }

            if (str[index] === '!') {
              return true
            }
          } else {
            index++
          }
        }
        return false
      }

      var relaxedCheck = function (str) {
        if (str[0] === '!') {
          return true
        }
        var index = 0
        while (index < str.length) {
          if (/[*?{}()[\]]/.test(str[index])) {
            return true
          }

          if (str[index] === '\\') {
            var open = str[index + 1]
            index += 2
            var close = chars[open]

            if (close) {
              var n = str.indexOf(close, index)
              if (n !== -1) {
                index = n + 1
              }
            }

            if (str[index] === '!') {
              return true
            }
          } else {
            index++
          }
        }
        return false
      }

      module.exports = function isGlob(str, options) {
        if (typeof str !== 'string' || str === '') {
          return false
        }

        if (isExtglob(str)) {
          return true
        }

        var check = strictCheck

        // optionally relax check
        if (options && options.strict === false) {
          check = relaxedCheck
        }

        return check(str)
      }

      /***/
    },

    /***/ 5680: /***/ module => {
      'use strict'
      /*!
       * is-number <https://github.com/jonschlinkert/is-number>
       *
       * Copyright (c) 2014-present, Jon Schlinkert.
       * Released under the MIT License.
       */

      module.exports = function (num) {
        if (typeof num === 'number') {
          return num - num === 0
        }
        if (typeof num === 'string' && num.trim() !== '') {
          return Number.isFinite ? Number.isFinite(+num) : isFinite(+num)
        }
        return false
      }

      /***/
    },

    /***/ 8760: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const betterPathResolve = __nccwpck_require__(7053)
      const path = __nccwpck_require__(1017)

      function isSubdir(parentDir, subdir) {
        const rParent = `${betterPathResolve(parentDir)}${path.sep}`
        const rDir = `${betterPathResolve(subdir)}${path.sep}`
        return rDir.startsWith(rParent)
      }

      isSubdir.strict = function isSubdirStrict(parentDir, subdir) {
        const rParent = `${betterPathResolve(parentDir)}${path.sep}`
        const rDir = `${betterPathResolve(subdir)}${path.sep}`
        return rDir !== rParent && rDir.startsWith(rParent)
      }

      module.exports = isSubdir

      /***/
    },

    /***/ 9125: /***/ (module, exports) => {
      /*!
       * is-windows <https://github.com/jonschlinkert/is-windows>
       *
       * Copyright © 2015-2018, Jon Schlinkert.
       * Released under the MIT License.
       */

      ;(function (factory) {
        if (
          exports &&
          typeof exports === 'object' &&
          'object' !== 'undefined'
        ) {
          module.exports = factory()
        } else if (typeof define === 'function' && define.amd) {
          define([], factory)
        } else if (typeof window !== 'undefined') {
          window.isWindows = factory()
        } else if (typeof global !== 'undefined') {
          global.isWindows = factory()
        } else if (typeof self !== 'undefined') {
          self.isWindows = factory()
        } else {
          this.isWindows = factory()
        }
      })(function () {
        'use strict'
        return function isWindows() {
          return (
            process &&
            (process.platform === 'win32' ||
              /^(msys|cygwin)$/.test(process.env.OSTYPE))
          )
        }
      })

      /***/
    },

    /***/ 7126: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      var fs = __nccwpck_require__(7147)
      var core
      if (process.platform === 'win32' || global.TESTING_WINDOWS) {
        core = __nccwpck_require__(2001)
      } else {
        core = __nccwpck_require__(9728)
      }

      module.exports = isexe
      isexe.sync = sync

      function isexe(path, options, cb) {
        if (typeof options === 'function') {
          cb = options
          options = {}
        }

        if (!cb) {
          if (typeof Promise !== 'function') {
            throw new TypeError('callback not provided')
          }

          return new Promise(function (resolve, reject) {
            isexe(path, options || {}, function (er, is) {
              if (er) {
                reject(er)
              } else {
                resolve(is)
              }
            })
          })
        }

        core(path, options || {}, function (er, is) {
          // ignore EACCES because that just means we aren't allowed to run it
          if (er) {
            if (er.code === 'EACCES' || (options && options.ignoreErrors)) {
              er = null
              is = false
            }
          }
          cb(er, is)
        })
      }

      function sync(path, options) {
        // my kingdom for a filtered catch
        try {
          return core.sync(path, options || {})
        } catch (er) {
          if ((options && options.ignoreErrors) || er.code === 'EACCES') {
            return false
          } else {
            throw er
          }
        }
      }

      /***/
    },

    /***/ 9728: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      module.exports = isexe
      isexe.sync = sync

      var fs = __nccwpck_require__(7147)

      function isexe(path, options, cb) {
        fs.stat(path, function (er, stat) {
          cb(er, er ? false : checkStat(stat, options))
        })
      }

      function sync(path, options) {
        return checkStat(fs.statSync(path), options)
      }

      function checkStat(stat, options) {
        return stat.isFile() && checkMode(stat, options)
      }

      function checkMode(stat, options) {
        var mod = stat.mode
        var uid = stat.uid
        var gid = stat.gid

        var myUid =
          options.uid !== undefined
            ? options.uid
            : process.getuid && process.getuid()
        var myGid =
          options.gid !== undefined
            ? options.gid
            : process.getgid && process.getgid()

        var u = parseInt('100', 8)
        var g = parseInt('010', 8)
        var o = parseInt('001', 8)
        var ug = u | g

        var ret =
          mod & o ||
          (mod & g && gid === myGid) ||
          (mod & u && uid === myUid) ||
          (mod & ug && myUid === 0)

        return ret
      }

      /***/
    },

    /***/ 2001: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      module.exports = isexe
      isexe.sync = sync

      var fs = __nccwpck_require__(7147)

      function checkPathExt(path, options) {
        var pathext =
          options.pathExt !== undefined ? options.pathExt : process.env.PATHEXT

        if (!pathext) {
          return true
        }

        pathext = pathext.split(';')
        if (pathext.indexOf('') !== -1) {
          return true
        }
        for (var i = 0; i < pathext.length; i++) {
          var p = pathext[i].toLowerCase()
          if (p && path.substr(-p.length).toLowerCase() === p) {
            return true
          }
        }
        return false
      }

      function checkStat(stat, path, options) {
        if (!stat.isSymbolicLink() && !stat.isFile()) {
          return false
        }
        return checkPathExt(path, options)
      }

      function isexe(path, options, cb) {
        fs.stat(path, function (er, stat) {
          cb(er, er ? false : checkStat(stat, path, options))
        })
      }

      function sync(path, options) {
        return checkStat(fs.statSync(path), path, options)
      }

      /***/
    },

    /***/ 6160: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      var _fs
      try {
        _fs = __nccwpck_require__(7758)
      } catch (_) {
        _fs = __nccwpck_require__(7147)
      }

      function readFile(file, options, callback) {
        if (callback == null) {
          callback = options
          options = {}
        }

        if (typeof options === 'string') {
          options = { encoding: options }
        }

        options = options || {}
        var fs = options.fs || _fs

        var shouldThrow = true
        if ('throws' in options) {
          shouldThrow = options.throws
        }

        fs.readFile(file, options, function (err, data) {
          if (err) return callback(err)

          data = stripBom(data)

          var obj
          try {
            obj = JSON.parse(data, options ? options.reviver : null)
          } catch (err2) {
            if (shouldThrow) {
              err2.message = file + ': ' + err2.message
              return callback(err2)
            } else {
              return callback(null, null)
            }
          }

          callback(null, obj)
        })
      }

      function readFileSync(file, options) {
        options = options || {}
        if (typeof options === 'string') {
          options = { encoding: options }
        }

        var fs = options.fs || _fs

        var shouldThrow = true
        if ('throws' in options) {
          shouldThrow = options.throws
        }

        try {
          var content = fs.readFileSync(file, options)
          content = stripBom(content)
          return JSON.parse(content, options.reviver)
        } catch (err) {
          if (shouldThrow) {
            err.message = file + ': ' + err.message
            throw err
          } else {
            return null
          }
        }
      }

      function stringify(obj, options) {
        var spaces
        var EOL = '\n'
        if (typeof options === 'object' && options !== null) {
          if (options.spaces) {
            spaces = options.spaces
          }
          if (options.EOL) {
            EOL = options.EOL
          }
        }

        var str = JSON.stringify(obj, options ? options.replacer : null, spaces)

        return str.replace(/\n/g, EOL) + EOL
      }

      function writeFile(file, obj, options, callback) {
        if (callback == null) {
          callback = options
          options = {}
        }
        options = options || {}
        var fs = options.fs || _fs

        var str = ''
        try {
          str = stringify(obj, options)
        } catch (err) {
          // Need to return whether a callback was passed or not
          if (callback) callback(err, null)
          return
        }

        fs.writeFile(file, str, options, callback)
      }

      function writeFileSync(file, obj, options) {
        options = options || {}
        var fs = options.fs || _fs

        var str = stringify(obj, options)
        // not sure if fs.writeFileSync returns anything, but just in case
        return fs.writeFileSync(file, str, options)
      }

      function stripBom(content) {
        // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
        if (Buffer.isBuffer(content)) content = content.toString('utf8')
        content = content.replace(/^\uFEFF/, '')
        return content
      }

      var jsonfile = {
        readFile: readFile,
        readFileSync: readFileSync,
        writeFile: writeFile,
        writeFileSync: writeFileSync,
      }

      module.exports = jsonfile

      /***/
    },

    /***/ 3447: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const path = __nccwpck_require__(1017)
      const fs = __nccwpck_require__(7147)
      const { promisify } = __nccwpck_require__(3837)
      const pLocate = __nccwpck_require__(104)

      const fsStat = promisify(fs.stat)
      const fsLStat = promisify(fs.lstat)

      const typeMappings = {
        directory: 'isDirectory',
        file: 'isFile',
      }

      function checkType({ type }) {
        if (type in typeMappings) {
          return
        }

        throw new Error(`Invalid type specified: ${type}`)
      }

      const matchType = (type, stat) =>
        type === undefined || stat[typeMappings[type]]()

      module.exports = async (paths, options) => {
        options = {
          cwd: process.cwd(),
          type: 'file',
          allowSymlinks: true,
          ...options,
        }
        checkType(options)
        const statFn = options.allowSymlinks ? fsStat : fsLStat

        return pLocate(
          paths,
          async path_ => {
            try {
              const stat = await statFn(path.resolve(options.cwd, path_))
              return matchType(options.type, stat)
            } catch (_) {
              return false
            }
          },
          options
        )
      }

      module.exports.sync = (paths, options) => {
        options = {
          cwd: process.cwd(),
          allowSymlinks: true,
          type: 'file',
          ...options,
        }
        checkType(options)
        const statFn = options.allowSymlinks ? fs.statSync : fs.lstatSync

        for (const path_ of paths) {
          try {
            const stat = statFn(path.resolve(options.cwd, path_))

            if (matchType(options.type, stat)) {
              return path_
            }
          } catch (_) {}
        }
      }

      /***/
    },

    /***/ 2578: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      /*
       * merge2
       * https://github.com/teambition/merge2
       *
       * Copyright (c) 2014-2020 Teambition
       * Licensed under the MIT license.
       */
      const Stream = __nccwpck_require__(2781)
      const PassThrough = Stream.PassThrough
      const slice = Array.prototype.slice

      module.exports = merge2

      function merge2() {
        const streamsQueue = []
        const args = slice.call(arguments)
        let merging = false
        let options = args[args.length - 1]

        if (options && !Array.isArray(options) && options.pipe == null) {
          args.pop()
        } else {
          options = {}
        }

        const doEnd = options.end !== false
        const doPipeError = options.pipeError === true
        if (options.objectMode == null) {
          options.objectMode = true
        }
        if (options.highWaterMark == null) {
          options.highWaterMark = 64 * 1024
        }
        const mergedStream = PassThrough(options)

        function addStream() {
          for (let i = 0, len = arguments.length; i < len; i++) {
            streamsQueue.push(pauseStreams(arguments[i], options))
          }
          mergeStream()
          return this
        }

        function mergeStream() {
          if (merging) {
            return
          }
          merging = true

          let streams = streamsQueue.shift()
          if (!streams) {
            process.nextTick(endStream)
            return
          }
          if (!Array.isArray(streams)) {
            streams = [streams]
          }

          let pipesCount = streams.length + 1

          function next() {
            if (--pipesCount > 0) {
              return
            }
            merging = false
            mergeStream()
          }

          function pipe(stream) {
            function onend() {
              stream.removeListener('merge2UnpipeEnd', onend)
              stream.removeListener('end', onend)
              if (doPipeError) {
                stream.removeListener('error', onerror)
              }
              next()
            }
            function onerror(err) {
              mergedStream.emit('error', err)
            }
            // skip ended stream
            if (stream._readableState.endEmitted) {
              return next()
            }

            stream.on('merge2UnpipeEnd', onend)
            stream.on('end', onend)

            if (doPipeError) {
              stream.on('error', onerror)
            }

            stream.pipe(mergedStream, { end: false })
            // compatible for old stream
            stream.resume()
          }

          for (let i = 0; i < streams.length; i++) {
            pipe(streams[i])
          }

          next()
        }

        function endStream() {
          merging = false
          // emit 'queueDrain' when all streams merged.
          mergedStream.emit('queueDrain')
          if (doEnd) {
            mergedStream.end()
          }
        }

        mergedStream.setMaxListeners(0)
        mergedStream.add = addStream
        mergedStream.on('unpipe', function (stream) {
          stream.emit('merge2UnpipeEnd')
        })

        if (args.length) {
          addStream.apply(null, args)
        }
        return mergedStream
      }

      // check and pause streams for pipe.
      function pauseStreams(streams, options) {
        if (!Array.isArray(streams)) {
          // Backwards-compat with old-style streams
          if (!streams._readableState && streams.pipe) {
            streams = streams.pipe(PassThrough(options))
          }
          if (!streams._readableState || !streams.pause || !streams.pipe) {
            throw new Error('Only readable stream can be merged.')
          }
          streams.pause()
        } else {
          for (let i = 0, len = streams.length; i < len; i++) {
            streams[i] = pauseStreams(streams[i], options)
          }
        }
        return streams
      }

      /***/
    },

    /***/ 6228: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const util = __nccwpck_require__(3837)
      const braces = __nccwpck_require__(610)
      const picomatch = __nccwpck_require__(8569)
      const utils = __nccwpck_require__(479)
      const isEmptyString = val => val === '' || val === './'

      /**
       * Returns an array of strings that match one or more glob patterns.
       *
       * ```js
       * const mm = require('micromatch');
       * // mm(list, patterns[, options]);
       *
       * console.log(mm(['a.js', 'a.txt'], ['*.js']));
       * //=> [ 'a.js' ]
       * ```
       * @param {String|Array<string>} `list` List of strings to match.
       * @param {String|Array<string>} `patterns` One or more glob patterns to use for matching.
       * @param {Object} `options` See available [options](#options)
       * @return {Array} Returns an array of matches
       * @summary false
       * @api public
       */

      const micromatch = (list, patterns, options) => {
        patterns = [].concat(patterns)
        list = [].concat(list)

        let omit = new Set()
        let keep = new Set()
        let items = new Set()
        let negatives = 0

        let onResult = state => {
          items.add(state.output)
          if (options && options.onResult) {
            options.onResult(state)
          }
        }

        for (let i = 0; i < patterns.length; i++) {
          let isMatch = picomatch(
            String(patterns[i]),
            { ...options, onResult },
            true
          )
          let negated = isMatch.state.negated || isMatch.state.negatedExtglob
          if (negated) negatives++

          for (let item of list) {
            let matched = isMatch(item, true)

            let match = negated ? !matched.isMatch : matched.isMatch
            if (!match) continue

            if (negated) {
              omit.add(matched.output)
            } else {
              omit.delete(matched.output)
              keep.add(matched.output)
            }
          }
        }

        let result = negatives === patterns.length ? [...items] : [...keep]
        let matches = result.filter(item => !omit.has(item))

        if (options && matches.length === 0) {
          if (options.failglob === true) {
            throw new Error(`No matches found for "${patterns.join(', ')}"`)
          }

          if (options.nonull === true || options.nullglob === true) {
            return options.unescape
              ? patterns.map(p => p.replace(/\\/g, ''))
              : patterns
          }
        }

        return matches
      }

      /**
       * Backwards compatibility
       */

      micromatch.match = micromatch

      /**
       * Returns a matcher function from the given glob `pattern` and `options`.
       * The returned function takes a string to match as its only argument and returns
       * true if the string is a match.
       *
       * ```js
       * const mm = require('micromatch');
       * // mm.matcher(pattern[, options]);
       *
       * const isMatch = mm.matcher('*.!(*a)');
       * console.log(isMatch('a.a')); //=> false
       * console.log(isMatch('a.b')); //=> true
       * ```
       * @param {String} `pattern` Glob pattern
       * @param {Object} `options`
       * @return {Function} Returns a matcher function.
       * @api public
       */

      micromatch.matcher = (pattern, options) => picomatch(pattern, options)

      /**
       * Returns true if **any** of the given glob `patterns` match the specified `string`.
       *
       * ```js
       * const mm = require('micromatch');
       * // mm.isMatch(string, patterns[, options]);
       *
       * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true
       * console.log(mm.isMatch('a.a', 'b.*')); //=> false
       * ```
       * @param {String} `str` The string to test.
       * @param {String|Array} `patterns` One or more glob patterns to use for matching.
       * @param {Object} `[options]` See available [options](#options).
       * @return {Boolean} Returns true if any patterns match `str`
       * @api public
       */

      micromatch.isMatch = (str, patterns, options) =>
        picomatch(patterns, options)(str)

      /**
       * Backwards compatibility
       */

      micromatch.any = micromatch.isMatch

      /**
       * Returns a list of strings that _**do not match any**_ of the given `patterns`.
       *
       * ```js
       * const mm = require('micromatch');
       * // mm.not(list, patterns[, options]);
       *
       * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
       * //=> ['b.b', 'c.c']
       * ```
       * @param {Array} `list` Array of strings to match.
       * @param {String|Array} `patterns` One or more glob pattern to use for matching.
       * @param {Object} `options` See available [options](#options) for changing how matches are performed
       * @return {Array} Returns an array of strings that **do not match** the given patterns.
       * @api public
       */

      micromatch.not = (list, patterns, options = {}) => {
        patterns = [].concat(patterns).map(String)
        let result = new Set()
        let items = []

        let onResult = state => {
          if (options.onResult) options.onResult(state)
          items.push(state.output)
        }

        let matches = new Set(
          micromatch(list, patterns, { ...options, onResult })
        )

        for (let item of items) {
          if (!matches.has(item)) {
            result.add(item)
          }
        }
        return [...result]
      }

      /**
       * Returns true if the given `string` contains the given pattern. Similar
       * to [.isMatch](#isMatch) but the pattern can match any part of the string.
       *
       * ```js
       * var mm = require('micromatch');
       * // mm.contains(string, pattern[, options]);
       *
       * console.log(mm.contains('aa/bb/cc', '*b'));
       * //=> true
       * console.log(mm.contains('aa/bb/cc', '*d'));
       * //=> false
       * ```
       * @param {String} `str` The string to match.
       * @param {String|Array} `patterns` Glob pattern to use for matching.
       * @param {Object} `options` See available [options](#options) for changing how matches are performed
       * @return {Boolean} Returns true if any of the patterns matches any part of `str`.
       * @api public
       */

      micromatch.contains = (str, pattern, options) => {
        if (typeof str !== 'string') {
          throw new TypeError(`Expected a string: "${util.inspect(str)}"`)
        }

        if (Array.isArray(pattern)) {
          return pattern.some(p => micromatch.contains(str, p, options))
        }

        if (typeof pattern === 'string') {
          if (isEmptyString(str) || isEmptyString(pattern)) {
            return false
          }

          if (
            str.includes(pattern) ||
            (str.startsWith('./') && str.slice(2).includes(pattern))
          ) {
            return true
          }
        }

        return micromatch.isMatch(str, pattern, { ...options, contains: true })
      }

      /**
       * Filter the keys of the given object with the given `glob` pattern
       * and `options`. Does not attempt to match nested keys. If you need this feature,
       * use [glob-object][] instead.
       *
       * ```js
       * const mm = require('micromatch');
       * // mm.matchKeys(object, patterns[, options]);
       *
       * const obj = { aa: 'a', ab: 'b', ac: 'c' };
       * console.log(mm.matchKeys(obj, '*b'));
       * //=> { ab: 'b' }
       * ```
       * @param {Object} `object` The object with keys to filter.
       * @param {String|Array} `patterns` One or more glob patterns to use for matching.
       * @param {Object} `options` See available [options](#options) for changing how matches are performed
       * @return {Object} Returns an object with only keys that match the given patterns.
       * @api public
       */

      micromatch.matchKeys = (obj, patterns, options) => {
        if (!utils.isObject(obj)) {
          throw new TypeError('Expected the first argument to be an object')
        }
        let keys = micromatch(Object.keys(obj), patterns, options)
        let res = {}
        for (let key of keys) res[key] = obj[key]
        return res
      }

      /**
       * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.
       *
       * ```js
       * const mm = require('micromatch');
       * // mm.some(list, patterns[, options]);
       *
       * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
       * // true
       * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
       * // false
       * ```
       * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
       * @param {String|Array} `patterns` One or more glob patterns to use for matching.
       * @param {Object} `options` See available [options](#options) for changing how matches are performed
       * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`
       * @api public
       */

      micromatch.some = (list, patterns, options) => {
        let items = [].concat(list)

        for (let pattern of [].concat(patterns)) {
          let isMatch = picomatch(String(pattern), options)
          if (items.some(item => isMatch(item))) {
            return true
          }
        }
        return false
      }

      /**
       * Returns true if every string in the given `list` matches
       * any of the given glob `patterns`.
       *
       * ```js
       * const mm = require('micromatch');
       * // mm.every(list, patterns[, options]);
       *
       * console.log(mm.every('foo.js', ['foo.js']));
       * // true
       * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
       * // true
       * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
       * // false
       * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
       * // false
       * ```
       * @param {String|Array} `list` The string or array of strings to test.
       * @param {String|Array} `patterns` One or more glob patterns to use for matching.
       * @param {Object} `options` See available [options](#options) for changing how matches are performed
       * @return {Boolean} Returns true if all `patterns` matches all of the strings in `list`
       * @api public
       */

      micromatch.every = (list, patterns, options) => {
        let items = [].concat(list)

        for (let pattern of [].concat(patterns)) {
          let isMatch = picomatch(String(pattern), options)
          if (!items.every(item => isMatch(item))) {
            return false
          }
        }
        return true
      }

      /**
       * Returns true if **all** of the given `patterns` match
       * the specified string.
       *
       * ```js
       * const mm = require('micromatch');
       * // mm.all(string, patterns[, options]);
       *
       * console.log(mm.all('foo.js', ['foo.js']));
       * // true
       *
       * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
       * // false
       *
       * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
       * // true
       *
       * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
       * // true
       * ```
       * @param {String|Array} `str` The string to test.
       * @param {String|Array} `patterns` One or more glob patterns to use for matching.
       * @param {Object} `options` See available [options](#options) for changing how matches are performed
       * @return {Boolean} Returns true if any patterns match `str`
       * @api public
       */

      micromatch.all = (str, patterns, options) => {
        if (typeof str !== 'string') {
          throw new TypeError(`Expected a string: "${util.inspect(str)}"`)
        }

        return [].concat(patterns).every(p => picomatch(p, options)(str))
      }

      /**
       * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
       *
       * ```js
       * const mm = require('micromatch');
       * // mm.capture(pattern, string[, options]);
       *
       * console.log(mm.capture('test/*.js', 'test/foo.js'));
       * //=> ['foo']
       * console.log(mm.capture('test/*.js', 'foo/bar.css'));
       * //=> null
       * ```
       * @param {String} `glob` Glob pattern to use for matching.
       * @param {String} `input` String to match
       * @param {Object} `options` See available [options](#options) for changing how matches are performed
       * @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`.
       * @api public
       */

      micromatch.capture = (glob, input, options) => {
        let posix = utils.isWindows(options)
        let regex = picomatch.makeRe(String(glob), {
          ...options,
          capture: true,
        })
        let match = regex.exec(posix ? utils.toPosixSlashes(input) : input)

        if (match) {
          return match.slice(1).map(v => (v === void 0 ? '' : v))
        }
      }

      /**
       * Create a regular expression from the given glob `pattern`.
       *
       * ```js
       * const mm = require('micromatch');
       * // mm.makeRe(pattern[, options]);
       *
       * console.log(mm.makeRe('*.js'));
       * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
       * ```
       * @param {String} `pattern` A glob pattern to convert to regex.
       * @param {Object} `options`
       * @return {RegExp} Returns a regex created from the given pattern.
       * @api public
       */

      micromatch.makeRe = (...args) => picomatch.makeRe(...args)

      /**
       * Scan a glob pattern to separate the pattern into segments. Used
       * by the [split](#split) method.
       *
       * ```js
       * const mm = require('micromatch');
       * const state = mm.scan(pattern[, options]);
       * ```
       * @param {String} `pattern`
       * @param {Object} `options`
       * @return {Object} Returns an object with
       * @api public
       */

      micromatch.scan = (...args) => picomatch.scan(...args)

      /**
       * Parse a glob pattern to create the source string for a regular
       * expression.
       *
       * ```js
       * const mm = require('micromatch');
       * const state = mm.parse(pattern[, options]);
       * ```
       * @param {String} `glob`
       * @param {Object} `options`
       * @return {Object} Returns an object with useful properties and output to be used as regex source string.
       * @api public
       */

      micromatch.parse = (patterns, options) => {
        let res = []
        for (let pattern of [].concat(patterns || [])) {
          for (let str of braces(String(pattern), options)) {
            res.push(picomatch.parse(str, options))
          }
        }
        return res
      }

      /**
       * Process the given brace `pattern`.
       *
       * ```js
       * const { braces } = require('micromatch');
       * console.log(braces('foo/{a,b,c}/bar'));
       * //=> [ 'foo/(a|b|c)/bar' ]
       *
       * console.log(braces('foo/{a,b,c}/bar', { expand: true }));
       * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]
       * ```
       * @param {String} `pattern` String with brace pattern to process.
       * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
       * @return {Array}
       * @api public
       */

      micromatch.braces = (pattern, options) => {
        if (typeof pattern !== 'string')
          throw new TypeError('Expected a string')
        if ((options && options.nobrace === true) || !/\{.*\}/.test(pattern)) {
          return [pattern]
        }
        return braces(pattern, options)
      }

      /**
       * Expand braces
       */

      micromatch.braceExpand = (pattern, options) => {
        if (typeof pattern !== 'string')
          throw new TypeError('Expected a string')
        return micromatch.braces(pattern, { ...options, expand: true })
      }

      /**
       * Expose micromatch
       */

      module.exports = micromatch

      /***/
    },

    /***/ 5886: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const pMap = __nccwpck_require__(3434)

      const pFilter = async (iterable, filterer, options) => {
        const values = await pMap(
          iterable,
          (element, index) => Promise.all([filterer(element, index), element]),
          options
        )
        return values.filter(value => Boolean(value[0])).map(value => value[1])
      }

      module.exports = pFilter
      // TODO: Remove this for the next major release
      module.exports['default'] = pFilter

      /***/
    },

    /***/ 3434: /***/ module => {
      'use strict'

      const pMap = (iterable, mapper, options) =>
        new Promise((resolve, reject) => {
          options = Object.assign(
            {
              concurrency: Infinity,
            },
            options
          )

          if (typeof mapper !== 'function') {
            throw new TypeError('Mapper function is required')
          }

          const { concurrency } = options

          if (!(typeof concurrency === 'number' && concurrency >= 1)) {
            throw new TypeError(
              `Expected \`concurrency\` to be a number from 1 and up, got \`${concurrency}\` (${typeof concurrency})`
            )
          }

          const ret = []
          const iterator = iterable[Symbol.iterator]()
          let isRejected = false
          let isIterableDone = false
          let resolvingCount = 0
          let currentIndex = 0

          const next = () => {
            if (isRejected) {
              return
            }

            const nextItem = iterator.next()
            const i = currentIndex
            currentIndex++

            if (nextItem.done) {
              isIterableDone = true

              if (resolvingCount === 0) {
                resolve(ret)
              }

              return
            }

            resolvingCount++

            Promise.resolve(nextItem.value)
              .then(element => mapper(element, i))
              .then(
                value => {
                  ret[i] = value
                  resolvingCount--
                  next()
                },
                error => {
                  isRejected = true
                  reject(error)
                }
              )
          }

          for (let i = 0; i < concurrency; i++) {
            next()

            if (isIterableDone) {
              break
            }
          }
        })

      module.exports = pMap
      // TODO: Remove this for the next major release
      module.exports['default'] = pMap

      /***/
    },

    /***/ 104: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const pLimit = __nccwpck_require__(707)

      class EndError extends Error {
        constructor(value) {
          super()
          this.value = value
        }
      }

      // The input can also be a promise, so we await it
      const testElement = async (element, tester) => tester(await element)

      // The input can also be a promise, so we `Promise.all()` them both
      const finder = async element => {
        const values = await Promise.all(element)
        if (values[1] === true) {
          throw new EndError(values[0])
        }

        return false
      }

      const pLocate = async (iterable, tester, options) => {
        options = {
          concurrency: Infinity,
          preserveOrder: true,
          ...options,
        }

        const limit = pLimit(options.concurrency)

        // Start all the promises concurrently with optional limit
        const items = [...iterable].map(element => [
          element,
          limit(testElement, element, tester),
        ])

        // Check the promises either serially or concurrently
        const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity)

        try {
          await Promise.all(items.map(element => checkLimit(finder, element)))
        } catch (error) {
          if (error instanceof EndError) {
            return error.value
          }

          throw error
        }
      }

      module.exports = pLocate
      // TODO: Remove this for the next major release
      module.exports['default'] = pLocate

      /***/
    },

    /***/ 707: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const pTry = __nccwpck_require__(746)

      const pLimit = concurrency => {
        if (
          !(
            (Number.isInteger(concurrency) || concurrency === Infinity) &&
            concurrency > 0
          )
        ) {
          return Promise.reject(
            new TypeError('Expected `concurrency` to be a number from 1 and up')
          )
        }

        const queue = []
        let activeCount = 0

        const next = () => {
          activeCount--

          if (queue.length > 0) {
            queue.shift()()
          }
        }

        const run = (fn, resolve, ...args) => {
          activeCount++

          const result = pTry(fn, ...args)

          resolve(result)

          result.then(next, next)
        }

        const enqueue = (fn, resolve, ...args) => {
          if (activeCount < concurrency) {
            run(fn, resolve, ...args)
          } else {
            queue.push(run.bind(null, fn, resolve, ...args))
          }
        }

        const generator = (fn, ...args) =>
          new Promise(resolve => enqueue(fn, resolve, ...args))
        Object.defineProperties(generator, {
          activeCount: {
            get: () => activeCount,
          },
          pendingCount: {
            get: () => queue.length,
          },
          clearQueue: {
            value: () => {
              queue.length = 0
            },
          },
        })

        return generator
      }

      module.exports = pLimit
      module.exports['default'] = pLimit

      /***/
    },

    /***/ 746: /***/ module => {
      'use strict'

      const pTry = (fn, ...arguments_) =>
        new Promise(resolve => {
          resolve(fn(...arguments_))
        })

      module.exports = pTry
      // TODO: remove this in the next major version
      module.exports['default'] = pTry

      /***/
    },

    /***/ 6978: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7147)
      const { promisify } = __nccwpck_require__(3837)

      const pAccess = promisify(fs.access)

      module.exports = async path => {
        try {
          await pAccess(path)
          return true
        } catch (_) {
          return false
        }
      }

      module.exports.sync = path => {
        try {
          fs.accessSync(path)
          return true
        } catch (_) {
          return false
        }
      }

      /***/
    },

    /***/ 3433: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const { promisify } = __nccwpck_require__(3837)
      const fs = __nccwpck_require__(7147)

      async function isType(fsStatType, statsMethodName, filePath) {
        if (typeof filePath !== 'string') {
          throw new TypeError(`Expected a string, got ${typeof filePath}`)
        }

        try {
          const stats = await promisify(fs[fsStatType])(filePath)
          return stats[statsMethodName]()
        } catch (error) {
          if (error.code === 'ENOENT') {
            return false
          }

          throw error
        }
      }

      function isTypeSync(fsStatType, statsMethodName, filePath) {
        if (typeof filePath !== 'string') {
          throw new TypeError(`Expected a string, got ${typeof filePath}`)
        }

        try {
          return fs[fsStatType](filePath)[statsMethodName]()
        } catch (error) {
          if (error.code === 'ENOENT') {
            return false
          }

          throw error
        }
      }

      exports.isFile = isType.bind(null, 'stat', 'isFile')
      exports.isDirectory = isType.bind(null, 'stat', 'isDirectory')
      exports.isSymlink = isType.bind(null, 'lstat', 'isSymbolicLink')
      exports.isFileSync = isTypeSync.bind(null, 'statSync', 'isFile')
      exports.isDirectorySync = isTypeSync.bind(null, 'statSync', 'isDirectory')
      exports.isSymlinkSync = isTypeSync.bind(
        null,
        'lstatSync',
        'isSymbolicLink'
      )

      /***/
    },

    /***/ 8569: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      module.exports = __nccwpck_require__(3322)

      /***/
    },

    /***/ 6099: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const path = __nccwpck_require__(1017)
      const WIN_SLASH = '\\\\/'
      const WIN_NO_SLASH = `[^${WIN_SLASH}]`

      /**
       * Posix glob regex
       */

      const DOT_LITERAL = '\\.'
      const PLUS_LITERAL = '\\+'
      const QMARK_LITERAL = '\\?'
      const SLASH_LITERAL = '\\/'
      const ONE_CHAR = '(?=.)'
      const QMARK = '[^/]'
      const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`
      const START_ANCHOR = `(?:^|${SLASH_LITERAL})`
      const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`
      const NO_DOT = `(?!${DOT_LITERAL})`
      const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`
      const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`
      const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`
      const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`
      const STAR = `${QMARK}*?`

      const POSIX_CHARS = {
        DOT_LITERAL,
        PLUS_LITERAL,
        QMARK_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        QMARK,
        END_ANCHOR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR,
      }

      /**
       * Windows glob regex
       */

      const WINDOWS_CHARS = {
        ...POSIX_CHARS,

        SLASH_LITERAL: `[${WIN_SLASH}]`,
        QMARK: WIN_NO_SLASH,
        STAR: `${WIN_NO_SLASH}*?`,
        DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
        NO_DOT: `(?!${DOT_LITERAL})`,
        NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
        NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
        NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
        QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
        START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
        END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,
      }

      /**
       * POSIX Bracket Regex
       */

      const POSIX_REGEX_SOURCE = {
        alnum: 'a-zA-Z0-9',
        alpha: 'a-zA-Z',
        ascii: '\\x00-\\x7F',
        blank: ' \\t',
        cntrl: '\\x00-\\x1F\\x7F',
        digit: '0-9',
        graph: '\\x21-\\x7E',
        lower: 'a-z',
        print: '\\x20-\\x7E ',
        punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
        space: ' \\t\\r\\n\\v\\f',
        upper: 'A-Z',
        word: 'A-Za-z0-9_',
        xdigit: 'A-Fa-f0-9',
      }

      module.exports = {
        MAX_LENGTH: 1024 * 64,
        POSIX_REGEX_SOURCE,

        // regular expressions
        REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
        REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
        REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
        REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
        REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
        REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,

        // Replace globs with equivalent patterns to reduce parsing time.
        REPLACEMENTS: {
          '***': '*',
          '**/**': '**',
          '**/**/**': '**',
        },

        // Digits
        CHAR_0: 48 /* 0 */,
        CHAR_9: 57 /* 9 */,

        // Alphabet chars.
        CHAR_UPPERCASE_A: 65 /* A */,
        CHAR_LOWERCASE_A: 97 /* a */,
        CHAR_UPPERCASE_Z: 90 /* Z */,
        CHAR_LOWERCASE_Z: 122 /* z */,

        CHAR_LEFT_PARENTHESES: 40 /* ( */,
        CHAR_RIGHT_PARENTHESES: 41 /* ) */,

        CHAR_ASTERISK: 42 /* * */,

        // Non-alphabetic chars.
        CHAR_AMPERSAND: 38 /* & */,
        CHAR_AT: 64 /* @ */,
        CHAR_BACKWARD_SLASH: 92 /* \ */,
        CHAR_CARRIAGE_RETURN: 13 /* \r */,
        CHAR_CIRCUMFLEX_ACCENT: 94 /* ^ */,
        CHAR_COLON: 58 /* : */,
        CHAR_COMMA: 44 /* , */,
        CHAR_DOT: 46 /* . */,
        CHAR_DOUBLE_QUOTE: 34 /* " */,
        CHAR_EQUAL: 61 /* = */,
        CHAR_EXCLAMATION_MARK: 33 /* ! */,
        CHAR_FORM_FEED: 12 /* \f */,
        CHAR_FORWARD_SLASH: 47 /* / */,
        CHAR_GRAVE_ACCENT: 96 /* ` */,
        CHAR_HASH: 35 /* # */,
        CHAR_HYPHEN_MINUS: 45 /* - */,
        CHAR_LEFT_ANGLE_BRACKET: 60 /* < */,
        CHAR_LEFT_CURLY_BRACE: 123 /* { */,
        CHAR_LEFT_SQUARE_BRACKET: 91 /* [ */,
        CHAR_LINE_FEED: 10 /* \n */,
        CHAR_NO_BREAK_SPACE: 160 /* \u00A0 */,
        CHAR_PERCENT: 37 /* % */,
        CHAR_PLUS: 43 /* + */,
        CHAR_QUESTION_MARK: 63 /* ? */,
        CHAR_RIGHT_ANGLE_BRACKET: 62 /* > */,
        CHAR_RIGHT_CURLY_BRACE: 125 /* } */,
        CHAR_RIGHT_SQUARE_BRACKET: 93 /* ] */,
        CHAR_SEMICOLON: 59 /* ; */,
        CHAR_SINGLE_QUOTE: 39 /* ' */,
        CHAR_SPACE: 32 /*   */,
        CHAR_TAB: 9 /* \t */,
        CHAR_UNDERSCORE: 95 /* _ */,
        CHAR_VERTICAL_LINE: 124 /* | */,
        CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279 /* \uFEFF */,

        SEP: path.sep,

        /**
         * Create EXTGLOB_CHARS
         */

        extglobChars(chars) {
          return {
            '!': {
              type: 'negate',
              open: '(?:(?!(?:',
              close: `))${chars.STAR})`,
            },
            '?': { type: 'qmark', open: '(?:', close: ')?' },
            '+': { type: 'plus', open: '(?:', close: ')+' },
            '*': { type: 'star', open: '(?:', close: ')*' },
            '@': { type: 'at', open: '(?:', close: ')' },
          }
        },

        /**
         * Create GLOB_CHARS
         */

        globChars(win32) {
          return win32 === true ? WINDOWS_CHARS : POSIX_CHARS
        },
      }

      /***/
    },

    /***/ 2139: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const constants = __nccwpck_require__(6099)
      const utils = __nccwpck_require__(479)

      /**
       * Constants
       */

      const {
        MAX_LENGTH,
        POSIX_REGEX_SOURCE,
        REGEX_NON_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_BACKREF,
        REPLACEMENTS,
      } = constants

      /**
       * Helpers
       */

      const expandRange = (args, options) => {
        if (typeof options.expandRange === 'function') {
          return options.expandRange(...args, options)
        }

        args.sort()
        const value = `[${args.join('-')}]`

        try {
          /* eslint-disable-next-line no-new */
          new RegExp(value)
        } catch (ex) {
          return args.map(v => utils.escapeRegex(v)).join('..')
        }

        return value
      }

      /**
       * Create the message for a syntax error
       */

      const syntaxError = (type, char) => {
        return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`
      }

      /**
       * Parse the given input string.
       * @param {String} input
       * @param {Object} options
       * @return {Object}
       */

      const parse = (input, options) => {
        if (typeof input !== 'string') {
          throw new TypeError('Expected a string')
        }

        input = REPLACEMENTS[input] || input

        const opts = { ...options }
        const max =
          typeof opts.maxLength === 'number'
            ? Math.min(MAX_LENGTH, opts.maxLength)
            : MAX_LENGTH

        let len = input.length
        if (len > max) {
          throw new SyntaxError(
            `Input length: ${len}, exceeds maximum allowed length: ${max}`
          )
        }

        const bos = { type: 'bos', value: '', output: opts.prepend || '' }
        const tokens = [bos]

        const capture = opts.capture ? '' : '?:'
        const win32 = utils.isWindows(options)

        // create constants based on platform, for windows or posix
        const PLATFORM_CHARS = constants.globChars(win32)
        const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS)

        const {
          DOT_LITERAL,
          PLUS_LITERAL,
          SLASH_LITERAL,
          ONE_CHAR,
          DOTS_SLASH,
          NO_DOT,
          NO_DOT_SLASH,
          NO_DOTS_SLASH,
          QMARK,
          QMARK_NO_DOT,
          STAR,
          START_ANCHOR,
        } = PLATFORM_CHARS

        const globstar = opts => {
          return `(${capture}(?:(?!${START_ANCHOR}${
            opts.dot ? DOTS_SLASH : DOT_LITERAL
          }).)*?)`
        }

        const nodot = opts.dot ? '' : NO_DOT
        const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT
        let star = opts.bash === true ? globstar(opts) : STAR

        if (opts.capture) {
          star = `(${star})`
        }

        // minimatch options support
        if (typeof opts.noext === 'boolean') {
          opts.noextglob = opts.noext
        }

        const state = {
          input,
          index: -1,
          start: 0,
          dot: opts.dot === true,
          consumed: '',
          output: '',
          prefix: '',
          backtrack: false,
          negated: false,
          brackets: 0,
          braces: 0,
          parens: 0,
          quotes: 0,
          globstar: false,
          tokens,
        }

        input = utils.removePrefix(input, state)
        len = input.length

        const extglobs = []
        const braces = []
        const stack = []
        let prev = bos
        let value

        /**
         * Tokenizing helpers
         */

        const eos = () => state.index === len - 1
        const peek = (state.peek = (n = 1) => input[state.index + n])
        const advance = (state.advance = () => input[++state.index] || '')
        const remaining = () => input.slice(state.index + 1)
        const consume = (value = '', num = 0) => {
          state.consumed += value
          state.index += num
        }

        const append = token => {
          state.output += token.output != null ? token.output : token.value
          consume(token.value)
        }

        const negate = () => {
          let count = 1

          while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
            advance()
            state.start++
            count++
          }

          if (count % 2 === 0) {
            return false
          }

          state.negated = true
          state.start++
          return true
        }

        const increment = type => {
          state[type]++
          stack.push(type)
        }

        const decrement = type => {
          state[type]--
          stack.pop()
        }

        /**
         * Push tokens onto the tokens array. This helper speeds up
         * tokenizing by 1) helping us avoid backtracking as much as possible,
         * and 2) helping us avoid creating extra tokens when consecutive
         * characters are plain text. This improves performance and simplifies
         * lookbehinds.
         */

        const push = tok => {
          if (prev.type === 'globstar') {
            const isBrace =
              state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace')
            const isExtglob =
              tok.extglob === true ||
              (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'))

            if (
              tok.type !== 'slash' &&
              tok.type !== 'paren' &&
              !isBrace &&
              !isExtglob
            ) {
              state.output = state.output.slice(0, -prev.output.length)
              prev.type = 'star'
              prev.value = '*'
              prev.output = star
              state.output += prev.output
            }
          }

          if (extglobs.length && tok.type !== 'paren') {
            extglobs[extglobs.length - 1].inner += tok.value
          }

          if (tok.value || tok.output) append(tok)
          if (prev && prev.type === 'text' && tok.type === 'text') {
            prev.value += tok.value
            prev.output = (prev.output || '') + tok.value
            return
          }

          tok.prev = prev
          tokens.push(tok)
          prev = tok
        }

        const extglobOpen = (type, value) => {
          const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' }

          token.prev = prev
          token.parens = state.parens
          token.output = state.output
          const output = (opts.capture ? '(' : '') + token.open

          increment('parens')
          push({ type, value, output: state.output ? '' : ONE_CHAR })
          push({ type: 'paren', extglob: true, value: advance(), output })
          extglobs.push(token)
        }

        const extglobClose = token => {
          let output = token.close + (opts.capture ? ')' : '')
          let rest

          if (token.type === 'negate') {
            let extglobStar = star

            if (
              token.inner &&
              token.inner.length > 1 &&
              token.inner.includes('/')
            ) {
              extglobStar = globstar(opts)
            }

            if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
              output = token.close = `)$))${extglobStar}`
            }

            if (
              token.inner.includes('*') &&
              (rest = remaining()) &&
              /^\.[^\\/.]+$/.test(rest)
            ) {
              // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
              // In this case, we need to parse the string and use it in the output of the original pattern.
              // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
              //
              // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
              const expression = parse(rest, {
                ...options,
                fastpaths: false,
              }).output

              output = token.close = `)${expression})${extglobStar})`
            }

            if (token.prev.type === 'bos') {
              state.negatedExtglob = true
            }
          }

          push({ type: 'paren', extglob: true, value, output })
          decrement('parens')
        }

        /**
         * Fast paths
         */

        if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
          let backslashes = false

          let output = input.replace(
            REGEX_SPECIAL_CHARS_BACKREF,
            (m, esc, chars, first, rest, index) => {
              if (first === '\\') {
                backslashes = true
                return m
              }

              if (first === '?') {
                if (esc) {
                  return esc + first + (rest ? QMARK.repeat(rest.length) : '')
                }
                if (index === 0) {
                  return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '')
                }
                return QMARK.repeat(chars.length)
              }

              if (first === '.') {
                return DOT_LITERAL.repeat(chars.length)
              }

              if (first === '*') {
                if (esc) {
                  return esc + first + (rest ? star : '')
                }
                return star
              }
              return esc ? m : `\\${m}`
            }
          )

          if (backslashes === true) {
            if (opts.unescape === true) {
              output = output.replace(/\\/g, '')
            } else {
              output = output.replace(/\\+/g, m => {
                return m.length % 2 === 0 ? '\\\\' : m ? '\\' : ''
              })
            }
          }

          if (output === input && opts.contains === true) {
            state.output = input
            return state
          }

          state.output = utils.wrapOutput(output, state, options)
          return state
        }

        /**
         * Tokenize input until we reach end-of-string
         */

        while (!eos()) {
          value = advance()

          if (value === '\u0000') {
            continue
          }

          /**
           * Escaped characters
           */

          if (value === '\\') {
            const next = peek()

            if (next === '/' && opts.bash !== true) {
              continue
            }

            if (next === '.' || next === ';') {
              continue
            }

            if (!next) {
              value += '\\'
              push({ type: 'text', value })
              continue
            }

            // collapse slashes to reduce potential for exploits
            const match = /^\\+/.exec(remaining())
            let slashes = 0

            if (match && match[0].length > 2) {
              slashes = match[0].length
              state.index += slashes
              if (slashes % 2 !== 0) {
                value += '\\'
              }
            }

            if (opts.unescape === true) {
              value = advance()
            } else {
              value += advance()
            }

            if (state.brackets === 0) {
              push({ type: 'text', value })
              continue
            }
          }

          /**
           * If we're inside a regex character class, continue
           * until we reach the closing bracket.
           */

          if (
            state.brackets > 0 &&
            (value !== ']' || prev.value === '[' || prev.value === '[^')
          ) {
            if (opts.posix !== false && value === ':') {
              const inner = prev.value.slice(1)
              if (inner.includes('[')) {
                prev.posix = true

                if (inner.includes(':')) {
                  const idx = prev.value.lastIndexOf('[')
                  const pre = prev.value.slice(0, idx)
                  const rest = prev.value.slice(idx + 2)
                  const posix = POSIX_REGEX_SOURCE[rest]
                  if (posix) {
                    prev.value = pre + posix
                    state.backtrack = true
                    advance()

                    if (!bos.output && tokens.indexOf(prev) === 1) {
                      bos.output = ONE_CHAR
                    }
                    continue
                  }
                }
              }
            }

            if (
              (value === '[' && peek() !== ':') ||
              (value === '-' && peek() === ']')
            ) {
              value = `\\${value}`
            }

            if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
              value = `\\${value}`
            }

            if (opts.posix === true && value === '!' && prev.value === '[') {
              value = '^'
            }

            prev.value += value
            append({ value })
            continue
          }

          /**
           * If we're inside a quoted string, continue
           * until we reach the closing double quote.
           */

          if (state.quotes === 1 && value !== '"') {
            value = utils.escapeRegex(value)
            prev.value += value
            append({ value })
            continue
          }

          /**
           * Double quotes
           */

          if (value === '"') {
            state.quotes = state.quotes === 1 ? 0 : 1
            if (opts.keepQuotes === true) {
              push({ type: 'text', value })
            }
            continue
          }

          /**
           * Parentheses
           */

          if (value === '(') {
            increment('parens')
            push({ type: 'paren', value })
            continue
          }

          if (value === ')') {
            if (state.parens === 0 && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError('opening', '('))
            }

            const extglob = extglobs[extglobs.length - 1]
            if (extglob && state.parens === extglob.parens + 1) {
              extglobClose(extglobs.pop())
              continue
            }

            push({ type: 'paren', value, output: state.parens ? ')' : '\\)' })
            decrement('parens')
            continue
          }

          /**
           * Square brackets
           */

          if (value === '[') {
            if (opts.nobracket === true || !remaining().includes(']')) {
              if (opts.nobracket !== true && opts.strictBrackets === true) {
                throw new SyntaxError(syntaxError('closing', ']'))
              }

              value = `\\${value}`
            } else {
              increment('brackets')
            }

            push({ type: 'bracket', value })
            continue
          }

          if (value === ']') {
            if (
              opts.nobracket === true ||
              (prev && prev.type === 'bracket' && prev.value.length === 1)
            ) {
              push({ type: 'text', value, output: `\\${value}` })
              continue
            }

            if (state.brackets === 0) {
              if (opts.strictBrackets === true) {
                throw new SyntaxError(syntaxError('opening', '['))
              }

              push({ type: 'text', value, output: `\\${value}` })
              continue
            }

            decrement('brackets')

            const prevValue = prev.value.slice(1)
            if (
              prev.posix !== true &&
              prevValue[0] === '^' &&
              !prevValue.includes('/')
            ) {
              value = `/${value}`
            }

            prev.value += value
            append({ value })

            // when literal brackets are explicitly disabled
            // assume we should match with a regex character class
            if (
              opts.literalBrackets === false ||
              utils.hasRegexChars(prevValue)
            ) {
              continue
            }

            const escaped = utils.escapeRegex(prev.value)
            state.output = state.output.slice(0, -prev.value.length)

            // when literal brackets are explicitly enabled
            // assume we should escape the brackets to match literal characters
            if (opts.literalBrackets === true) {
              state.output += escaped
              prev.value = escaped
              continue
            }

            // when the user specifies nothing, try to match both
            prev.value = `(${capture}${escaped}|${prev.value})`
            state.output += prev.value
            continue
          }

          /**
           * Braces
           */

          if (value === '{' && opts.nobrace !== true) {
            increment('braces')

            const open = {
              type: 'brace',
              value,
              output: '(',
              outputIndex: state.output.length,
              tokensIndex: state.tokens.length,
            }

            braces.push(open)
            push(open)
            continue
          }

          if (value === '}') {
            const brace = braces[braces.length - 1]

            if (opts.nobrace === true || !brace) {
              push({ type: 'text', value, output: value })
              continue
            }

            let output = ')'

            if (brace.dots === true) {
              const arr = tokens.slice()
              const range = []

              for (let i = arr.length - 1; i >= 0; i--) {
                tokens.pop()
                if (arr[i].type === 'brace') {
                  break
                }
                if (arr[i].type !== 'dots') {
                  range.unshift(arr[i].value)
                }
              }

              output = expandRange(range, opts)
              state.backtrack = true
            }

            if (brace.comma !== true && brace.dots !== true) {
              const out = state.output.slice(0, brace.outputIndex)
              const toks = state.tokens.slice(brace.tokensIndex)
              brace.value = brace.output = '\\{'
              value = output = '\\}'
              state.output = out
              for (const t of toks) {
                state.output += t.output || t.value
              }
            }

            push({ type: 'brace', value, output })
            decrement('braces')
            braces.pop()
            continue
          }

          /**
           * Pipes
           */

          if (value === '|') {
            if (extglobs.length > 0) {
              extglobs[extglobs.length - 1].conditions++
            }
            push({ type: 'text', value })
            continue
          }

          /**
           * Commas
           */

          if (value === ',') {
            let output = value

            const brace = braces[braces.length - 1]
            if (brace && stack[stack.length - 1] === 'braces') {
              brace.comma = true
              output = '|'
            }

            push({ type: 'comma', value, output })
            continue
          }

          /**
           * Slashes
           */

          if (value === '/') {
            // if the beginning of the glob is "./", advance the start
            // to the current index, and don't add the "./" characters
            // to the state. This greatly simplifies lookbehinds when
            // checking for BOS characters like "!" and "." (not "./")
            if (prev.type === 'dot' && state.index === state.start + 1) {
              state.start = state.index + 1
              state.consumed = ''
              state.output = ''
              tokens.pop()
              prev = bos // reset "prev" to the first token
              continue
            }

            push({ type: 'slash', value, output: SLASH_LITERAL })
            continue
          }

          /**
           * Dots
           */

          if (value === '.') {
            if (state.braces > 0 && prev.type === 'dot') {
              if (prev.value === '.') prev.output = DOT_LITERAL
              const brace = braces[braces.length - 1]
              prev.type = 'dots'
              prev.output += value
              prev.value += value
              brace.dots = true
              continue
            }

            if (
              state.braces + state.parens === 0 &&
              prev.type !== 'bos' &&
              prev.type !== 'slash'
            ) {
              push({ type: 'text', value, output: DOT_LITERAL })
              continue
            }

            push({ type: 'dot', value, output: DOT_LITERAL })
            continue
          }

          /**
           * Question marks
           */

          if (value === '?') {
            const isGroup = prev && prev.value === '('
            if (
              !isGroup &&
              opts.noextglob !== true &&
              peek() === '(' &&
              peek(2) !== '?'
            ) {
              extglobOpen('qmark', value)
              continue
            }

            if (prev && prev.type === 'paren') {
              const next = peek()
              let output = value

              if (next === '<' && !utils.supportsLookbehinds()) {
                throw new Error(
                  'Node.js v10 or higher is required for regex lookbehinds'
                )
              }

              if (
                (prev.value === '(' && !/[!=<:]/.test(next)) ||
                (next === '<' && !/<([!=]|\w+>)/.test(remaining()))
              ) {
                output = `\\${value}`
              }

              push({ type: 'text', value, output })
              continue
            }

            if (
              opts.dot !== true &&
              (prev.type === 'slash' || prev.type === 'bos')
            ) {
              push({ type: 'qmark', value, output: QMARK_NO_DOT })
              continue
            }

            push({ type: 'qmark', value, output: QMARK })
            continue
          }

          /**
           * Exclamation
           */

          if (value === '!') {
            if (opts.noextglob !== true && peek() === '(') {
              if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
                extglobOpen('negate', value)
                continue
              }
            }

            if (opts.nonegate !== true && state.index === 0) {
              negate()
              continue
            }
          }

          /**
           * Plus
           */

          if (value === '+') {
            if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
              extglobOpen('plus', value)
              continue
            }

            if ((prev && prev.value === '(') || opts.regex === false) {
              push({ type: 'plus', value, output: PLUS_LITERAL })
              continue
            }

            if (
              (prev &&
                (prev.type === 'bracket' ||
                  prev.type === 'paren' ||
                  prev.type === 'brace')) ||
              state.parens > 0
            ) {
              push({ type: 'plus', value })
              continue
            }

            push({ type: 'plus', value: PLUS_LITERAL })
            continue
          }

          /**
           * Plain text
           */

          if (value === '@') {
            if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
              push({ type: 'at', extglob: true, value, output: '' })
              continue
            }

            push({ type: 'text', value })
            continue
          }

          /**
           * Plain text
           */

          if (value !== '*') {
            if (value === '$' || value === '^') {
              value = `\\${value}`
            }

            const match = REGEX_NON_SPECIAL_CHARS.exec(remaining())
            if (match) {
              value += match[0]
              state.index += match[0].length
            }

            push({ type: 'text', value })
            continue
          }

          /**
           * Stars
           */

          if (prev && (prev.type === 'globstar' || prev.star === true)) {
            prev.type = 'star'
            prev.star = true
            prev.value += value
            prev.output = star
            state.backtrack = true
            state.globstar = true
            consume(value)
            continue
          }

          let rest = remaining()
          if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
            extglobOpen('star', value)
            continue
          }

          if (prev.type === 'star') {
            if (opts.noglobstar === true) {
              consume(value)
              continue
            }

            const prior = prev.prev
            const before = prior.prev
            const isStart = prior.type === 'slash' || prior.type === 'bos'
            const afterStar =
              before && (before.type === 'star' || before.type === 'globstar')

            if (
              opts.bash === true &&
              (!isStart || (rest[0] && rest[0] !== '/'))
            ) {
              push({ type: 'star', value, output: '' })
              continue
            }

            const isBrace =
              state.braces > 0 &&
              (prior.type === 'comma' || prior.type === 'brace')
            const isExtglob =
              extglobs.length &&
              (prior.type === 'pipe' || prior.type === 'paren')
            if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
              push({ type: 'star', value, output: '' })
              continue
            }

            // strip consecutive `/**/`
            while (rest.slice(0, 3) === '/**') {
              const after = input[state.index + 4]
              if (after && after !== '/') {
                break
              }
              rest = rest.slice(3)
              consume('/**', 3)
            }

            if (prior.type === 'bos' && eos()) {
              prev.type = 'globstar'
              prev.value += value
              prev.output = globstar(opts)
              state.output = prev.output
              state.globstar = true
              consume(value)
              continue
            }

            if (
              prior.type === 'slash' &&
              prior.prev.type !== 'bos' &&
              !afterStar &&
              eos()
            ) {
              state.output = state.output.slice(
                0,
                -(prior.output + prev.output).length
              )
              prior.output = `(?:${prior.output}`

              prev.type = 'globstar'
              prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)')
              prev.value += value
              state.globstar = true
              state.output += prior.output + prev.output
              consume(value)
              continue
            }

            if (
              prior.type === 'slash' &&
              prior.prev.type !== 'bos' &&
              rest[0] === '/'
            ) {
              const end = rest[1] !== void 0 ? '|$' : ''

              state.output = state.output.slice(
                0,
                -(prior.output + prev.output).length
              )
              prior.output = `(?:${prior.output}`

              prev.type = 'globstar'
              prev.output = `${globstar(
                opts
              )}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`
              prev.value += value

              state.output += prior.output + prev.output
              state.globstar = true

              consume(value + advance())

              push({ type: 'slash', value: '/', output: '' })
              continue
            }

            if (prior.type === 'bos' && rest[0] === '/') {
              prev.type = 'globstar'
              prev.value += value
              prev.output = `(?:^|${SLASH_LITERAL}|${globstar(
                opts
              )}${SLASH_LITERAL})`
              state.output = prev.output
              state.globstar = true
              consume(value + advance())
              push({ type: 'slash', value: '/', output: '' })
              continue
            }

            // remove single star from output
            state.output = state.output.slice(0, -prev.output.length)

            // reset previous token to globstar
            prev.type = 'globstar'
            prev.output = globstar(opts)
            prev.value += value

            // reset output with globstar
            state.output += prev.output
            state.globstar = true
            consume(value)
            continue
          }

          const token = { type: 'star', value, output: star }

          if (opts.bash === true) {
            token.output = '.*?'
            if (prev.type === 'bos' || prev.type === 'slash') {
              token.output = nodot + token.output
            }
            push(token)
            continue
          }

          if (
            prev &&
            (prev.type === 'bracket' || prev.type === 'paren') &&
            opts.regex === true
          ) {
            token.output = value
            push(token)
            continue
          }

          if (
            state.index === state.start ||
            prev.type === 'slash' ||
            prev.type === 'dot'
          ) {
            if (prev.type === 'dot') {
              state.output += NO_DOT_SLASH
              prev.output += NO_DOT_SLASH
            } else if (opts.dot === true) {
              state.output += NO_DOTS_SLASH
              prev.output += NO_DOTS_SLASH
            } else {
              state.output += nodot
              prev.output += nodot
            }

            if (peek() !== '*') {
              state.output += ONE_CHAR
              prev.output += ONE_CHAR
            }
          }

          push(token)
        }

        while (state.brackets > 0) {
          if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError('closing', ']'))
          state.output = utils.escapeLast(state.output, '[')
          decrement('brackets')
        }

        while (state.parens > 0) {
          if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError('closing', ')'))
          state.output = utils.escapeLast(state.output, '(')
          decrement('parens')
        }

        while (state.braces > 0) {
          if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError('closing', '}'))
          state.output = utils.escapeLast(state.output, '{')
          decrement('braces')
        }

        if (
          opts.strictSlashes !== true &&
          (prev.type === 'star' || prev.type === 'bracket')
        ) {
          push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` })
        }

        // rebuild the output if we had to backtrack at any point
        if (state.backtrack === true) {
          state.output = ''

          for (const token of state.tokens) {
            state.output += token.output != null ? token.output : token.value

            if (token.suffix) {
              state.output += token.suffix
            }
          }
        }

        return state
      }

      /**
       * Fast paths for creating regular expressions for common glob patterns.
       * This can significantly speed up processing and has very little downside
       * impact when none of the fast paths match.
       */

      parse.fastpaths = (input, options) => {
        const opts = { ...options }
        const max =
          typeof opts.maxLength === 'number'
            ? Math.min(MAX_LENGTH, opts.maxLength)
            : MAX_LENGTH
        const len = input.length
        if (len > max) {
          throw new SyntaxError(
            `Input length: ${len}, exceeds maximum allowed length: ${max}`
          )
        }

        input = REPLACEMENTS[input] || input
        const win32 = utils.isWindows(options)

        // create constants based on platform, for windows or posix
        const {
          DOT_LITERAL,
          SLASH_LITERAL,
          ONE_CHAR,
          DOTS_SLASH,
          NO_DOT,
          NO_DOTS,
          NO_DOTS_SLASH,
          STAR,
          START_ANCHOR,
        } = constants.globChars(win32)

        const nodot = opts.dot ? NO_DOTS : NO_DOT
        const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT
        const capture = opts.capture ? '' : '?:'
        const state = { negated: false, prefix: '' }
        let star = opts.bash === true ? '.*?' : STAR

        if (opts.capture) {
          star = `(${star})`
        }

        const globstar = opts => {
          if (opts.noglobstar === true) return star
          return `(${capture}(?:(?!${START_ANCHOR}${
            opts.dot ? DOTS_SLASH : DOT_LITERAL
          }).)*?)`
        }

        const create = str => {
          switch (str) {
            case '*':
              return `${nodot}${ONE_CHAR}${star}`

            case '.*':
              return `${DOT_LITERAL}${ONE_CHAR}${star}`

            case '*.*':
              return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`

            case '*/*':
              return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`

            case '**':
              return nodot + globstar(opts)

            case '**/*':
              return `(?:${nodot}${globstar(
                opts
              )}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`

            case '**/*.*':
              return `(?:${nodot}${globstar(
                opts
              )}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`

            case '**/.*':
              return `(?:${nodot}${globstar(
                opts
              )}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`

            default: {
              const match = /^(.*?)\.(\w+)$/.exec(str)
              if (!match) return

              const source = create(match[1])
              if (!source) return

              return source + DOT_LITERAL + match[2]
            }
          }
        }

        const output = utils.removePrefix(input, state)
        let source = create(output)

        if (source && opts.strictSlashes !== true) {
          source += `${SLASH_LITERAL}?`
        }

        return source
      }

      module.exports = parse

      /***/
    },

    /***/ 3322: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const path = __nccwpck_require__(1017)
      const scan = __nccwpck_require__(2429)
      const parse = __nccwpck_require__(2139)
      const utils = __nccwpck_require__(479)
      const constants = __nccwpck_require__(6099)
      const isObject = val =>
        val && typeof val === 'object' && !Array.isArray(val)

      /**
       * Creates a matcher function from one or more glob patterns. The
       * returned function takes a string to match as its first argument,
       * and returns true if the string is a match. The returned matcher
       * function also takes a boolean as the second argument that, when true,
       * returns an object with additional information.
       *
       * ```js
       * const picomatch = require('picomatch');
       * // picomatch(glob[, options]);
       *
       * const isMatch = picomatch('*.!(*a)');
       * console.log(isMatch('a.a')); //=> false
       * console.log(isMatch('a.b')); //=> true
       * ```
       * @name picomatch
       * @param {String|Array} `globs` One or more glob patterns.
       * @param {Object=} `options`
       * @return {Function=} Returns a matcher function.
       * @api public
       */

      const picomatch = (glob, options, returnState = false) => {
        if (Array.isArray(glob)) {
          const fns = glob.map(input => picomatch(input, options, returnState))
          const arrayMatcher = str => {
            for (const isMatch of fns) {
              const state = isMatch(str)
              if (state) return state
            }
            return false
          }
          return arrayMatcher
        }

        const isState = isObject(glob) && glob.tokens && glob.input

        if (glob === '' || (typeof glob !== 'string' && !isState)) {
          throw new TypeError('Expected pattern to be a non-empty string')
        }

        const opts = options || {}
        const posix = utils.isWindows(options)
        const regex = isState
          ? picomatch.compileRe(glob, options)
          : picomatch.makeRe(glob, options, false, true)

        const state = regex.state
        delete regex.state

        let isIgnored = () => false
        if (opts.ignore) {
          const ignoreOpts = {
            ...options,
            ignore: null,
            onMatch: null,
            onResult: null,
          }
          isIgnored = picomatch(opts.ignore, ignoreOpts, returnState)
        }

        const matcher = (input, returnObject = false) => {
          const { isMatch, match, output } = picomatch.test(
            input,
            regex,
            options,
            { glob, posix }
          )
          const result = {
            glob,
            state,
            regex,
            posix,
            input,
            output,
            match,
            isMatch,
          }

          if (typeof opts.onResult === 'function') {
            opts.onResult(result)
          }

          if (isMatch === false) {
            result.isMatch = false
            return returnObject ? result : false
          }

          if (isIgnored(input)) {
            if (typeof opts.onIgnore === 'function') {
              opts.onIgnore(result)
            }
            result.isMatch = false
            return returnObject ? result : false
          }

          if (typeof opts.onMatch === 'function') {
            opts.onMatch(result)
          }
          return returnObject ? result : true
        }

        if (returnState) {
          matcher.state = state
        }

        return matcher
      }

      /**
       * Test `input` with the given `regex`. This is used by the main
       * `picomatch()` function to test the input string.
       *
       * ```js
       * const picomatch = require('picomatch');
       * // picomatch.test(input, regex[, options]);
       *
       * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
       * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
       * ```
       * @param {String} `input` String to test.
       * @param {RegExp} `regex`
       * @return {Object} Returns an object with matching info.
       * @api public
       */

      picomatch.test = (input, regex, options, { glob, posix } = {}) => {
        if (typeof input !== 'string') {
          throw new TypeError('Expected input to be a string')
        }

        if (input === '') {
          return { isMatch: false, output: '' }
        }

        const opts = options || {}
        const format = opts.format || (posix ? utils.toPosixSlashes : null)
        let match = input === glob
        let output = match && format ? format(input) : input

        if (match === false) {
          output = format ? format(input) : input
          match = output === glob
        }

        if (match === false || opts.capture === true) {
          if (opts.matchBase === true || opts.basename === true) {
            match = picomatch.matchBase(input, regex, options, posix)
          } else {
            match = regex.exec(output)
          }
        }

        return { isMatch: Boolean(match), match, output }
      }

      /**
       * Match the basename of a filepath.
       *
       * ```js
       * const picomatch = require('picomatch');
       * // picomatch.matchBase(input, glob[, options]);
       * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
       * ```
       * @param {String} `input` String to test.
       * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
       * @return {Boolean}
       * @api public
       */

      picomatch.matchBase = (
        input,
        glob,
        options,
        posix = utils.isWindows(options)
      ) => {
        const regex =
          glob instanceof RegExp ? glob : picomatch.makeRe(glob, options)
        return regex.test(path.basename(input))
      }

      /**
       * Returns true if **any** of the given glob `patterns` match the specified `string`.
       *
       * ```js
       * const picomatch = require('picomatch');
       * // picomatch.isMatch(string, patterns[, options]);
       *
       * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
       * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
       * ```
       * @param {String|Array} str The string to test.
       * @param {String|Array} patterns One or more glob patterns to use for matching.
       * @param {Object} [options] See available [options](#options).
       * @return {Boolean} Returns true if any patterns match `str`
       * @api public
       */

      picomatch.isMatch = (str, patterns, options) =>
        picomatch(patterns, options)(str)

      /**
       * Parse a glob pattern to create the source string for a regular
       * expression.
       *
       * ```js
       * const picomatch = require('picomatch');
       * const result = picomatch.parse(pattern[, options]);
       * ```
       * @param {String} `pattern`
       * @param {Object} `options`
       * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
       * @api public
       */

      picomatch.parse = (pattern, options) => {
        if (Array.isArray(pattern))
          return pattern.map(p => picomatch.parse(p, options))
        return parse(pattern, { ...options, fastpaths: false })
      }

      /**
       * Scan a glob pattern to separate the pattern into segments.
       *
       * ```js
       * const picomatch = require('picomatch');
       * // picomatch.scan(input[, options]);
       *
       * const result = picomatch.scan('!./foo/*.js');
       * console.log(result);
       * { prefix: '!./',
       *   input: '!./foo/*.js',
       *   start: 3,
       *   base: 'foo',
       *   glob: '*.js',
       *   isBrace: false,
       *   isBracket: false,
       *   isGlob: true,
       *   isExtglob: false,
       *   isGlobstar: false,
       *   negated: true }
       * ```
       * @param {String} `input` Glob pattern to scan.
       * @param {Object} `options`
       * @return {Object} Returns an object with
       * @api public
       */

      picomatch.scan = (input, options) => scan(input, options)

      /**
       * Compile a regular expression from the `state` object returned by the
       * [parse()](#parse) method.
       *
       * @param {Object} `state`
       * @param {Object} `options`
       * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
       * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
       * @return {RegExp}
       * @api public
       */

      picomatch.compileRe = (
        state,
        options,
        returnOutput = false,
        returnState = false
      ) => {
        if (returnOutput === true) {
          return state.output
        }

        const opts = options || {}
        const prepend = opts.contains ? '' : '^'
        const append = opts.contains ? '' : '$'

        let source = `${prepend}(?:${state.output})${append}`
        if (state && state.negated === true) {
          source = `^(?!${source}).*$`
        }

        const regex = picomatch.toRegex(source, options)
        if (returnState === true) {
          regex.state = state
        }

        return regex
      }

      /**
       * Create a regular expression from a parsed glob pattern.
       *
       * ```js
       * const picomatch = require('picomatch');
       * const state = picomatch.parse('*.js');
       * // picomatch.compileRe(state[, options]);
       *
       * console.log(picomatch.compileRe(state));
       * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
       * ```
       * @param {String} `state` The object returned from the `.parse` method.
       * @param {Object} `options`
       * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
       * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
       * @return {RegExp} Returns a regex created from the given pattern.
       * @api public
       */

      picomatch.makeRe = (
        input,
        options = {},
        returnOutput = false,
        returnState = false
      ) => {
        if (!input || typeof input !== 'string') {
          throw new TypeError('Expected a non-empty string')
        }

        let parsed = { negated: false, fastpaths: true }

        if (
          options.fastpaths !== false &&
          (input[0] === '.' || input[0] === '*')
        ) {
          parsed.output = parse.fastpaths(input, options)
        }

        if (!parsed.output) {
          parsed = parse(input, options)
        }

        return picomatch.compileRe(parsed, options, returnOutput, returnState)
      }

      /**
       * Create a regular expression from the given regex source string.
       *
       * ```js
       * const picomatch = require('picomatch');
       * // picomatch.toRegex(source[, options]);
       *
       * const { output } = picomatch.parse('*.js');
       * console.log(picomatch.toRegex(output));
       * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
       * ```
       * @param {String} `source` Regular expression source string.
       * @param {Object} `options`
       * @return {RegExp}
       * @api public
       */

      picomatch.toRegex = (source, options) => {
        try {
          const opts = options || {}
          return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''))
        } catch (err) {
          if (options && options.debug === true) throw err
          return /$^/
        }
      }

      /**
       * Picomatch constants.
       * @return {Object}
       */

      picomatch.constants = constants

      /**
       * Expose "picomatch"
       */

      module.exports = picomatch

      /***/
    },

    /***/ 2429: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const utils = __nccwpck_require__(479)
      const {
        CHAR_ASTERISK /* * */,
        CHAR_AT /* @ */,
        CHAR_BACKWARD_SLASH /* \ */,
        CHAR_COMMA /* , */,
        CHAR_DOT /* . */,
        CHAR_EXCLAMATION_MARK /* ! */,
        CHAR_FORWARD_SLASH /* / */,
        CHAR_LEFT_CURLY_BRACE /* { */,
        CHAR_LEFT_PARENTHESES /* ( */,
        CHAR_LEFT_SQUARE_BRACKET /* [ */,
        CHAR_PLUS /* + */,
        CHAR_QUESTION_MARK /* ? */,
        CHAR_RIGHT_CURLY_BRACE /* } */,
        CHAR_RIGHT_PARENTHESES /* ) */,
        CHAR_RIGHT_SQUARE_BRACKET /* ] */,
      } = __nccwpck_require__(6099)

      const isPathSeparator = code => {
        return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH
      }

      const depth = token => {
        if (token.isPrefix !== true) {
          token.depth = token.isGlobstar ? Infinity : 1
        }
      }

      /**
       * Quickly scans a glob pattern and returns an object with a handful of
       * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
       * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
       * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
       *
       * ```js
       * const pm = require('picomatch');
       * console.log(pm.scan('foo/bar/*.js'));
       * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
       * ```
       * @param {String} `str`
       * @param {Object} `options`
       * @return {Object} Returns an object with tokens and regex source string.
       * @api public
       */

      const scan = (input, options) => {
        const opts = options || {}

        const length = input.length - 1
        const scanToEnd = opts.parts === true || opts.scanToEnd === true
        const slashes = []
        const tokens = []
        const parts = []

        let str = input
        let index = -1
        let start = 0
        let lastIndex = 0
        let isBrace = false
        let isBracket = false
        let isGlob = false
        let isExtglob = false
        let isGlobstar = false
        let braceEscaped = false
        let backslashes = false
        let negated = false
        let negatedExtglob = false
        let finished = false
        let braces = 0
        let prev
        let code
        let token = { value: '', depth: 0, isGlob: false }

        const eos = () => index >= length
        const peek = () => str.charCodeAt(index + 1)
        const advance = () => {
          prev = code
          return str.charCodeAt(++index)
        }

        while (index < length) {
          code = advance()
          let next

          if (code === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true
            code = advance()

            if (code === CHAR_LEFT_CURLY_BRACE) {
              braceEscaped = true
            }
            continue
          }

          if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
            braces++

            while (eos() !== true && (code = advance())) {
              if (code === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = true
                advance()
                continue
              }

              if (code === CHAR_LEFT_CURLY_BRACE) {
                braces++
                continue
              }

              if (
                braceEscaped !== true &&
                code === CHAR_DOT &&
                (code = advance()) === CHAR_DOT
              ) {
                isBrace = token.isBrace = true
                isGlob = token.isGlob = true
                finished = true

                if (scanToEnd === true) {
                  continue
                }

                break
              }

              if (braceEscaped !== true && code === CHAR_COMMA) {
                isBrace = token.isBrace = true
                isGlob = token.isGlob = true
                finished = true

                if (scanToEnd === true) {
                  continue
                }

                break
              }

              if (code === CHAR_RIGHT_CURLY_BRACE) {
                braces--

                if (braces === 0) {
                  braceEscaped = false
                  isBrace = token.isBrace = true
                  finished = true
                  break
                }
              }
            }

            if (scanToEnd === true) {
              continue
            }

            break
          }

          if (code === CHAR_FORWARD_SLASH) {
            slashes.push(index)
            tokens.push(token)
            token = { value: '', depth: 0, isGlob: false }

            if (finished === true) continue
            if (prev === CHAR_DOT && index === start + 1) {
              start += 2
              continue
            }

            lastIndex = index + 1
            continue
          }

          if (opts.noext !== true) {
            const isExtglobChar =
              code === CHAR_PLUS ||
              code === CHAR_AT ||
              code === CHAR_ASTERISK ||
              code === CHAR_QUESTION_MARK ||
              code === CHAR_EXCLAMATION_MARK

            if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
              isGlob = token.isGlob = true
              isExtglob = token.isExtglob = true
              finished = true
              if (code === CHAR_EXCLAMATION_MARK && index === start) {
                negatedExtglob = true
              }

              if (scanToEnd === true) {
                while (eos() !== true && (code = advance())) {
                  if (code === CHAR_BACKWARD_SLASH) {
                    backslashes = token.backslashes = true
                    code = advance()
                    continue
                  }

                  if (code === CHAR_RIGHT_PARENTHESES) {
                    isGlob = token.isGlob = true
                    finished = true
                    break
                  }
                }
                continue
              }
              break
            }
          }

          if (code === CHAR_ASTERISK) {
            if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true
            isGlob = token.isGlob = true
            finished = true

            if (scanToEnd === true) {
              continue
            }
            break
          }

          if (code === CHAR_QUESTION_MARK) {
            isGlob = token.isGlob = true
            finished = true

            if (scanToEnd === true) {
              continue
            }
            break
          }

          if (code === CHAR_LEFT_SQUARE_BRACKET) {
            while (eos() !== true && (next = advance())) {
              if (next === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = true
                advance()
                continue
              }

              if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                isBracket = token.isBracket = true
                isGlob = token.isGlob = true
                finished = true
                break
              }
            }

            if (scanToEnd === true) {
              continue
            }

            break
          }

          if (
            opts.nonegate !== true &&
            code === CHAR_EXCLAMATION_MARK &&
            index === start
          ) {
            negated = token.negated = true
            start++
            continue
          }

          if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true

            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_LEFT_PARENTHESES) {
                  backslashes = token.backslashes = true
                  code = advance()
                  continue
                }

                if (code === CHAR_RIGHT_PARENTHESES) {
                  finished = true
                  break
                }
              }
              continue
            }
            break
          }

          if (isGlob === true) {
            finished = true

            if (scanToEnd === true) {
              continue
            }

            break
          }
        }

        if (opts.noext === true) {
          isExtglob = false
          isGlob = false
        }

        let base = str
        let prefix = ''
        let glob = ''

        if (start > 0) {
          prefix = str.slice(0, start)
          str = str.slice(start)
          lastIndex -= start
        }

        if (base && isGlob === true && lastIndex > 0) {
          base = str.slice(0, lastIndex)
          glob = str.slice(lastIndex)
        } else if (isGlob === true) {
          base = ''
          glob = str
        } else {
          base = str
        }

        if (base && base !== '' && base !== '/' && base !== str) {
          if (isPathSeparator(base.charCodeAt(base.length - 1))) {
            base = base.slice(0, -1)
          }
        }

        if (opts.unescape === true) {
          if (glob) glob = utils.removeBackslashes(glob)

          if (base && backslashes === true) {
            base = utils.removeBackslashes(base)
          }
        }

        const state = {
          prefix,
          input,
          start,
          base,
          glob,
          isBrace,
          isBracket,
          isGlob,
          isExtglob,
          isGlobstar,
          negated,
          negatedExtglob,
        }

        if (opts.tokens === true) {
          state.maxDepth = 0
          if (!isPathSeparator(code)) {
            tokens.push(token)
          }
          state.tokens = tokens
        }

        if (opts.parts === true || opts.tokens === true) {
          let prevIndex

          for (let idx = 0; idx < slashes.length; idx++) {
            const n = prevIndex ? prevIndex + 1 : start
            const i = slashes[idx]
            const value = input.slice(n, i)
            if (opts.tokens) {
              if (idx === 0 && start !== 0) {
                tokens[idx].isPrefix = true
                tokens[idx].value = prefix
              } else {
                tokens[idx].value = value
              }
              depth(tokens[idx])
              state.maxDepth += tokens[idx].depth
            }
            if (idx !== 0 || value !== '') {
              parts.push(value)
            }
            prevIndex = i
          }

          if (prevIndex && prevIndex + 1 < input.length) {
            const value = input.slice(prevIndex + 1)
            parts.push(value)

            if (opts.tokens) {
              tokens[tokens.length - 1].value = value
              depth(tokens[tokens.length - 1])
              state.maxDepth += tokens[tokens.length - 1].depth
            }
          }

          state.slashes = slashes
          state.parts = parts
        }

        return state
      }

      module.exports = scan

      /***/
    },

    /***/ 479: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const path = __nccwpck_require__(1017)
      const win32 = process.platform === 'win32'
      const {
        REGEX_BACKSLASH,
        REGEX_REMOVE_BACKSLASH,
        REGEX_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_GLOBAL,
      } = __nccwpck_require__(6099)

      exports.isObject = val =>
        val !== null && typeof val === 'object' && !Array.isArray(val)
      exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str)
      exports.isRegexChar = str =>
        str.length === 1 && exports.hasRegexChars(str)
      exports.escapeRegex = str =>
        str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1')
      exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/')

      exports.removeBackslashes = str => {
        return str.replace(REGEX_REMOVE_BACKSLASH, match => {
          return match === '\\' ? '' : match
        })
      }

      exports.supportsLookbehinds = () => {
        const segs = process.version.slice(1).split('.').map(Number)
        if (
          (segs.length === 3 && segs[0] >= 9) ||
          (segs[0] === 8 && segs[1] >= 10)
        ) {
          return true
        }
        return false
      }

      exports.isWindows = options => {
        if (options && typeof options.windows === 'boolean') {
          return options.windows
        }
        return win32 === true || path.sep === '\\'
      }

      exports.escapeLast = (input, char, lastIdx) => {
        const idx = input.lastIndexOf(char, lastIdx)
        if (idx === -1) return input
        if (input[idx - 1] === '\\')
          return exports.escapeLast(input, char, idx - 1)
        return `${input.slice(0, idx)}\\${input.slice(idx)}`
      }

      exports.removePrefix = (input, state = {}) => {
        let output = input
        if (output.startsWith('./')) {
          output = output.slice(2)
          state.prefix = './'
        }
        return output
      }

      exports.wrapOutput = (input, state = {}, options = {}) => {
        const prepend = options.contains ? '' : '^'
        const append = options.contains ? '' : '$'

        let output = `${prepend}(?:${input})${append}`
        if (state.negated === true) {
          output = `(?:^(?!${output}).*$)`
        }
        return output
      }

      /***/
    },

    /***/ 4810: /***/ module => {
      'use strict'

      const processFn = (fn, options) =>
        function (...args) {
          const P = options.promiseModule

          return new P((resolve, reject) => {
            if (options.multiArgs) {
              args.push((...result) => {
                if (options.errorFirst) {
                  if (result[0]) {
                    reject(result)
                  } else {
                    result.shift()
                    resolve(result)
                  }
                } else {
                  resolve(result)
                }
              })
            } else if (options.errorFirst) {
              args.push((error, result) => {
                if (error) {
                  reject(error)
                } else {
                  resolve(result)
                }
              })
            } else {
              args.push(resolve)
            }

            fn.apply(this, args)
          })
        }

      module.exports = (input, options) => {
        options = Object.assign(
          {
            exclude: [/.+(Sync|Stream)$/],
            errorFirst: true,
            promiseModule: Promise,
          },
          options
        )

        const objType = typeof input
        if (
          !(input !== null && (objType === 'object' || objType === 'function'))
        ) {
          throw new TypeError(
            `Expected \`input\` to be a \`Function\` or \`Object\`, got \`${
              input === null ? 'null' : objType
            }\``
          )
        }

        const filter = key => {
          const match = pattern =>
            typeof pattern === 'string' ? key === pattern : pattern.test(key)
          return options.include
            ? options.include.some(match)
            : !options.exclude.some(match)
        }

        let ret
        if (objType === 'function') {
          ret = function (...args) {
            return options.excludeMain
              ? input(...args)
              : processFn(input, options).apply(this, args)
          }
        } else {
          ret = Object.create(Object.getPrototypeOf(input))
        }

        for (const key in input) {
          // eslint-disable-line guard-for-in
          const property = input[key]
          ret[key] =
            typeof property === 'function' && filter(key)
              ? processFn(property, options)
              : property
        }

        return ret
      }

      /***/
    },

    /***/ 3541: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      if (
        process.env.npm_package_name === 'pseudomap' &&
        process.env.npm_lifecycle_script === 'test'
      )
        process.env.TEST_PSEUDOMAP = 'true'

      if (typeof Map === 'function' && !process.env.TEST_PSEUDOMAP) {
        module.exports = Map
      } else {
        module.exports = __nccwpck_require__(7967)
      }

      /***/
    },

    /***/ 7967: /***/ module => {
      var hasOwnProperty = Object.prototype.hasOwnProperty

      module.exports = PseudoMap

      function PseudoMap(set) {
        if (!(this instanceof PseudoMap))
          // whyyyyyyy
          throw new TypeError("Constructor PseudoMap requires 'new'")

        this.clear()

        if (set) {
          if (
            set instanceof PseudoMap ||
            (typeof Map === 'function' && set instanceof Map)
          )
            set.forEach(function (value, key) {
              this.set(key, value)
            }, this)
          else if (Array.isArray(set))
            set.forEach(function (kv) {
              this.set(kv[0], kv[1])
            }, this)
          else throw new TypeError('invalid argument')
        }
      }

      PseudoMap.prototype.forEach = function (fn, thisp) {
        thisp = thisp || this
        Object.keys(this._data).forEach(function (k) {
          if (k !== 'size')
            fn.call(thisp, this._data[k].value, this._data[k].key)
        }, this)
      }

      PseudoMap.prototype.has = function (k) {
        return !!find(this._data, k)
      }

      PseudoMap.prototype.get = function (k) {
        var res = find(this._data, k)
        return res && res.value
      }

      PseudoMap.prototype.set = function (k, v) {
        set(this._data, k, v)
      }

      PseudoMap.prototype.delete = function (k) {
        var res = find(this._data, k)
        if (res) {
          delete this._data[res._index]
          this._data.size--
        }
      }

      PseudoMap.prototype.clear = function () {
        var data = Object.create(null)
        data.size = 0

        Object.defineProperty(this, '_data', {
          value: data,
          enumerable: false,
          configurable: true,
          writable: false,
        })
      }

      Object.defineProperty(PseudoMap.prototype, 'size', {
        get: function () {
          return this._data.size
        },
        set: function (n) {},
        enumerable: true,
        configurable: true,
      })

      PseudoMap.prototype.values =
        PseudoMap.prototype.keys =
        PseudoMap.prototype.entries =
          function () {
            throw new Error('iterators are not implemented in this version')
          }

      // Either identical, or both NaN
      function same(a, b) {
        return a === b || (a !== a && b !== b)
      }

      function Entry(k, v, i) {
        this.key = k
        this.value = v
        this._index = i
      }

      function find(data, k) {
        for (
          var i = 0, s = '_' + k, key = s;
          hasOwnProperty.call(data, key);
          key = s + i++
        ) {
          if (same(data[key].key, k)) return data[key]
        }
      }

      function set(data, k, v) {
        for (
          var i = 0, s = '_' + k, key = s;
          hasOwnProperty.call(data, key);
          key = s + i++
        ) {
          if (same(data[key].key, k)) {
            data[key].value = v
            return
          }
        }
        data.size++
        data[key] = new Entry(k, v, key)
      }

      /***/
    },

    /***/ 9795: /***/ module => {
      /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
      let promise

      module.exports =
        typeof queueMicrotask === 'function'
          ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)
          : // reuse resolved promise, and allocate it lazily
            cb =>
              (promise || (promise = Promise.resolve())).then(cb).catch(err =>
                setTimeout(() => {
                  throw err
                }, 0)
              )

      /***/
    },

    /***/ 2920: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const fs = __nccwpck_require__(7758)
      const pify = __nccwpck_require__(4810)
      const stripBom = __nccwpck_require__(8551)
      const yaml = __nccwpck_require__(1349)

      const parse = data => yaml.safeLoad(stripBom(data))

      const readYamlFile = fp =>
        pify(fs.readFile)(fp, 'utf8').then(data => parse(data))

      module.exports = readYamlFile
      module.exports['default'] = readYamlFile
      module.exports.sync = fp => parse(fs.readFileSync(fp, 'utf8'))

      /***/
    },

    /***/ 1349: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var yaml = __nccwpck_require__(6240)

      module.exports = yaml

      /***/
    },

    /***/ 6240: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var loader = __nccwpck_require__(7530)
      var dumper = __nccwpck_require__(8231)

      function deprecated(name) {
        return function () {
          throw new Error(
            'Function ' + name + ' is deprecated and cannot be used.'
          )
        }
      }

      module.exports.Type = __nccwpck_require__(6496)
      module.exports.Schema = __nccwpck_require__(3804)
      module.exports.FAILSAFE_SCHEMA = __nccwpck_require__(2925)
      module.exports.JSON_SCHEMA = __nccwpck_require__(9035)
      module.exports.CORE_SCHEMA = __nccwpck_require__(413)
      module.exports.DEFAULT_SAFE_SCHEMA = __nccwpck_require__(6137)
      module.exports.DEFAULT_FULL_SCHEMA = __nccwpck_require__(5460)
      module.exports.load = loader.load
      module.exports.loadAll = loader.loadAll
      module.exports.safeLoad = loader.safeLoad
      module.exports.safeLoadAll = loader.safeLoadAll
      module.exports.dump = dumper.dump
      module.exports.safeDump = dumper.safeDump
      module.exports.YAMLException = __nccwpck_require__(5694)

      // Deprecated schema names from JS-YAML 2.0.x
      module.exports.MINIMAL_SCHEMA = __nccwpck_require__(2925)
      module.exports.SAFE_SCHEMA = __nccwpck_require__(6137)
      module.exports.DEFAULT_SCHEMA = __nccwpck_require__(5460)

      // Deprecated functions from JS-YAML 1.x.x
      module.exports.scan = deprecated('scan')
      module.exports.parse = deprecated('parse')
      module.exports.compose = deprecated('compose')
      module.exports.addConstructor = deprecated('addConstructor')

      /***/
    },

    /***/ 4158: /***/ module => {
      'use strict'

      function isNothing(subject) {
        return typeof subject === 'undefined' || subject === null
      }

      function isObject(subject) {
        return typeof subject === 'object' && subject !== null
      }

      function toArray(sequence) {
        if (Array.isArray(sequence)) return sequence
        else if (isNothing(sequence)) return []

        return [sequence]
      }

      function extend(target, source) {
        var index, length, key, sourceKeys

        if (source) {
          sourceKeys = Object.keys(source)

          for (
            index = 0, length = sourceKeys.length;
            index < length;
            index += 1
          ) {
            key = sourceKeys[index]
            target[key] = source[key]
          }
        }

        return target
      }

      function repeat(string, count) {
        var result = '',
          cycle

        for (cycle = 0; cycle < count; cycle += 1) {
          result += string
        }

        return result
      }

      function isNegativeZero(number) {
        return number === 0 && Number.NEGATIVE_INFINITY === 1 / number
      }

      module.exports.isNothing = isNothing
      module.exports.isObject = isObject
      module.exports.toArray = toArray
      module.exports.repeat = repeat
      module.exports.isNegativeZero = isNegativeZero
      module.exports.extend = extend

      /***/
    },

    /***/ 8231: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      /*eslint-disable no-use-before-define*/

      var common = __nccwpck_require__(4158)
      var YAMLException = __nccwpck_require__(5694)
      var DEFAULT_FULL_SCHEMA = __nccwpck_require__(5460)
      var DEFAULT_SAFE_SCHEMA = __nccwpck_require__(6137)

      var _toString = Object.prototype.toString
      var _hasOwnProperty = Object.prototype.hasOwnProperty

      var CHAR_TAB = 0x09 /* Tab */
      var CHAR_LINE_FEED = 0x0a /* LF */
      var CHAR_CARRIAGE_RETURN = 0x0d /* CR */
      var CHAR_SPACE = 0x20 /* Space */
      var CHAR_EXCLAMATION = 0x21 /* ! */
      var CHAR_DOUBLE_QUOTE = 0x22 /* " */
      var CHAR_SHARP = 0x23 /* # */
      var CHAR_PERCENT = 0x25 /* % */
      var CHAR_AMPERSAND = 0x26 /* & */
      var CHAR_SINGLE_QUOTE = 0x27 /* ' */
      var CHAR_ASTERISK = 0x2a /* * */
      var CHAR_COMMA = 0x2c /* , */
      var CHAR_MINUS = 0x2d /* - */
      var CHAR_COLON = 0x3a /* : */
      var CHAR_EQUALS = 0x3d /* = */
      var CHAR_GREATER_THAN = 0x3e /* > */
      var CHAR_QUESTION = 0x3f /* ? */
      var CHAR_COMMERCIAL_AT = 0x40 /* @ */
      var CHAR_LEFT_SQUARE_BRACKET = 0x5b /* [ */
      var CHAR_RIGHT_SQUARE_BRACKET = 0x5d /* ] */
      var CHAR_GRAVE_ACCENT = 0x60 /* ` */
      var CHAR_LEFT_CURLY_BRACKET = 0x7b /* { */
      var CHAR_VERTICAL_LINE = 0x7c /* | */
      var CHAR_RIGHT_CURLY_BRACKET = 0x7d /* } */

      var ESCAPE_SEQUENCES = {}

      ESCAPE_SEQUENCES[0x00] = '\\0'
      ESCAPE_SEQUENCES[0x07] = '\\a'
      ESCAPE_SEQUENCES[0x08] = '\\b'
      ESCAPE_SEQUENCES[0x09] = '\\t'
      ESCAPE_SEQUENCES[0x0a] = '\\n'
      ESCAPE_SEQUENCES[0x0b] = '\\v'
      ESCAPE_SEQUENCES[0x0c] = '\\f'
      ESCAPE_SEQUENCES[0x0d] = '\\r'
      ESCAPE_SEQUENCES[0x1b] = '\\e'
      ESCAPE_SEQUENCES[0x22] = '\\"'
      ESCAPE_SEQUENCES[0x5c] = '\\\\'
      ESCAPE_SEQUENCES[0x85] = '\\N'
      ESCAPE_SEQUENCES[0xa0] = '\\_'
      ESCAPE_SEQUENCES[0x2028] = '\\L'
      ESCAPE_SEQUENCES[0x2029] = '\\P'

      var DEPRECATED_BOOLEANS_SYNTAX = [
        'y',
        'Y',
        'yes',
        'Yes',
        'YES',
        'on',
        'On',
        'ON',
        'n',
        'N',
        'no',
        'No',
        'NO',
        'off',
        'Off',
        'OFF',
      ]

      function compileStyleMap(schema, map) {
        var result, keys, index, length, tag, style, type

        if (map === null) return {}

        result = {}
        keys = Object.keys(map)

        for (index = 0, length = keys.length; index < length; index += 1) {
          tag = keys[index]
          style = String(map[tag])

          if (tag.slice(0, 2) === '!!') {
            tag = 'tag:yaml.org,2002:' + tag.slice(2)
          }
          type = schema.compiledTypeMap['fallback'][tag]

          if (type && _hasOwnProperty.call(type.styleAliases, style)) {
            style = type.styleAliases[style]
          }

          result[tag] = style
        }

        return result
      }

      function encodeHex(character) {
        var string, handle, length

        string = character.toString(16).toUpperCase()

        if (character <= 0xff) {
          handle = 'x'
          length = 2
        } else if (character <= 0xffff) {
          handle = 'u'
          length = 4
        } else if (character <= 0xffffffff) {
          handle = 'U'
          length = 8
        } else {
          throw new YAMLException(
            'code point within a string may not be greater than 0xFFFFFFFF'
          )
        }

        return (
          '\\' + handle + common.repeat('0', length - string.length) + string
        )
      }

      function State(options) {
        this.schema = options['schema'] || DEFAULT_FULL_SCHEMA
        this.indent = Math.max(1, options['indent'] || 2)
        this.noArrayIndent = options['noArrayIndent'] || false
        this.skipInvalid = options['skipInvalid'] || false
        this.flowLevel = common.isNothing(options['flowLevel'])
          ? -1
          : options['flowLevel']
        this.styleMap = compileStyleMap(this.schema, options['styles'] || null)
        this.sortKeys = options['sortKeys'] || false
        this.lineWidth = options['lineWidth'] || 80
        this.noRefs = options['noRefs'] || false
        this.noCompatMode = options['noCompatMode'] || false
        this.condenseFlow = options['condenseFlow'] || false

        this.implicitTypes = this.schema.compiledImplicit
        this.explicitTypes = this.schema.compiledExplicit

        this.tag = null
        this.result = ''

        this.duplicates = []
        this.usedDuplicates = null
      }

      // Indents every line in a string. Empty lines (\n only) are not indented.
      function indentString(string, spaces) {
        var ind = common.repeat(' ', spaces),
          position = 0,
          next = -1,
          result = '',
          line,
          length = string.length

        while (position < length) {
          next = string.indexOf('\n', position)
          if (next === -1) {
            line = string.slice(position)
            position = length
          } else {
            line = string.slice(position, next + 1)
            position = next + 1
          }

          if (line.length && line !== '\n') result += ind

          result += line
        }

        return result
      }

      function generateNextLine(state, level) {
        return '\n' + common.repeat(' ', state.indent * level)
      }

      function testImplicitResolving(state, str) {
        var index, length, type

        for (
          index = 0, length = state.implicitTypes.length;
          index < length;
          index += 1
        ) {
          type = state.implicitTypes[index]

          if (type.resolve(str)) {
            return true
          }
        }

        return false
      }

      // [33] s-white ::= s-space | s-tab
      function isWhitespace(c) {
        return c === CHAR_SPACE || c === CHAR_TAB
      }

      // Returns true if the character can be printed without escaping.
      // From YAML 1.2: "any allowed characters known to be non-printable
      // should also be escaped. [However,] This isn’t mandatory"
      // Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
      function isPrintable(c) {
        return (
          (0x00020 <= c && c <= 0x00007e) ||
          (0x000a1 <= c && c <= 0x00d7ff && c !== 0x2028 && c !== 0x2029) ||
          (0x0e000 <= c && c <= 0x00fffd && c !== 0xfeff) /* BOM */ ||
          (0x10000 <= c && c <= 0x10ffff)
        )
      }

      // [34] ns-char ::= nb-char - s-white
      // [27] nb-char ::= c-printable - b-char - c-byte-order-mark
      // [26] b-char  ::= b-line-feed | b-carriage-return
      // [24] b-line-feed       ::=     #xA    /* LF */
      // [25] b-carriage-return ::=     #xD    /* CR */
      // [3]  c-byte-order-mark ::=     #xFEFF
      function isNsChar(c) {
        return (
          isPrintable(c) &&
          !isWhitespace(c) &&
          // byte-order-mark
          c !== 0xfeff &&
          // b-char
          c !== CHAR_CARRIAGE_RETURN &&
          c !== CHAR_LINE_FEED
        )
      }

      // Simplified test for values allowed after the first character in plain style.
      function isPlainSafe(c, prev) {
        // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
        // where nb-char ::= c-printable - b-char - c-byte-order-mark.
        return (
          isPrintable(c) &&
          c !== 0xfeff &&
          // - c-flow-indicator
          c !== CHAR_COMMA &&
          c !== CHAR_LEFT_SQUARE_BRACKET &&
          c !== CHAR_RIGHT_SQUARE_BRACKET &&
          c !== CHAR_LEFT_CURLY_BRACKET &&
          c !== CHAR_RIGHT_CURLY_BRACKET &&
          // - ":" - "#"
          // /* An ns-char preceding */ "#"
          c !== CHAR_COLON &&
          (c !== CHAR_SHARP || (prev && isNsChar(prev)))
        )
      }

      // Simplified test for values allowed as the first character in plain style.
      function isPlainSafeFirst(c) {
        // Uses a subset of ns-char - c-indicator
        // where ns-char = nb-char - s-white.
        return (
          isPrintable(c) &&
          c !== 0xfeff &&
          !isWhitespace(c) && // - s-white
          // - (c-indicator ::=
          // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
          c !== CHAR_MINUS &&
          c !== CHAR_QUESTION &&
          c !== CHAR_COLON &&
          c !== CHAR_COMMA &&
          c !== CHAR_LEFT_SQUARE_BRACKET &&
          c !== CHAR_RIGHT_SQUARE_BRACKET &&
          c !== CHAR_LEFT_CURLY_BRACKET &&
          c !== CHAR_RIGHT_CURLY_BRACKET &&
          // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “"”
          c !== CHAR_SHARP &&
          c !== CHAR_AMPERSAND &&
          c !== CHAR_ASTERISK &&
          c !== CHAR_EXCLAMATION &&
          c !== CHAR_VERTICAL_LINE &&
          c !== CHAR_EQUALS &&
          c !== CHAR_GREATER_THAN &&
          c !== CHAR_SINGLE_QUOTE &&
          c !== CHAR_DOUBLE_QUOTE &&
          // | “%” | “@” | “`”)
          c !== CHAR_PERCENT &&
          c !== CHAR_COMMERCIAL_AT &&
          c !== CHAR_GRAVE_ACCENT
        )
      }

      // Determines whether block indentation indicator is required.
      function needIndentIndicator(string) {
        var leadingSpaceRe = /^\n* /
        return leadingSpaceRe.test(string)
      }

      var STYLE_PLAIN = 1,
        STYLE_SINGLE = 2,
        STYLE_LITERAL = 3,
        STYLE_FOLDED = 4,
        STYLE_DOUBLE = 5

      // Determines which scalar styles are possible and returns the preferred style.
      // lineWidth = -1 => no limit.
      // Pre-conditions: str.length > 0.
      // Post-conditions:
      //    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
      //    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
      //    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
      function chooseScalarStyle(
        string,
        singleLineOnly,
        indentPerLevel,
        lineWidth,
        testAmbiguousType
      ) {
        var i
        var char, prev_char
        var hasLineBreak = false
        var hasFoldableLine = false // only checked if shouldTrackWidth
        var shouldTrackWidth = lineWidth !== -1
        var previousLineBreak = -1 // count the first line correctly
        var plain =
          isPlainSafeFirst(string.charCodeAt(0)) &&
          !isWhitespace(string.charCodeAt(string.length - 1))

        if (singleLineOnly) {
          // Case: no block styles.
          // Check for disallowed characters to rule out plain and single.
          for (i = 0; i < string.length; i++) {
            char = string.charCodeAt(i)
            if (!isPrintable(char)) {
              return STYLE_DOUBLE
            }
            prev_char = i > 0 ? string.charCodeAt(i - 1) : null
            plain = plain && isPlainSafe(char, prev_char)
          }
        } else {
          // Case: block styles permitted.
          for (i = 0; i < string.length; i++) {
            char = string.charCodeAt(i)
            if (char === CHAR_LINE_FEED) {
              hasLineBreak = true
              // Check if any line can be folded.
              if (shouldTrackWidth) {
                hasFoldableLine =
                  hasFoldableLine ||
                  // Foldable line = too long, and not more-indented.
                  (i - previousLineBreak - 1 > lineWidth &&
                    string[previousLineBreak + 1] !== ' ')
                previousLineBreak = i
              }
            } else if (!isPrintable(char)) {
              return STYLE_DOUBLE
            }
            prev_char = i > 0 ? string.charCodeAt(i - 1) : null
            plain = plain && isPlainSafe(char, prev_char)
          }
          // in case the end is missing a \n
          hasFoldableLine =
            hasFoldableLine ||
            (shouldTrackWidth &&
              i - previousLineBreak - 1 > lineWidth &&
              string[previousLineBreak + 1] !== ' ')
        }
        // Although every style can represent \n without escaping, prefer block styles
        // for multiline, since they're more readable and they don't add empty lines.
        // Also prefer folding a super-long line.
        if (!hasLineBreak && !hasFoldableLine) {
          // Strings interpretable as another type have to be quoted;
          // e.g. the string 'true' vs. the boolean true.
          return plain && !testAmbiguousType(string)
            ? STYLE_PLAIN
            : STYLE_SINGLE
        }
        // Edge case: block indentation indicator can only have one digit.
        if (indentPerLevel > 9 && needIndentIndicator(string)) {
          return STYLE_DOUBLE
        }
        // At this point we know block styles are valid.
        // Prefer literal style unless we want to fold.
        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL
      }

      // Note: line breaking/folding is implemented for only the folded style.
      // NB. We drop the last trailing newline (if any) of a returned block scalar
      //  since the dumper adds its own newline. This always works:
      //    • No ending newline => unaffected; already using strip "-" chomping.
      //    • Ending newline    => removed then restored.
      //  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
      function writeScalar(state, string, level, iskey) {
        state.dump = (function () {
          if (string.length === 0) {
            return "''"
          }
          if (
            !state.noCompatMode &&
            DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1
          ) {
            return "'" + string + "'"
          }

          var indent = state.indent * Math.max(1, level) // no 0-indent scalars
          // As indentation gets deeper, let the width decrease monotonically
          // to the lower bound min(state.lineWidth, 40).
          // Note that this implies
          //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
          //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
          // This behaves better than a constant minimum width which disallows narrower options,
          // or an indent threshold which causes the width to suddenly increase.
          var lineWidth =
            state.lineWidth === -1
              ? -1
              : Math.max(
                  Math.min(state.lineWidth, 40),
                  state.lineWidth - indent
                )

          // Without knowing if keys are implicit/explicit, assume implicit for safety.
          var singleLineOnly =
            iskey ||
            // No block styles in flow mode.
            (state.flowLevel > -1 && level >= state.flowLevel)
          function testAmbiguity(string) {
            return testImplicitResolving(state, string)
          }

          switch (
            chooseScalarStyle(
              string,
              singleLineOnly,
              state.indent,
              lineWidth,
              testAmbiguity
            )
          ) {
            case STYLE_PLAIN:
              return string
            case STYLE_SINGLE:
              return "'" + string.replace(/'/g, "''") + "'"
            case STYLE_LITERAL:
              return (
                '|' +
                blockHeader(string, state.indent) +
                dropEndingNewline(indentString(string, indent))
              )
            case STYLE_FOLDED:
              return (
                '>' +
                blockHeader(string, state.indent) +
                dropEndingNewline(
                  indentString(foldString(string, lineWidth), indent)
                )
              )
            case STYLE_DOUBLE:
              return '"' + escapeString(string, lineWidth) + '"'
            default:
              throw new YAMLException('impossible error: invalid scalar style')
          }
        })()
      }

      // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
      function blockHeader(string, indentPerLevel) {
        var indentIndicator = needIndentIndicator(string)
          ? String(indentPerLevel)
          : ''

        // note the special case: the string '\n' counts as a "trailing" empty line.
        var clip = string[string.length - 1] === '\n'
        var keep =
          clip && (string[string.length - 2] === '\n' || string === '\n')
        var chomp = keep ? '+' : clip ? '' : '-'

        return indentIndicator + chomp + '\n'
      }

      // (See the note for writeScalar.)
      function dropEndingNewline(string) {
        return string[string.length - 1] === '\n' ? string.slice(0, -1) : string
      }

      // Note: a long line without a suitable break point will exceed the width limit.
      // Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
      function foldString(string, width) {
        // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
        // unless they're before or after a more-indented line, or at the very
        // beginning or end, in which case $k$ maps to $k$.
        // Therefore, parse each chunk as newline(s) followed by a content line.
        var lineRe = /(\n+)([^\n]*)/g

        // first line (possibly an empty line)
        var result = (function () {
          var nextLF = string.indexOf('\n')
          nextLF = nextLF !== -1 ? nextLF : string.length
          lineRe.lastIndex = nextLF
          return foldLine(string.slice(0, nextLF), width)
        })()
        // If we haven't reached the first content line yet, don't add an extra \n.
        var prevMoreIndented = string[0] === '\n' || string[0] === ' '
        var moreIndented

        // rest of the lines
        var match
        while ((match = lineRe.exec(string))) {
          var prefix = match[1],
            line = match[2]
          moreIndented = line[0] === ' '
          result +=
            prefix +
            (!prevMoreIndented && !moreIndented && line !== '' ? '\n' : '') +
            foldLine(line, width)
          prevMoreIndented = moreIndented
        }

        return result
      }

      // Greedy line breaking.
      // Picks the longest line under the limit each time,
      // otherwise settles for the shortest line over the limit.
      // NB. More-indented lines *cannot* be folded, as that would add an extra \n.
      function foldLine(line, width) {
        if (line === '' || line[0] === ' ') return line

        // Since a more-indented line adds a \n, breaks can't be followed by a space.
        var breakRe = / [^ ]/g // note: the match index will always be <= length-2.
        var match
        // start is an inclusive index. end, curr, and next are exclusive.
        var start = 0,
          end,
          curr = 0,
          next = 0
        var result = ''

        // Invariants: 0 <= start <= length-1.
        //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
        // Inside the loop:
        //   A match implies length >= 2, so curr and next are <= length-2.
        while ((match = breakRe.exec(line))) {
          next = match.index
          // maintain invariant: curr - start <= width
          if (next - start > width) {
            end = curr > start ? curr : next // derive end <= length-2
            result += '\n' + line.slice(start, end)
            // skip the space that was output as \n
            start = end + 1 // derive start <= length-1
          }
          curr = next
        }

        // By the invariants, start <= length-1, so there is something left over.
        // It is either the whole string or a part starting from non-whitespace.
        result += '\n'
        // Insert a break if the remainder is too long and there is a break available.
        if (line.length - start > width && curr > start) {
          result += line.slice(start, curr) + '\n' + line.slice(curr + 1)
        } else {
          result += line.slice(start)
        }

        return result.slice(1) // drop extra \n joiner
      }

      // Escapes a double-quoted string.
      function escapeString(string) {
        var result = ''
        var char, nextChar
        var escapeSeq

        for (var i = 0; i < string.length; i++) {
          char = string.charCodeAt(i)
          // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
          if (char >= 0xd800 && char <= 0xdbff /* high surrogate */) {
            nextChar = string.charCodeAt(i + 1)
            if (nextChar >= 0xdc00 && nextChar <= 0xdfff /* low surrogate */) {
              // Combine the surrogate pair and store it escaped.
              result += encodeHex(
                (char - 0xd800) * 0x400 + nextChar - 0xdc00 + 0x10000
              )
              // Advance index one extra since we already used that char here.
              i++
              continue
            }
          }
          escapeSeq = ESCAPE_SEQUENCES[char]
          result +=
            !escapeSeq && isPrintable(char)
              ? string[i]
              : escapeSeq || encodeHex(char)
        }

        return result
      }

      function writeFlowSequence(state, level, object) {
        var _result = '',
          _tag = state.tag,
          index,
          length

        for (index = 0, length = object.length; index < length; index += 1) {
          // Write only valid elements.
          if (writeNode(state, level, object[index], false, false)) {
            if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '')
            _result += state.dump
          }
        }

        state.tag = _tag
        state.dump = '[' + _result + ']'
      }

      function writeBlockSequence(state, level, object, compact) {
        var _result = '',
          _tag = state.tag,
          index,
          length

        for (index = 0, length = object.length; index < length; index += 1) {
          // Write only valid elements.
          if (writeNode(state, level + 1, object[index], true, true)) {
            if (!compact || index !== 0) {
              _result += generateNextLine(state, level)
            }

            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
              _result += '-'
            } else {
              _result += '- '
            }

            _result += state.dump
          }
        }

        state.tag = _tag
        state.dump = _result || '[]' // Empty sequence if no valid values.
      }

      function writeFlowMapping(state, level, object) {
        var _result = '',
          _tag = state.tag,
          objectKeyList = Object.keys(object),
          index,
          length,
          objectKey,
          objectValue,
          pairBuffer

        for (
          index = 0, length = objectKeyList.length;
          index < length;
          index += 1
        ) {
          pairBuffer = ''
          if (index !== 0) pairBuffer += ', '

          if (state.condenseFlow) pairBuffer += '"'

          objectKey = objectKeyList[index]
          objectValue = object[objectKey]

          if (!writeNode(state, level, objectKey, false, false)) {
            continue // Skip this pair because of invalid key;
          }

          if (state.dump.length > 1024) pairBuffer += '? '

          pairBuffer +=
            state.dump +
            (state.condenseFlow ? '"' : '') +
            ':' +
            (state.condenseFlow ? '' : ' ')

          if (!writeNode(state, level, objectValue, false, false)) {
            continue // Skip this pair because of invalid value.
          }

          pairBuffer += state.dump

          // Both key and value are valid.
          _result += pairBuffer
        }

        state.tag = _tag
        state.dump = '{' + _result + '}'
      }

      function writeBlockMapping(state, level, object, compact) {
        var _result = '',
          _tag = state.tag,
          objectKeyList = Object.keys(object),
          index,
          length,
          objectKey,
          objectValue,
          explicitPair,
          pairBuffer

        // Allow sorting keys so that the output file is deterministic
        if (state.sortKeys === true) {
          // Default sorting
          objectKeyList.sort()
        } else if (typeof state.sortKeys === 'function') {
          // Custom sort function
          objectKeyList.sort(state.sortKeys)
        } else if (state.sortKeys) {
          // Something is wrong
          throw new YAMLException('sortKeys must be a boolean or a function')
        }

        for (
          index = 0, length = objectKeyList.length;
          index < length;
          index += 1
        ) {
          pairBuffer = ''

          if (!compact || index !== 0) {
            pairBuffer += generateNextLine(state, level)
          }

          objectKey = objectKeyList[index]
          objectValue = object[objectKey]

          if (!writeNode(state, level + 1, objectKey, true, true, true)) {
            continue // Skip this pair because of invalid key.
          }

          explicitPair =
            (state.tag !== null && state.tag !== '?') ||
            (state.dump && state.dump.length > 1024)

          if (explicitPair) {
            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
              pairBuffer += '?'
            } else {
              pairBuffer += '? '
            }
          }

          pairBuffer += state.dump

          if (explicitPair) {
            pairBuffer += generateNextLine(state, level)
          }

          if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
            continue // Skip this pair because of invalid value.
          }

          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += ':'
          } else {
            pairBuffer += ': '
          }

          pairBuffer += state.dump

          // Both key and value are valid.
          _result += pairBuffer
        }

        state.tag = _tag
        state.dump = _result || '{}' // Empty mapping if no valid pairs.
      }

      function detectType(state, object, explicit) {
        var _result, typeList, index, length, type, style

        typeList = explicit ? state.explicitTypes : state.implicitTypes

        for (index = 0, length = typeList.length; index < length; index += 1) {
          type = typeList[index]

          if (
            (type.instanceOf || type.predicate) &&
            (!type.instanceOf ||
              (typeof object === 'object' &&
                object instanceof type.instanceOf)) &&
            (!type.predicate || type.predicate(object))
          ) {
            state.tag = explicit ? type.tag : '?'

            if (type.represent) {
              style = state.styleMap[type.tag] || type.defaultStyle

              if (_toString.call(type.represent) === '[object Function]') {
                _result = type.represent(object, style)
              } else if (_hasOwnProperty.call(type.represent, style)) {
                _result = type.represent[style](object, style)
              } else {
                throw new YAMLException(
                  '!<' +
                    type.tag +
                    '> tag resolver accepts not "' +
                    style +
                    '" style'
                )
              }

              state.dump = _result
            }

            return true
          }
        }

        return false
      }

      // Serializes `object` and writes it to global `result`.
      // Returns true on success, or false on invalid object.
      //
      function writeNode(state, level, object, block, compact, iskey) {
        state.tag = null
        state.dump = object

        if (!detectType(state, object, false)) {
          detectType(state, object, true)
        }

        var type = _toString.call(state.dump)

        if (block) {
          block = state.flowLevel < 0 || state.flowLevel > level
        }

        var objectOrArray =
            type === '[object Object]' || type === '[object Array]',
          duplicateIndex,
          duplicate

        if (objectOrArray) {
          duplicateIndex = state.duplicates.indexOf(object)
          duplicate = duplicateIndex !== -1
        }

        if (
          (state.tag !== null && state.tag !== '?') ||
          duplicate ||
          (state.indent !== 2 && level > 0)
        ) {
          compact = false
        }

        if (duplicate && state.usedDuplicates[duplicateIndex]) {
          state.dump = '*ref_' + duplicateIndex
        } else {
          if (
            objectOrArray &&
            duplicate &&
            !state.usedDuplicates[duplicateIndex]
          ) {
            state.usedDuplicates[duplicateIndex] = true
          }
          if (type === '[object Object]') {
            if (block && Object.keys(state.dump).length !== 0) {
              writeBlockMapping(state, level, state.dump, compact)
              if (duplicate) {
                state.dump = '&ref_' + duplicateIndex + state.dump
              }
            } else {
              writeFlowMapping(state, level, state.dump)
              if (duplicate) {
                state.dump = '&ref_' + duplicateIndex + ' ' + state.dump
              }
            }
          } else if (type === '[object Array]') {
            var arrayLevel =
              state.noArrayIndent && level > 0 ? level - 1 : level
            if (block && state.dump.length !== 0) {
              writeBlockSequence(state, arrayLevel, state.dump, compact)
              if (duplicate) {
                state.dump = '&ref_' + duplicateIndex + state.dump
              }
            } else {
              writeFlowSequence(state, arrayLevel, state.dump)
              if (duplicate) {
                state.dump = '&ref_' + duplicateIndex + ' ' + state.dump
              }
            }
          } else if (type === '[object String]') {
            if (state.tag !== '?') {
              writeScalar(state, state.dump, level, iskey)
            }
          } else {
            if (state.skipInvalid) return false
            throw new YAMLException(
              'unacceptable kind of an object to dump ' + type
            )
          }

          if (state.tag !== null && state.tag !== '?') {
            state.dump = '!<' + state.tag + '> ' + state.dump
          }
        }

        return true
      }

      function getDuplicateReferences(object, state) {
        var objects = [],
          duplicatesIndexes = [],
          index,
          length

        inspectNode(object, objects, duplicatesIndexes)

        for (
          index = 0, length = duplicatesIndexes.length;
          index < length;
          index += 1
        ) {
          state.duplicates.push(objects[duplicatesIndexes[index]])
        }
        state.usedDuplicates = new Array(length)
      }

      function inspectNode(object, objects, duplicatesIndexes) {
        var objectKeyList, index, length

        if (object !== null && typeof object === 'object') {
          index = objects.indexOf(object)
          if (index !== -1) {
            if (duplicatesIndexes.indexOf(index) === -1) {
              duplicatesIndexes.push(index)
            }
          } else {
            objects.push(object)

            if (Array.isArray(object)) {
              for (
                index = 0, length = object.length;
                index < length;
                index += 1
              ) {
                inspectNode(object[index], objects, duplicatesIndexes)
              }
            } else {
              objectKeyList = Object.keys(object)

              for (
                index = 0, length = objectKeyList.length;
                index < length;
                index += 1
              ) {
                inspectNode(
                  object[objectKeyList[index]],
                  objects,
                  duplicatesIndexes
                )
              }
            }
          }
        }
      }

      function dump(input, options) {
        options = options || {}

        var state = new State(options)

        if (!state.noRefs) getDuplicateReferences(input, state)

        if (writeNode(state, 0, input, true, true)) return state.dump + '\n'

        return ''
      }

      function safeDump(input, options) {
        return dump(
          input,
          common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options)
        )
      }

      module.exports.dump = dump
      module.exports.safeDump = safeDump

      /***/
    },

    /***/ 5694: /***/ module => {
      'use strict'
      // YAML error class. http://stackoverflow.com/questions/8458984
      //

      function YAMLException(reason, mark) {
        // Super constructor
        Error.call(this)

        this.name = 'YAMLException'
        this.reason = reason
        this.mark = mark
        this.message =
          (this.reason || '(unknown reason)') +
          (this.mark ? ' ' + this.mark.toString() : '')

        // Include stack trace in error object
        if (Error.captureStackTrace) {
          // Chrome and NodeJS
          Error.captureStackTrace(this, this.constructor)
        } else {
          // FF, IE 10+ and Safari 6+. Fallback for others
          this.stack = new Error().stack || ''
        }
      }

      // Inherit from Error
      YAMLException.prototype = Object.create(Error.prototype)
      YAMLException.prototype.constructor = YAMLException

      YAMLException.prototype.toString = function toString(compact) {
        var result = this.name + ': '

        result += this.reason || '(unknown reason)'

        if (!compact && this.mark) {
          result += ' ' + this.mark.toString()
        }

        return result
      }

      module.exports = YAMLException

      /***/
    },

    /***/ 7530: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      /*eslint-disable max-len,no-use-before-define*/

      var common = __nccwpck_require__(4158)
      var YAMLException = __nccwpck_require__(5694)
      var Mark = __nccwpck_require__(8770)
      var DEFAULT_SAFE_SCHEMA = __nccwpck_require__(6137)
      var DEFAULT_FULL_SCHEMA = __nccwpck_require__(5460)

      var _hasOwnProperty = Object.prototype.hasOwnProperty

      var CONTEXT_FLOW_IN = 1
      var CONTEXT_FLOW_OUT = 2
      var CONTEXT_BLOCK_IN = 3
      var CONTEXT_BLOCK_OUT = 4

      var CHOMPING_CLIP = 1
      var CHOMPING_STRIP = 2
      var CHOMPING_KEEP = 3

      var PATTERN_NON_PRINTABLE =
        /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/
      var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/
      var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/
      var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i
      var PATTERN_TAG_URI =
        /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i

      function _class(obj) {
        return Object.prototype.toString.call(obj)
      }

      function is_EOL(c) {
        return c === 0x0a /* LF */ || c === 0x0d /* CR */
      }

      function is_WHITE_SPACE(c) {
        return c === 0x09 /* Tab */ || c === 0x20 /* Space */
      }

      function is_WS_OR_EOL(c) {
        return (
          c === 0x09 /* Tab */ ||
          c === 0x20 /* Space */ ||
          c === 0x0a /* LF */ ||
          c === 0x0d /* CR */
        )
      }

      function is_FLOW_INDICATOR(c) {
        return (
          c === 0x2c /* , */ ||
          c === 0x5b /* [ */ ||
          c === 0x5d /* ] */ ||
          c === 0x7b /* { */ ||
          c === 0x7d /* } */
        )
      }

      function fromHexCode(c) {
        var lc

        if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
          return c - 0x30
        }

        /*eslint-disable no-bitwise*/
        lc = c | 0x20

        if (0x61 /* a */ <= lc && lc <= 0x66 /* f */) {
          return lc - 0x61 + 10
        }

        return -1
      }

      function escapedHexLen(c) {
        if (c === 0x78 /* x */) {
          return 2
        }
        if (c === 0x75 /* u */) {
          return 4
        }
        if (c === 0x55 /* U */) {
          return 8
        }
        return 0
      }

      function fromDecimalCode(c) {
        if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
          return c - 0x30
        }

        return -1
      }

      function simpleEscapeSequence(c) {
        /* eslint-disable indent */
        return c === 0x30 /* 0 */
          ? '\x00'
          : c === 0x61 /* a */
          ? '\x07'
          : c === 0x62 /* b */
          ? '\x08'
          : c === 0x74 /* t */
          ? '\x09'
          : c === 0x09 /* Tab */
          ? '\x09'
          : c === 0x6e /* n */
          ? '\x0A'
          : c === 0x76 /* v */
          ? '\x0B'
          : c === 0x66 /* f */
          ? '\x0C'
          : c === 0x72 /* r */
          ? '\x0D'
          : c === 0x65 /* e */
          ? '\x1B'
          : c === 0x20 /* Space */
          ? ' '
          : c === 0x22 /* " */
          ? '\x22'
          : c === 0x2f /* / */
          ? '/'
          : c === 0x5c /* \ */
          ? '\x5C'
          : c === 0x4e /* N */
          ? '\x85'
          : c === 0x5f /* _ */
          ? '\xA0'
          : c === 0x4c /* L */
          ? '\u2028'
          : c === 0x50 /* P */
          ? '\u2029'
          : ''
      }

      function charFromCodepoint(c) {
        if (c <= 0xffff) {
          return String.fromCharCode(c)
        }
        // Encode UTF-16 surrogate pair
        // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
        return String.fromCharCode(
          ((c - 0x010000) >> 10) + 0xd800,
          ((c - 0x010000) & 0x03ff) + 0xdc00
        )
      }

      var simpleEscapeCheck = new Array(256) // integer, for fast access
      var simpleEscapeMap = new Array(256)
      for (var i = 0; i < 256; i++) {
        simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0
        simpleEscapeMap[i] = simpleEscapeSequence(i)
      }

      function State(input, options) {
        this.input = input

        this.filename = options['filename'] || null
        this.schema = options['schema'] || DEFAULT_FULL_SCHEMA
        this.onWarning = options['onWarning'] || null
        this.legacy = options['legacy'] || false
        this.json = options['json'] || false
        this.listener = options['listener'] || null

        this.implicitTypes = this.schema.compiledImplicit
        this.typeMap = this.schema.compiledTypeMap

        this.length = input.length
        this.position = 0
        this.line = 0
        this.lineStart = 0
        this.lineIndent = 0

        this.documents = []

        /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/
      }

      function generateError(state, message) {
        return new YAMLException(
          message,
          new Mark(
            state.filename,
            state.input,
            state.position,
            state.line,
            state.position - state.lineStart
          )
        )
      }

      function throwError(state, message) {
        throw generateError(state, message)
      }

      function throwWarning(state, message) {
        if (state.onWarning) {
          state.onWarning.call(null, generateError(state, message))
        }
      }

      var directiveHandlers = {
        YAML: function handleYamlDirective(state, name, args) {
          var match, major, minor

          if (state.version !== null) {
            throwError(state, 'duplication of %YAML directive')
          }

          if (args.length !== 1) {
            throwError(state, 'YAML directive accepts exactly one argument')
          }

          match = /^([0-9]+)\.([0-9]+)$/.exec(args[0])

          if (match === null) {
            throwError(state, 'ill-formed argument of the YAML directive')
          }

          major = parseInt(match[1], 10)
          minor = parseInt(match[2], 10)

          if (major !== 1) {
            throwError(state, 'unacceptable YAML version of the document')
          }

          state.version = args[0]
          state.checkLineBreaks = minor < 2

          if (minor !== 1 && minor !== 2) {
            throwWarning(state, 'unsupported YAML version of the document')
          }
        },

        TAG: function handleTagDirective(state, name, args) {
          var handle, prefix

          if (args.length !== 2) {
            throwError(state, 'TAG directive accepts exactly two arguments')
          }

          handle = args[0]
          prefix = args[1]

          if (!PATTERN_TAG_HANDLE.test(handle)) {
            throwError(
              state,
              'ill-formed tag handle (first argument) of the TAG directive'
            )
          }

          if (_hasOwnProperty.call(state.tagMap, handle)) {
            throwError(
              state,
              'there is a previously declared suffix for "' +
                handle +
                '" tag handle'
            )
          }

          if (!PATTERN_TAG_URI.test(prefix)) {
            throwError(
              state,
              'ill-formed tag prefix (second argument) of the TAG directive'
            )
          }

          state.tagMap[handle] = prefix
        },
      }

      function captureSegment(state, start, end, checkJson) {
        var _position, _length, _character, _result

        if (start < end) {
          _result = state.input.slice(start, end)

          if (checkJson) {
            for (
              _position = 0, _length = _result.length;
              _position < _length;
              _position += 1
            ) {
              _character = _result.charCodeAt(_position)
              if (
                !(
                  _character === 0x09 ||
                  (0x20 <= _character && _character <= 0x10ffff)
                )
              ) {
                throwError(state, 'expected valid JSON character')
              }
            }
          } else if (PATTERN_NON_PRINTABLE.test(_result)) {
            throwError(state, 'the stream contains non-printable characters')
          }

          state.result += _result
        }
      }

      function mergeMappings(state, destination, source, overridableKeys) {
        var sourceKeys, key, index, quantity

        if (!common.isObject(source)) {
          throwError(
            state,
            'cannot merge mappings; the provided source object is unacceptable'
          )
        }

        sourceKeys = Object.keys(source)

        for (
          index = 0, quantity = sourceKeys.length;
          index < quantity;
          index += 1
        ) {
          key = sourceKeys[index]

          if (!_hasOwnProperty.call(destination, key)) {
            destination[key] = source[key]
            overridableKeys[key] = true
          }
        }
      }

      function storeMappingPair(
        state,
        _result,
        overridableKeys,
        keyTag,
        keyNode,
        valueNode,
        startLine,
        startPos
      ) {
        var index, quantity

        // The output is a plain object here, so keys can only be strings.
        // We need to convert keyNode to a string, but doing so can hang the process
        // (deeply nested arrays that explode exponentially using aliases).
        if (Array.isArray(keyNode)) {
          keyNode = Array.prototype.slice.call(keyNode)

          for (
            index = 0, quantity = keyNode.length;
            index < quantity;
            index += 1
          ) {
            if (Array.isArray(keyNode[index])) {
              throwError(state, 'nested arrays are not supported inside keys')
            }

            if (
              typeof keyNode === 'object' &&
              _class(keyNode[index]) === '[object Object]'
            ) {
              keyNode[index] = '[object Object]'
            }
          }
        }

        // Avoid code execution in load() via toString property
        // (still use its own toString for arrays, timestamps,
        // and whatever user schema extensions happen to have @@toStringTag)
        if (
          typeof keyNode === 'object' &&
          _class(keyNode) === '[object Object]'
        ) {
          keyNode = '[object Object]'
        }

        keyNode = String(keyNode)

        if (_result === null) {
          _result = {}
        }

        if (keyTag === 'tag:yaml.org,2002:merge') {
          if (Array.isArray(valueNode)) {
            for (
              index = 0, quantity = valueNode.length;
              index < quantity;
              index += 1
            ) {
              mergeMappings(state, _result, valueNode[index], overridableKeys)
            }
          } else {
            mergeMappings(state, _result, valueNode, overridableKeys)
          }
        } else {
          if (
            !state.json &&
            !_hasOwnProperty.call(overridableKeys, keyNode) &&
            _hasOwnProperty.call(_result, keyNode)
          ) {
            state.line = startLine || state.line
            state.position = startPos || state.position
            throwError(state, 'duplicated mapping key')
          }
          _result[keyNode] = valueNode
          delete overridableKeys[keyNode]
        }

        return _result
      }

      function readLineBreak(state) {
        var ch

        ch = state.input.charCodeAt(state.position)

        if (ch === 0x0a /* LF */) {
          state.position++
        } else if (ch === 0x0d /* CR */) {
          state.position++
          if (state.input.charCodeAt(state.position) === 0x0a /* LF */) {
            state.position++
          }
        } else {
          throwError(state, 'a line break is expected')
        }

        state.line += 1
        state.lineStart = state.position
      }

      function skipSeparationSpace(state, allowComments, checkIndent) {
        var lineBreaks = 0,
          ch = state.input.charCodeAt(state.position)

        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position)
          }

          if (allowComments && ch === 0x23 /* # */) {
            do {
              ch = state.input.charCodeAt(++state.position)
            } while (ch !== 0x0a /* LF */ && ch !== 0x0d /* CR */ && ch !== 0)
          }

          if (is_EOL(ch)) {
            readLineBreak(state)

            ch = state.input.charCodeAt(state.position)
            lineBreaks++
            state.lineIndent = 0

            while (ch === 0x20 /* Space */) {
              state.lineIndent++
              ch = state.input.charCodeAt(++state.position)
            }
          } else {
            break
          }
        }

        if (
          checkIndent !== -1 &&
          lineBreaks !== 0 &&
          state.lineIndent < checkIndent
        ) {
          throwWarning(state, 'deficient indentation')
        }

        return lineBreaks
      }

      function testDocumentSeparator(state) {
        var _position = state.position,
          ch

        ch = state.input.charCodeAt(_position)

        // Condition state.position === state.lineStart is tested
        // in parent on each call, for efficiency. No needs to test here again.
        if (
          (ch === 0x2d /* - */ || ch === 0x2e) /* . */ &&
          ch === state.input.charCodeAt(_position + 1) &&
          ch === state.input.charCodeAt(_position + 2)
        ) {
          _position += 3

          ch = state.input.charCodeAt(_position)

          if (ch === 0 || is_WS_OR_EOL(ch)) {
            return true
          }
        }

        return false
      }

      function writeFoldedLines(state, count) {
        if (count === 1) {
          state.result += ' '
        } else if (count > 1) {
          state.result += common.repeat('\n', count - 1)
        }
      }

      function readPlainScalar(state, nodeIndent, withinFlowCollection) {
        var preceding,
          following,
          captureStart,
          captureEnd,
          hasPendingContent,
          _line,
          _lineStart,
          _lineIndent,
          _kind = state.kind,
          _result = state.result,
          ch

        ch = state.input.charCodeAt(state.position)

        if (
          is_WS_OR_EOL(ch) ||
          is_FLOW_INDICATOR(ch) ||
          ch === 0x23 /* # */ ||
          ch === 0x26 /* & */ ||
          ch === 0x2a /* * */ ||
          ch === 0x21 /* ! */ ||
          ch === 0x7c /* | */ ||
          ch === 0x3e /* > */ ||
          ch === 0x27 /* ' */ ||
          ch === 0x22 /* " */ ||
          ch === 0x25 /* % */ ||
          ch === 0x40 /* @ */ ||
          ch === 0x60 /* ` */
        ) {
          return false
        }

        if (ch === 0x3f /* ? */ || ch === 0x2d /* - */) {
          following = state.input.charCodeAt(state.position + 1)

          if (
            is_WS_OR_EOL(following) ||
            (withinFlowCollection && is_FLOW_INDICATOR(following))
          ) {
            return false
          }
        }

        state.kind = 'scalar'
        state.result = ''
        captureStart = captureEnd = state.position
        hasPendingContent = false

        while (ch !== 0) {
          if (ch === 0x3a /* : */) {
            following = state.input.charCodeAt(state.position + 1)

            if (
              is_WS_OR_EOL(following) ||
              (withinFlowCollection && is_FLOW_INDICATOR(following))
            ) {
              break
            }
          } else if (ch === 0x23 /* # */) {
            preceding = state.input.charCodeAt(state.position - 1)

            if (is_WS_OR_EOL(preceding)) {
              break
            }
          } else if (
            (state.position === state.lineStart &&
              testDocumentSeparator(state)) ||
            (withinFlowCollection && is_FLOW_INDICATOR(ch))
          ) {
            break
          } else if (is_EOL(ch)) {
            _line = state.line
            _lineStart = state.lineStart
            _lineIndent = state.lineIndent
            skipSeparationSpace(state, false, -1)

            if (state.lineIndent >= nodeIndent) {
              hasPendingContent = true
              ch = state.input.charCodeAt(state.position)
              continue
            } else {
              state.position = captureEnd
              state.line = _line
              state.lineStart = _lineStart
              state.lineIndent = _lineIndent
              break
            }
          }

          if (hasPendingContent) {
            captureSegment(state, captureStart, captureEnd, false)
            writeFoldedLines(state, state.line - _line)
            captureStart = captureEnd = state.position
            hasPendingContent = false
          }

          if (!is_WHITE_SPACE(ch)) {
            captureEnd = state.position + 1
          }

          ch = state.input.charCodeAt(++state.position)
        }

        captureSegment(state, captureStart, captureEnd, false)

        if (state.result) {
          return true
        }

        state.kind = _kind
        state.result = _result
        return false
      }

      function readSingleQuotedScalar(state, nodeIndent) {
        var ch, captureStart, captureEnd

        ch = state.input.charCodeAt(state.position)

        if (ch !== 0x27 /* ' */) {
          return false
        }

        state.kind = 'scalar'
        state.result = ''
        state.position++
        captureStart = captureEnd = state.position

        while ((ch = state.input.charCodeAt(state.position)) !== 0) {
          if (ch === 0x27 /* ' */) {
            captureSegment(state, captureStart, state.position, true)
            ch = state.input.charCodeAt(++state.position)

            if (ch === 0x27 /* ' */) {
              captureStart = state.position
              state.position++
              captureEnd = state.position
            } else {
              return true
            }
          } else if (is_EOL(ch)) {
            captureSegment(state, captureStart, captureEnd, true)
            writeFoldedLines(
              state,
              skipSeparationSpace(state, false, nodeIndent)
            )
            captureStart = captureEnd = state.position
          } else if (
            state.position === state.lineStart &&
            testDocumentSeparator(state)
          ) {
            throwError(
              state,
              'unexpected end of the document within a single quoted scalar'
            )
          } else {
            state.position++
            captureEnd = state.position
          }
        }

        throwError(
          state,
          'unexpected end of the stream within a single quoted scalar'
        )
      }

      function readDoubleQuotedScalar(state, nodeIndent) {
        var captureStart, captureEnd, hexLength, hexResult, tmp, ch

        ch = state.input.charCodeAt(state.position)

        if (ch !== 0x22 /* " */) {
          return false
        }

        state.kind = 'scalar'
        state.result = ''
        state.position++
        captureStart = captureEnd = state.position

        while ((ch = state.input.charCodeAt(state.position)) !== 0) {
          if (ch === 0x22 /* " */) {
            captureSegment(state, captureStart, state.position, true)
            state.position++
            return true
          } else if (ch === 0x5c /* \ */) {
            captureSegment(state, captureStart, state.position, true)
            ch = state.input.charCodeAt(++state.position)

            if (is_EOL(ch)) {
              skipSeparationSpace(state, false, nodeIndent)

              // TODO: rework to inline fn with no type cast?
            } else if (ch < 256 && simpleEscapeCheck[ch]) {
              state.result += simpleEscapeMap[ch]
              state.position++
            } else if ((tmp = escapedHexLen(ch)) > 0) {
              hexLength = tmp
              hexResult = 0

              for (; hexLength > 0; hexLength--) {
                ch = state.input.charCodeAt(++state.position)

                if ((tmp = fromHexCode(ch)) >= 0) {
                  hexResult = (hexResult << 4) + tmp
                } else {
                  throwError(state, 'expected hexadecimal character')
                }
              }

              state.result += charFromCodepoint(hexResult)

              state.position++
            } else {
              throwError(state, 'unknown escape sequence')
            }

            captureStart = captureEnd = state.position
          } else if (is_EOL(ch)) {
            captureSegment(state, captureStart, captureEnd, true)
            writeFoldedLines(
              state,
              skipSeparationSpace(state, false, nodeIndent)
            )
            captureStart = captureEnd = state.position
          } else if (
            state.position === state.lineStart &&
            testDocumentSeparator(state)
          ) {
            throwError(
              state,
              'unexpected end of the document within a double quoted scalar'
            )
          } else {
            state.position++
            captureEnd = state.position
          }
        }

        throwError(
          state,
          'unexpected end of the stream within a double quoted scalar'
        )
      }

      function readFlowCollection(state, nodeIndent) {
        var readNext = true,
          _line,
          _tag = state.tag,
          _result,
          _anchor = state.anchor,
          following,
          terminator,
          isPair,
          isExplicitPair,
          isMapping,
          overridableKeys = {},
          keyNode,
          keyTag,
          valueNode,
          ch

        ch = state.input.charCodeAt(state.position)

        if (ch === 0x5b /* [ */) {
          terminator = 0x5d /* ] */
          isMapping = false
          _result = []
        } else if (ch === 0x7b /* { */) {
          terminator = 0x7d /* } */
          isMapping = true
          _result = {}
        } else {
          return false
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = _result
        }

        ch = state.input.charCodeAt(++state.position)

        while (ch !== 0) {
          skipSeparationSpace(state, true, nodeIndent)

          ch = state.input.charCodeAt(state.position)

          if (ch === terminator) {
            state.position++
            state.tag = _tag
            state.anchor = _anchor
            state.kind = isMapping ? 'mapping' : 'sequence'
            state.result = _result
            return true
          } else if (!readNext) {
            throwError(state, 'missed comma between flow collection entries')
          }

          keyTag = keyNode = valueNode = null
          isPair = isExplicitPair = false

          if (ch === 0x3f /* ? */) {
            following = state.input.charCodeAt(state.position + 1)

            if (is_WS_OR_EOL(following)) {
              isPair = isExplicitPair = true
              state.position++
              skipSeparationSpace(state, true, nodeIndent)
            }
          }

          _line = state.line
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true)
          keyTag = state.tag
          keyNode = state.result
          skipSeparationSpace(state, true, nodeIndent)

          ch = state.input.charCodeAt(state.position)

          if ((isExplicitPair || state.line === _line) && ch === 0x3a /* : */) {
            isPair = true
            ch = state.input.charCodeAt(++state.position)
            skipSeparationSpace(state, true, nodeIndent)
            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true)
            valueNode = state.result
          }

          if (isMapping) {
            storeMappingPair(
              state,
              _result,
              overridableKeys,
              keyTag,
              keyNode,
              valueNode
            )
          } else if (isPair) {
            _result.push(
              storeMappingPair(
                state,
                null,
                overridableKeys,
                keyTag,
                keyNode,
                valueNode
              )
            )
          } else {
            _result.push(keyNode)
          }

          skipSeparationSpace(state, true, nodeIndent)

          ch = state.input.charCodeAt(state.position)

          if (ch === 0x2c /* , */) {
            readNext = true
            ch = state.input.charCodeAt(++state.position)
          } else {
            readNext = false
          }
        }

        throwError(
          state,
          'unexpected end of the stream within a flow collection'
        )
      }

      function readBlockScalar(state, nodeIndent) {
        var captureStart,
          folding,
          chomping = CHOMPING_CLIP,
          didReadContent = false,
          detectedIndent = false,
          textIndent = nodeIndent,
          emptyLines = 0,
          atMoreIndented = false,
          tmp,
          ch

        ch = state.input.charCodeAt(state.position)

        if (ch === 0x7c /* | */) {
          folding = false
        } else if (ch === 0x3e /* > */) {
          folding = true
        } else {
          return false
        }

        state.kind = 'scalar'
        state.result = ''

        while (ch !== 0) {
          ch = state.input.charCodeAt(++state.position)

          if (ch === 0x2b /* + */ || ch === 0x2d /* - */) {
            if (CHOMPING_CLIP === chomping) {
              chomping = ch === 0x2b /* + */ ? CHOMPING_KEEP : CHOMPING_STRIP
            } else {
              throwError(state, 'repeat of a chomping mode identifier')
            }
          } else if ((tmp = fromDecimalCode(ch)) >= 0) {
            if (tmp === 0) {
              throwError(
                state,
                'bad explicit indentation width of a block scalar; it cannot be less than one'
              )
            } else if (!detectedIndent) {
              textIndent = nodeIndent + tmp - 1
              detectedIndent = true
            } else {
              throwError(state, 'repeat of an indentation width identifier')
            }
          } else {
            break
          }
        }

        if (is_WHITE_SPACE(ch)) {
          do {
            ch = state.input.charCodeAt(++state.position)
          } while (is_WHITE_SPACE(ch))

          if (ch === 0x23 /* # */) {
            do {
              ch = state.input.charCodeAt(++state.position)
            } while (!is_EOL(ch) && ch !== 0)
          }
        }

        while (ch !== 0) {
          readLineBreak(state)
          state.lineIndent = 0

          ch = state.input.charCodeAt(state.position)

          while (
            (!detectedIndent || state.lineIndent < textIndent) &&
            ch === 0x20 /* Space */
          ) {
            state.lineIndent++
            ch = state.input.charCodeAt(++state.position)
          }

          if (!detectedIndent && state.lineIndent > textIndent) {
            textIndent = state.lineIndent
          }

          if (is_EOL(ch)) {
            emptyLines++
            continue
          }

          // End of the scalar.
          if (state.lineIndent < textIndent) {
            // Perform the chomping.
            if (chomping === CHOMPING_KEEP) {
              state.result += common.repeat(
                '\n',
                didReadContent ? 1 + emptyLines : emptyLines
              )
            } else if (chomping === CHOMPING_CLIP) {
              if (didReadContent) {
                // i.e. only if the scalar is not empty.
                state.result += '\n'
              }
            }

            // Break this `while` cycle and go to the funciton's epilogue.
            break
          }

          // Folded style: use fancy rules to handle line breaks.
          if (folding) {
            // Lines starting with white space characters (more-indented lines) are not folded.
            if (is_WHITE_SPACE(ch)) {
              atMoreIndented = true
              // except for the first content line (cf. Example 8.1)
              state.result += common.repeat(
                '\n',
                didReadContent ? 1 + emptyLines : emptyLines
              )

              // End of more-indented block.
            } else if (atMoreIndented) {
              atMoreIndented = false
              state.result += common.repeat('\n', emptyLines + 1)

              // Just one line break - perceive as the same line.
            } else if (emptyLines === 0) {
              if (didReadContent) {
                // i.e. only if we have already read some scalar content.
                state.result += ' '
              }

              // Several line breaks - perceive as different lines.
            } else {
              state.result += common.repeat('\n', emptyLines)
            }

            // Literal style: just add exact number of line breaks between content lines.
          } else {
            // Keep all line breaks except the header line break.
            state.result += common.repeat(
              '\n',
              didReadContent ? 1 + emptyLines : emptyLines
            )
          }

          didReadContent = true
          detectedIndent = true
          emptyLines = 0
          captureStart = state.position

          while (!is_EOL(ch) && ch !== 0) {
            ch = state.input.charCodeAt(++state.position)
          }

          captureSegment(state, captureStart, state.position, false)
        }

        return true
      }

      function readBlockSequence(state, nodeIndent) {
        var _line,
          _tag = state.tag,
          _anchor = state.anchor,
          _result = [],
          following,
          detected = false,
          ch

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = _result
        }

        ch = state.input.charCodeAt(state.position)

        while (ch !== 0) {
          if (ch !== 0x2d /* - */) {
            break
          }

          following = state.input.charCodeAt(state.position + 1)

          if (!is_WS_OR_EOL(following)) {
            break
          }

          detected = true
          state.position++

          if (skipSeparationSpace(state, true, -1)) {
            if (state.lineIndent <= nodeIndent) {
              _result.push(null)
              ch = state.input.charCodeAt(state.position)
              continue
            }
          }

          _line = state.line
          composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true)
          _result.push(state.result)
          skipSeparationSpace(state, true, -1)

          ch = state.input.charCodeAt(state.position)

          if (
            (state.line === _line || state.lineIndent > nodeIndent) &&
            ch !== 0
          ) {
            throwError(state, 'bad indentation of a sequence entry')
          } else if (state.lineIndent < nodeIndent) {
            break
          }
        }

        if (detected) {
          state.tag = _tag
          state.anchor = _anchor
          state.kind = 'sequence'
          state.result = _result
          return true
        }
        return false
      }

      function readBlockMapping(state, nodeIndent, flowIndent) {
        var following,
          allowCompact,
          _line,
          _pos,
          _tag = state.tag,
          _anchor = state.anchor,
          _result = {},
          overridableKeys = {},
          keyTag = null,
          keyNode = null,
          valueNode = null,
          atExplicitKey = false,
          detected = false,
          ch

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = _result
        }

        ch = state.input.charCodeAt(state.position)

        while (ch !== 0) {
          following = state.input.charCodeAt(state.position + 1)
          _line = state.line // Save the current line.
          _pos = state.position

          //
          // Explicit notation case. There are two separate blocks:
          // first for the key (denoted by "?") and second for the value (denoted by ":")
          //
          if (
            (ch === 0x3f /* ? */ || ch === 0x3a /*: */) &&
            is_WS_OR_EOL(following)
          ) {
            if (ch === 0x3f /* ? */) {
              if (atExplicitKey) {
                storeMappingPair(
                  state,
                  _result,
                  overridableKeys,
                  keyTag,
                  keyNode,
                  null
                )
                keyTag = keyNode = valueNode = null
              }

              detected = true
              atExplicitKey = true
              allowCompact = true
            } else if (atExplicitKey) {
              // i.e. 0x3A/* : */ === character after the explicit key.
              atExplicitKey = false
              allowCompact = true
            } else {
              throwError(
                state,
                'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line'
              )
            }

            state.position += 1
            ch = following

            //
            // Implicit notation case. Flow-style node as the key first, then ":", and the value.
            //
          } else if (
            composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)
          ) {
            if (state.line === _line) {
              ch = state.input.charCodeAt(state.position)

              while (is_WHITE_SPACE(ch)) {
                ch = state.input.charCodeAt(++state.position)
              }

              if (ch === 0x3a /* : */) {
                ch = state.input.charCodeAt(++state.position)

                if (!is_WS_OR_EOL(ch)) {
                  throwError(
                    state,
                    'a whitespace character is expected after the key-value separator within a block mapping'
                  )
                }

                if (atExplicitKey) {
                  storeMappingPair(
                    state,
                    _result,
                    overridableKeys,
                    keyTag,
                    keyNode,
                    null
                  )
                  keyTag = keyNode = valueNode = null
                }

                detected = true
                atExplicitKey = false
                allowCompact = false
                keyTag = state.tag
                keyNode = state.result
              } else if (detected) {
                throwError(
                  state,
                  'can not read an implicit mapping pair; a colon is missed'
                )
              } else {
                state.tag = _tag
                state.anchor = _anchor
                return true // Keep the result of `composeNode`.
              }
            } else if (detected) {
              throwError(
                state,
                'can not read a block mapping entry; a multiline key may not be an implicit key'
              )
            } else {
              state.tag = _tag
              state.anchor = _anchor
              return true // Keep the result of `composeNode`.
            }
          } else {
            break // Reading is done. Go to the epilogue.
          }

          //
          // Common reading code for both explicit and implicit notations.
          //
          if (state.line === _line || state.lineIndent > nodeIndent) {
            if (
              composeNode(
                state,
                nodeIndent,
                CONTEXT_BLOCK_OUT,
                true,
                allowCompact
              )
            ) {
              if (atExplicitKey) {
                keyNode = state.result
              } else {
                valueNode = state.result
              }
            }

            if (!atExplicitKey) {
              storeMappingPair(
                state,
                _result,
                overridableKeys,
                keyTag,
                keyNode,
                valueNode,
                _line,
                _pos
              )
              keyTag = keyNode = valueNode = null
            }

            skipSeparationSpace(state, true, -1)
            ch = state.input.charCodeAt(state.position)
          }

          if (state.lineIndent > nodeIndent && ch !== 0) {
            throwError(state, 'bad indentation of a mapping entry')
          } else if (state.lineIndent < nodeIndent) {
            break
          }
        }

        //
        // Epilogue.
        //

        // Special case: last mapping's node contains only the key in explicit notation.
        if (atExplicitKey) {
          storeMappingPair(
            state,
            _result,
            overridableKeys,
            keyTag,
            keyNode,
            null
          )
        }

        // Expose the resulting mapping.
        if (detected) {
          state.tag = _tag
          state.anchor = _anchor
          state.kind = 'mapping'
          state.result = _result
        }

        return detected
      }

      function readTagProperty(state) {
        var _position,
          isVerbatim = false,
          isNamed = false,
          tagHandle,
          tagName,
          ch

        ch = state.input.charCodeAt(state.position)

        if (ch !== 0x21 /* ! */) return false

        if (state.tag !== null) {
          throwError(state, 'duplication of a tag property')
        }

        ch = state.input.charCodeAt(++state.position)

        if (ch === 0x3c /* < */) {
          isVerbatim = true
          ch = state.input.charCodeAt(++state.position)
        } else if (ch === 0x21 /* ! */) {
          isNamed = true
          tagHandle = '!!'
          ch = state.input.charCodeAt(++state.position)
        } else {
          tagHandle = '!'
        }

        _position = state.position

        if (isVerbatim) {
          do {
            ch = state.input.charCodeAt(++state.position)
          } while (ch !== 0 && ch !== 0x3e /* > */)

          if (state.position < state.length) {
            tagName = state.input.slice(_position, state.position)
            ch = state.input.charCodeAt(++state.position)
          } else {
            throwError(
              state,
              'unexpected end of the stream within a verbatim tag'
            )
          }
        } else {
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            if (ch === 0x21 /* ! */) {
              if (!isNamed) {
                tagHandle = state.input.slice(_position - 1, state.position + 1)

                if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                  throwError(
                    state,
                    'named tag handle cannot contain such characters'
                  )
                }

                isNamed = true
                _position = state.position + 1
              } else {
                throwError(state, 'tag suffix cannot contain exclamation marks')
              }
            }

            ch = state.input.charCodeAt(++state.position)
          }

          tagName = state.input.slice(_position, state.position)

          if (PATTERN_FLOW_INDICATORS.test(tagName)) {
            throwError(
              state,
              'tag suffix cannot contain flow indicator characters'
            )
          }
        }

        if (tagName && !PATTERN_TAG_URI.test(tagName)) {
          throwError(
            state,
            'tag name cannot contain such characters: ' + tagName
          )
        }

        if (isVerbatim) {
          state.tag = tagName
        } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
          state.tag = state.tagMap[tagHandle] + tagName
        } else if (tagHandle === '!') {
          state.tag = '!' + tagName
        } else if (tagHandle === '!!') {
          state.tag = 'tag:yaml.org,2002:' + tagName
        } else {
          throwError(state, 'undeclared tag handle "' + tagHandle + '"')
        }

        return true
      }

      function readAnchorProperty(state) {
        var _position, ch

        ch = state.input.charCodeAt(state.position)

        if (ch !== 0x26 /* & */) return false

        if (state.anchor !== null) {
          throwError(state, 'duplication of an anchor property')
        }

        ch = state.input.charCodeAt(++state.position)
        _position = state.position

        while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
          ch = state.input.charCodeAt(++state.position)
        }

        if (state.position === _position) {
          throwError(
            state,
            'name of an anchor node must contain at least one character'
          )
        }

        state.anchor = state.input.slice(_position, state.position)
        return true
      }

      function readAlias(state) {
        var _position, alias, ch

        ch = state.input.charCodeAt(state.position)

        if (ch !== 0x2a /* * */) return false

        ch = state.input.charCodeAt(++state.position)
        _position = state.position

        while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
          ch = state.input.charCodeAt(++state.position)
        }

        if (state.position === _position) {
          throwError(
            state,
            'name of an alias node must contain at least one character'
          )
        }

        alias = state.input.slice(_position, state.position)

        if (!_hasOwnProperty.call(state.anchorMap, alias)) {
          throwError(state, 'unidentified alias "' + alias + '"')
        }

        state.result = state.anchorMap[alias]
        skipSeparationSpace(state, true, -1)
        return true
      }

      function composeNode(
        state,
        parentIndent,
        nodeContext,
        allowToSeek,
        allowCompact
      ) {
        var allowBlockStyles,
          allowBlockScalars,
          allowBlockCollections,
          indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
          atNewLine = false,
          hasContent = false,
          typeIndex,
          typeQuantity,
          type,
          flowIndent,
          blockIndent

        if (state.listener !== null) {
          state.listener('open', state)
        }

        state.tag = null
        state.anchor = null
        state.kind = null
        state.result = null

        allowBlockStyles =
          allowBlockScalars =
          allowBlockCollections =
            CONTEXT_BLOCK_OUT === nodeContext ||
            CONTEXT_BLOCK_IN === nodeContext

        if (allowToSeek) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true

            if (state.lineIndent > parentIndent) {
              indentStatus = 1
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1
            }
          }
        }

        if (indentStatus === 1) {
          while (readTagProperty(state) || readAnchorProperty(state)) {
            if (skipSeparationSpace(state, true, -1)) {
              atNewLine = true
              allowBlockCollections = allowBlockStyles

              if (state.lineIndent > parentIndent) {
                indentStatus = 1
              } else if (state.lineIndent === parentIndent) {
                indentStatus = 0
              } else if (state.lineIndent < parentIndent) {
                indentStatus = -1
              }
            } else {
              allowBlockCollections = false
            }
          }
        }

        if (allowBlockCollections) {
          allowBlockCollections = atNewLine || allowCompact
        }

        if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
          if (
            CONTEXT_FLOW_IN === nodeContext ||
            CONTEXT_FLOW_OUT === nodeContext
          ) {
            flowIndent = parentIndent
          } else {
            flowIndent = parentIndent + 1
          }

          blockIndent = state.position - state.lineStart

          if (indentStatus === 1) {
            if (
              (allowBlockCollections &&
                (readBlockSequence(state, blockIndent) ||
                  readBlockMapping(state, blockIndent, flowIndent))) ||
              readFlowCollection(state, flowIndent)
            ) {
              hasContent = true
            } else {
              if (
                (allowBlockScalars && readBlockScalar(state, flowIndent)) ||
                readSingleQuotedScalar(state, flowIndent) ||
                readDoubleQuotedScalar(state, flowIndent)
              ) {
                hasContent = true
              } else if (readAlias(state)) {
                hasContent = true

                if (state.tag !== null || state.anchor !== null) {
                  throwError(state, 'alias node should not have any properties')
                }
              } else if (
                readPlainScalar(
                  state,
                  flowIndent,
                  CONTEXT_FLOW_IN === nodeContext
                )
              ) {
                hasContent = true

                if (state.tag === null) {
                  state.tag = '?'
                }
              }

              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result
              }
            }
          } else if (indentStatus === 0) {
            // Special case: block sequences are allowed to have same indentation level as the parent.
            // http://www.yaml.org/spec/1.2/spec.html#id2799784
            hasContent =
              allowBlockCollections && readBlockSequence(state, blockIndent)
          }
        }

        if (state.tag !== null && state.tag !== '!') {
          if (state.tag === '?') {
            // Implicit resolving is not allowed for non-scalar types, and '?'
            // non-specific tag is only automatically assigned to plain scalars.
            //
            // We only need to check kind conformity in case user explicitly assigns '?'
            // tag, for example like this: "!<?> [0]"
            //
            if (state.result !== null && state.kind !== 'scalar') {
              throwError(
                state,
                'unacceptable node kind for !<?> tag; it should be "scalar", not "' +
                  state.kind +
                  '"'
              )
            }

            for (
              typeIndex = 0, typeQuantity = state.implicitTypes.length;
              typeIndex < typeQuantity;
              typeIndex += 1
            ) {
              type = state.implicitTypes[typeIndex]

              if (type.resolve(state.result)) {
                // `state.result` updated in resolver if matched
                state.result = type.construct(state.result)
                state.tag = type.tag
                if (state.anchor !== null) {
                  state.anchorMap[state.anchor] = state.result
                }
                break
              }
            }
          } else if (
            _hasOwnProperty.call(
              state.typeMap[state.kind || 'fallback'],
              state.tag
            )
          ) {
            type = state.typeMap[state.kind || 'fallback'][state.tag]

            if (state.result !== null && type.kind !== state.kind) {
              throwError(
                state,
                'unacceptable node kind for !<' +
                  state.tag +
                  '> tag; it should be "' +
                  type.kind +
                  '", not "' +
                  state.kind +
                  '"'
              )
            }

            if (!type.resolve(state.result)) {
              // `state.result` updated in resolver if matched
              throwError(
                state,
                'cannot resolve a node with !<' + state.tag + '> explicit tag'
              )
            } else {
              state.result = type.construct(state.result)
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result
              }
            }
          } else {
            throwError(state, 'unknown tag !<' + state.tag + '>')
          }
        }

        if (state.listener !== null) {
          state.listener('close', state)
        }
        return state.tag !== null || state.anchor !== null || hasContent
      }

      function readDocument(state) {
        var documentStart = state.position,
          _position,
          directiveName,
          directiveArgs,
          hasDirectives = false,
          ch

        state.version = null
        state.checkLineBreaks = state.legacy
        state.tagMap = {}
        state.anchorMap = {}

        while ((ch = state.input.charCodeAt(state.position)) !== 0) {
          skipSeparationSpace(state, true, -1)

          ch = state.input.charCodeAt(state.position)

          if (state.lineIndent > 0 || ch !== 0x25 /* % */) {
            break
          }

          hasDirectives = true
          ch = state.input.charCodeAt(++state.position)
          _position = state.position

          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position)
          }

          directiveName = state.input.slice(_position, state.position)
          directiveArgs = []

          if (directiveName.length < 1) {
            throwError(
              state,
              'directive name must not be less than one character in length'
            )
          }

          while (ch !== 0) {
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position)
            }

            if (ch === 0x23 /* # */) {
              do {
                ch = state.input.charCodeAt(++state.position)
              } while (ch !== 0 && !is_EOL(ch))
              break
            }

            if (is_EOL(ch)) break

            _position = state.position

            while (ch !== 0 && !is_WS_OR_EOL(ch)) {
              ch = state.input.charCodeAt(++state.position)
            }

            directiveArgs.push(state.input.slice(_position, state.position))
          }

          if (ch !== 0) readLineBreak(state)

          if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
            directiveHandlers[directiveName](
              state,
              directiveName,
              directiveArgs
            )
          } else {
            throwWarning(
              state,
              'unknown document directive "' + directiveName + '"'
            )
          }
        }

        skipSeparationSpace(state, true, -1)

        if (
          state.lineIndent === 0 &&
          state.input.charCodeAt(state.position) === 0x2d /* - */ &&
          state.input.charCodeAt(state.position + 1) === 0x2d /* - */ &&
          state.input.charCodeAt(state.position + 2) === 0x2d /* - */
        ) {
          state.position += 3
          skipSeparationSpace(state, true, -1)
        } else if (hasDirectives) {
          throwError(state, 'directives end mark is expected')
        }

        composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true)
        skipSeparationSpace(state, true, -1)

        if (
          state.checkLineBreaks &&
          PATTERN_NON_ASCII_LINE_BREAKS.test(
            state.input.slice(documentStart, state.position)
          )
        ) {
          throwWarning(
            state,
            'non-ASCII line breaks are interpreted as content'
          )
        }

        state.documents.push(state.result)

        if (
          state.position === state.lineStart &&
          testDocumentSeparator(state)
        ) {
          if (state.input.charCodeAt(state.position) === 0x2e /* . */) {
            state.position += 3
            skipSeparationSpace(state, true, -1)
          }
          return
        }

        if (state.position < state.length - 1) {
          throwError(
            state,
            'end of the stream or a document separator is expected'
          )
        } else {
          return
        }
      }

      function loadDocuments(input, options) {
        input = String(input)
        options = options || {}

        if (input.length !== 0) {
          // Add tailing `\n` if not exists
          if (
            input.charCodeAt(input.length - 1) !== 0x0a /* LF */ &&
            input.charCodeAt(input.length - 1) !== 0x0d /* CR */
          ) {
            input += '\n'
          }

          // Strip BOM
          if (input.charCodeAt(0) === 0xfeff) {
            input = input.slice(1)
          }
        }

        var state = new State(input, options)

        var nullpos = input.indexOf('\0')

        if (nullpos !== -1) {
          state.position = nullpos
          throwError(state, 'null byte is not allowed in input')
        }

        // Use 0 as string terminator. That significantly simplifies bounds check.
        state.input += '\0'

        while (state.input.charCodeAt(state.position) === 0x20 /* Space */) {
          state.lineIndent += 1
          state.position += 1
        }

        while (state.position < state.length - 1) {
          readDocument(state)
        }

        return state.documents
      }

      function loadAll(input, iterator, options) {
        if (
          iterator !== null &&
          typeof iterator === 'object' &&
          typeof options === 'undefined'
        ) {
          options = iterator
          iterator = null
        }

        var documents = loadDocuments(input, options)

        if (typeof iterator !== 'function') {
          return documents
        }

        for (
          var index = 0, length = documents.length;
          index < length;
          index += 1
        ) {
          iterator(documents[index])
        }
      }

      function load(input, options) {
        var documents = loadDocuments(input, options)

        if (documents.length === 0) {
          /*eslint-disable no-undefined*/
          return undefined
        } else if (documents.length === 1) {
          return documents[0]
        }
        throw new YAMLException(
          'expected a single document in the stream, but found more'
        )
      }

      function safeLoadAll(input, iterator, options) {
        if (
          typeof iterator === 'object' &&
          iterator !== null &&
          typeof options === 'undefined'
        ) {
          options = iterator
          iterator = null
        }

        return loadAll(
          input,
          iterator,
          common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options)
        )
      }

      function safeLoad(input, options) {
        return load(
          input,
          common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options)
        )
      }

      module.exports.loadAll = loadAll
      module.exports.load = load
      module.exports.safeLoadAll = safeLoadAll
      module.exports.safeLoad = safeLoad

      /***/
    },

    /***/ 8770: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var common = __nccwpck_require__(4158)

      function Mark(name, buffer, position, line, column) {
        this.name = name
        this.buffer = buffer
        this.position = position
        this.line = line
        this.column = column
      }

      Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
        var head, start, tail, end, snippet

        if (!this.buffer) return null

        indent = indent || 4
        maxLength = maxLength || 75

        head = ''
        start = this.position

        while (
          start > 0 &&
          '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) ===
            -1
        ) {
          start -= 1
          if (this.position - start > maxLength / 2 - 1) {
            head = ' ... '
            start += 5
            break
          }
        }

        tail = ''
        end = this.position

        while (
          end < this.buffer.length &&
          '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1
        ) {
          end += 1
          if (end - this.position > maxLength / 2 - 1) {
            tail = ' ... '
            end -= 5
            break
          }
        }

        snippet = this.buffer.slice(start, end)

        return (
          common.repeat(' ', indent) +
          head +
          snippet +
          tail +
          '\n' +
          common.repeat(' ', indent + this.position - start + head.length) +
          '^'
        )
      }

      Mark.prototype.toString = function toString(compact) {
        var snippet,
          where = ''

        if (this.name) {
          where += 'in "' + this.name + '" '
        }

        where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1)

        if (!compact) {
          snippet = this.getSnippet()

          if (snippet) {
            where += ':\n' + snippet
          }
        }

        return where
      }

      module.exports = Mark

      /***/
    },

    /***/ 3804: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      /*eslint-disable max-len*/

      var common = __nccwpck_require__(4158)
      var YAMLException = __nccwpck_require__(5694)
      var Type = __nccwpck_require__(6496)

      function compileList(schema, name, result) {
        var exclude = []

        schema.include.forEach(function (includedSchema) {
          result = compileList(includedSchema, name, result)
        })

        schema[name].forEach(function (currentType) {
          result.forEach(function (previousType, previousIndex) {
            if (
              previousType.tag === currentType.tag &&
              previousType.kind === currentType.kind
            ) {
              exclude.push(previousIndex)
            }
          })

          result.push(currentType)
        })

        return result.filter(function (type, index) {
          return exclude.indexOf(index) === -1
        })
      }

      function compileMap(/* lists... */) {
        var result = {
            scalar: {},
            sequence: {},
            mapping: {},
            fallback: {},
          },
          index,
          length

        function collectType(type) {
          result[type.kind][type.tag] = result['fallback'][type.tag] = type
        }

        for (index = 0, length = arguments.length; index < length; index += 1) {
          arguments[index].forEach(collectType)
        }
        return result
      }

      function Schema(definition) {
        this.include = definition.include || []
        this.implicit = definition.implicit || []
        this.explicit = definition.explicit || []

        this.implicit.forEach(function (type) {
          if (type.loadKind && type.loadKind !== 'scalar') {
            throw new YAMLException(
              'There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.'
            )
          }
        })

        this.compiledImplicit = compileList(this, 'implicit', [])
        this.compiledExplicit = compileList(this, 'explicit', [])
        this.compiledTypeMap = compileMap(
          this.compiledImplicit,
          this.compiledExplicit
        )
      }

      Schema.DEFAULT = null

      Schema.create = function createSchema() {
        var schemas, types

        switch (arguments.length) {
          case 1:
            schemas = Schema.DEFAULT
            types = arguments[0]
            break

          case 2:
            schemas = arguments[0]
            types = arguments[1]
            break

          default:
            throw new YAMLException(
              'Wrong number of arguments for Schema.create function'
            )
        }

        schemas = common.toArray(schemas)
        types = common.toArray(types)

        if (
          !schemas.every(function (schema) {
            return schema instanceof Schema
          })
        ) {
          throw new YAMLException(
            'Specified list of super schemas (or a single Schema object) contains a non-Schema object.'
          )
        }

        if (
          !types.every(function (type) {
            return type instanceof Type
          })
        ) {
          throw new YAMLException(
            'Specified list of YAML types (or a single Type object) contains a non-Type object.'
          )
        }

        return new Schema({
          include: schemas,
          explicit: types,
        })
      }

      module.exports = Schema

      /***/
    },

    /***/ 413: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'
      // Standard YAML's Core schema.
      // http://www.yaml.org/spec/1.2/spec.html#id2804923
      //
      // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
      // So, Core schema has no distinctions from JSON schema is JS-YAML.

      var Schema = __nccwpck_require__(3804)

      module.exports = new Schema({
        include: [__nccwpck_require__(9035)],
      })

      /***/
    },

    /***/ 5460: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'
      // JS-YAML's default schema for `load` function.
      // It is not described in the YAML specification.
      //
      // This schema is based on JS-YAML's default safe schema and includes
      // JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
      //
      // Also this schema is used as default base schema at `Schema.create` function.

      var Schema = __nccwpck_require__(3804)

      module.exports = Schema.DEFAULT = new Schema({
        include: [__nccwpck_require__(6137)],
        explicit: [
          __nccwpck_require__(2664),
          __nccwpck_require__(4938),
          __nccwpck_require__(7008),
        ],
      })

      /***/
    },

    /***/ 6137: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'
      // JS-YAML's default schema for `safeLoad` function.
      // It is not described in the YAML specification.
      //
      // This schema is based on standard YAML's Core schema and includes most of
      // extra types described at YAML tag repository. (http://yaml.org/type/)

      var Schema = __nccwpck_require__(3804)

      module.exports = new Schema({
        include: [__nccwpck_require__(413)],
        implicit: [__nccwpck_require__(9809), __nccwpck_require__(9264)],
        explicit: [
          __nccwpck_require__(7610),
          __nccwpck_require__(9360),
          __nccwpck_require__(5422),
          __nccwpck_require__(3121),
        ],
      })

      /***/
    },

    /***/ 2925: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'
      // Standard YAML's Failsafe schema.
      // http://www.yaml.org/spec/1.2/spec.html#id2802346

      var Schema = __nccwpck_require__(3804)

      module.exports = new Schema({
        explicit: [
          __nccwpck_require__(1658),
          __nccwpck_require__(1939),
          __nccwpck_require__(5226),
        ],
      })

      /***/
    },

    /***/ 9035: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'
      // Standard YAML's JSON schema.
      // http://www.yaml.org/spec/1.2/spec.html#id2803231
      //
      // NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
      // So, this schema is not such strict as defined in the YAML specification.
      // It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.

      var Schema = __nccwpck_require__(3804)

      module.exports = new Schema({
        include: [__nccwpck_require__(2925)],
        implicit: [
          __nccwpck_require__(737),
          __nccwpck_require__(4359),
          __nccwpck_require__(4097),
          __nccwpck_require__(5620),
        ],
      })

      /***/
    },

    /***/ 6496: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var YAMLException = __nccwpck_require__(5694)

      var TYPE_CONSTRUCTOR_OPTIONS = [
        'kind',
        'resolve',
        'construct',
        'instanceOf',
        'predicate',
        'represent',
        'defaultStyle',
        'styleAliases',
      ]

      var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping']

      function compileStyleAliases(map) {
        var result = {}

        if (map !== null) {
          Object.keys(map).forEach(function (style) {
            map[style].forEach(function (alias) {
              result[String(alias)] = style
            })
          })
        }

        return result
      }

      function Type(tag, options) {
        options = options || {}

        Object.keys(options).forEach(function (name) {
          if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
            throw new YAMLException(
              'Unknown option "' +
                name +
                '" is met in definition of "' +
                tag +
                '" YAML type.'
            )
          }
        })

        // TODO: Add tag format check.
        this.tag = tag
        this.kind = options['kind'] || null
        this.resolve =
          options['resolve'] ||
          function () {
            return true
          }
        this.construct =
          options['construct'] ||
          function (data) {
            return data
          }
        this.instanceOf = options['instanceOf'] || null
        this.predicate = options['predicate'] || null
        this.represent = options['represent'] || null
        this.defaultStyle = options['defaultStyle'] || null
        this.styleAliases = compileStyleAliases(options['styleAliases'] || null)

        if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
          throw new YAMLException(
            'Unknown kind "' +
              this.kind +
              '" is specified for "' +
              tag +
              '" YAML type.'
          )
        }
      }

      module.exports = Type

      /***/
    },

    /***/ 7610: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      /*eslint-disable no-bitwise*/

      var NodeBuffer

      try {
        // A trick for browserified version, to not include `Buffer` shim
        var _require = require
        NodeBuffer = _require('buffer').Buffer
      } catch (__) {}

      var Type = __nccwpck_require__(6496)

      // [ 64, 65, 66 ] -> [ padding, CR, LF ]
      var BASE64_MAP =
        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r'

      function resolveYamlBinary(data) {
        if (data === null) return false

        var code,
          idx,
          bitlen = 0,
          max = data.length,
          map = BASE64_MAP

        // Convert one by one.
        for (idx = 0; idx < max; idx++) {
          code = map.indexOf(data.charAt(idx))

          // Skip CR/LF
          if (code > 64) continue

          // Fail on illegal characters
          if (code < 0) return false

          bitlen += 6
        }

        // If there are any bits left, source was corrupted
        return bitlen % 8 === 0
      }

      function constructYamlBinary(data) {
        var idx,
          tailbits,
          input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
          max = input.length,
          map = BASE64_MAP,
          bits = 0,
          result = []

        // Collect by 6*4 bits (3 bytes)

        for (idx = 0; idx < max; idx++) {
          if (idx % 4 === 0 && idx) {
            result.push((bits >> 16) & 0xff)
            result.push((bits >> 8) & 0xff)
            result.push(bits & 0xff)
          }

          bits = (bits << 6) | map.indexOf(input.charAt(idx))
        }

        // Dump tail

        tailbits = (max % 4) * 6

        if (tailbits === 0) {
          result.push((bits >> 16) & 0xff)
          result.push((bits >> 8) & 0xff)
          result.push(bits & 0xff)
        } else if (tailbits === 18) {
          result.push((bits >> 10) & 0xff)
          result.push((bits >> 2) & 0xff)
        } else if (tailbits === 12) {
          result.push((bits >> 4) & 0xff)
        }

        // Wrap into Buffer for NodeJS and leave Array for browser
        if (NodeBuffer) {
          // Support node 6.+ Buffer API when available
          return NodeBuffer.from
            ? NodeBuffer.from(result)
            : new NodeBuffer(result)
        }

        return result
      }

      function representYamlBinary(object /*, style*/) {
        var result = '',
          bits = 0,
          idx,
          tail,
          max = object.length,
          map = BASE64_MAP

        // Convert every three bytes to 4 ASCII characters.

        for (idx = 0; idx < max; idx++) {
          if (idx % 3 === 0 && idx) {
            result += map[(bits >> 18) & 0x3f]
            result += map[(bits >> 12) & 0x3f]
            result += map[(bits >> 6) & 0x3f]
            result += map[bits & 0x3f]
          }

          bits = (bits << 8) + object[idx]
        }

        // Dump tail

        tail = max % 3

        if (tail === 0) {
          result += map[(bits >> 18) & 0x3f]
          result += map[(bits >> 12) & 0x3f]
          result += map[(bits >> 6) & 0x3f]
          result += map[bits & 0x3f]
        } else if (tail === 2) {
          result += map[(bits >> 10) & 0x3f]
          result += map[(bits >> 4) & 0x3f]
          result += map[(bits << 2) & 0x3f]
          result += map[64]
        } else if (tail === 1) {
          result += map[(bits >> 2) & 0x3f]
          result += map[(bits << 4) & 0x3f]
          result += map[64]
          result += map[64]
        }

        return result
      }

      function isBinary(object) {
        return NodeBuffer && NodeBuffer.isBuffer(object)
      }

      module.exports = new Type('tag:yaml.org,2002:binary', {
        kind: 'scalar',
        resolve: resolveYamlBinary,
        construct: constructYamlBinary,
        predicate: isBinary,
        represent: representYamlBinary,
      })

      /***/
    },

    /***/ 4359: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(6496)

      function resolveYamlBoolean(data) {
        if (data === null) return false

        var max = data.length

        return (
          (max === 4 &&
            (data === 'true' || data === 'True' || data === 'TRUE')) ||
          (max === 5 &&
            (data === 'false' || data === 'False' || data === 'FALSE'))
        )
      }

      function constructYamlBoolean(data) {
        return data === 'true' || data === 'True' || data === 'TRUE'
      }

      function isBoolean(object) {
        return Object.prototype.toString.call(object) === '[object Boolean]'
      }

      module.exports = new Type('tag:yaml.org,2002:bool', {
        kind: 'scalar',
        resolve: resolveYamlBoolean,
        construct: constructYamlBoolean,
        predicate: isBoolean,
        represent: {
          lowercase: function (object) {
            return object ? 'true' : 'false'
          },
          uppercase: function (object) {
            return object ? 'TRUE' : 'FALSE'
          },
          camelcase: function (object) {
            return object ? 'True' : 'False'
          },
        },
        defaultStyle: 'lowercase',
      })

      /***/
    },

    /***/ 5620: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var common = __nccwpck_require__(4158)
      var Type = __nccwpck_require__(6496)

      var YAML_FLOAT_PATTERN = new RegExp(
        // 2.5e4, 2.5 and integers
        '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
          // .2e4, .2
          // special case, seems not from spec
          '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
          // 20:59
          '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
          // .inf
          '|[-+]?\\.(?:inf|Inf|INF)' +
          // .nan
          '|\\.(?:nan|NaN|NAN))$'
      )

      function resolveYamlFloat(data) {
        if (data === null) return false

        if (
          !YAML_FLOAT_PATTERN.test(data) ||
          // Quick hack to not allow integers end with `_`
          // Probably should update regexp & check speed
          data[data.length - 1] === '_'
        ) {
          return false
        }

        return true
      }

      function constructYamlFloat(data) {
        var value, sign, base, digits

        value = data.replace(/_/g, '').toLowerCase()
        sign = value[0] === '-' ? -1 : 1
        digits = []

        if ('+-'.indexOf(value[0]) >= 0) {
          value = value.slice(1)
        }

        if (value === '.inf') {
          return sign === 1
            ? Number.POSITIVE_INFINITY
            : Number.NEGATIVE_INFINITY
        } else if (value === '.nan') {
          return NaN
        } else if (value.indexOf(':') >= 0) {
          value.split(':').forEach(function (v) {
            digits.unshift(parseFloat(v, 10))
          })

          value = 0.0
          base = 1

          digits.forEach(function (d) {
            value += d * base
            base *= 60
          })

          return sign * value
        }
        return sign * parseFloat(value, 10)
      }

      var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/

      function representYamlFloat(object, style) {
        var res

        if (isNaN(object)) {
          switch (style) {
            case 'lowercase':
              return '.nan'
            case 'uppercase':
              return '.NAN'
            case 'camelcase':
              return '.NaN'
          }
        } else if (Number.POSITIVE_INFINITY === object) {
          switch (style) {
            case 'lowercase':
              return '.inf'
            case 'uppercase':
              return '.INF'
            case 'camelcase':
              return '.Inf'
          }
        } else if (Number.NEGATIVE_INFINITY === object) {
          switch (style) {
            case 'lowercase':
              return '-.inf'
            case 'uppercase':
              return '-.INF'
            case 'camelcase':
              return '-.Inf'
          }
        } else if (common.isNegativeZero(object)) {
          return '-0.0'
        }

        res = object.toString(10)

        // JS stringifier can build scientific format without dots: 5e-100,
        // while YAML requres dot: 5.e-100. Fix it with simple hack

        return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res
      }

      function isFloat(object) {
        return (
          Object.prototype.toString.call(object) === '[object Number]' &&
          (object % 1 !== 0 || common.isNegativeZero(object))
        )
      }

      module.exports = new Type('tag:yaml.org,2002:float', {
        kind: 'scalar',
        resolve: resolveYamlFloat,
        construct: constructYamlFloat,
        predicate: isFloat,
        represent: representYamlFloat,
        defaultStyle: 'lowercase',
      })

      /***/
    },

    /***/ 4097: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var common = __nccwpck_require__(4158)
      var Type = __nccwpck_require__(6496)

      function isHexCode(c) {
        return (
          (0x30 /* 0 */ <= c && c <= 0x39) /* 9 */ ||
          (0x41 /* A */ <= c && c <= 0x46) /* F */ ||
          (0x61 /* a */ <= c && c <= 0x66) /* f */
        )
      }

      function isOctCode(c) {
        return 0x30 /* 0 */ <= c && c <= 0x37 /* 7 */
      }

      function isDecCode(c) {
        return 0x30 /* 0 */ <= c && c <= 0x39 /* 9 */
      }

      function resolveYamlInteger(data) {
        if (data === null) return false

        var max = data.length,
          index = 0,
          hasDigits = false,
          ch

        if (!max) return false

        ch = data[index]

        // sign
        if (ch === '-' || ch === '+') {
          ch = data[++index]
        }

        if (ch === '0') {
          // 0
          if (index + 1 === max) return true
          ch = data[++index]

          // base 2, base 8, base 16

          if (ch === 'b') {
            // base 2
            index++

            for (; index < max; index++) {
              ch = data[index]
              if (ch === '_') continue
              if (ch !== '0' && ch !== '1') return false
              hasDigits = true
            }
            return hasDigits && ch !== '_'
          }

          if (ch === 'x') {
            // base 16
            index++

            for (; index < max; index++) {
              ch = data[index]
              if (ch === '_') continue
              if (!isHexCode(data.charCodeAt(index))) return false
              hasDigits = true
            }
            return hasDigits && ch !== '_'
          }

          // base 8
          for (; index < max; index++) {
            ch = data[index]
            if (ch === '_') continue
            if (!isOctCode(data.charCodeAt(index))) return false
            hasDigits = true
          }
          return hasDigits && ch !== '_'
        }

        // base 10 (except 0) or base 60

        // value should not start with `_`;
        if (ch === '_') return false

        for (; index < max; index++) {
          ch = data[index]
          if (ch === '_') continue
          if (ch === ':') break
          if (!isDecCode(data.charCodeAt(index))) {
            return false
          }
          hasDigits = true
        }

        // Should have digits and should not end with `_`
        if (!hasDigits || ch === '_') return false

        // if !base60 - done;
        if (ch !== ':') return true

        // base60 almost not used, no needs to optimize
        return /^(:[0-5]?[0-9])+$/.test(data.slice(index))
      }

      function constructYamlInteger(data) {
        var value = data,
          sign = 1,
          ch,
          base,
          digits = []

        if (value.indexOf('_') !== -1) {
          value = value.replace(/_/g, '')
        }

        ch = value[0]

        if (ch === '-' || ch === '+') {
          if (ch === '-') sign = -1
          value = value.slice(1)
          ch = value[0]
        }

        if (value === '0') return 0

        if (ch === '0') {
          if (value[1] === 'b') return sign * parseInt(value.slice(2), 2)
          if (value[1] === 'x') return sign * parseInt(value, 16)
          return sign * parseInt(value, 8)
        }

        if (value.indexOf(':') !== -1) {
          value.split(':').forEach(function (v) {
            digits.unshift(parseInt(v, 10))
          })

          value = 0
          base = 1

          digits.forEach(function (d) {
            value += d * base
            base *= 60
          })

          return sign * value
        }

        return sign * parseInt(value, 10)
      }

      function isInteger(object) {
        return (
          Object.prototype.toString.call(object) === '[object Number]' &&
          object % 1 === 0 &&
          !common.isNegativeZero(object)
        )
      }

      module.exports = new Type('tag:yaml.org,2002:int', {
        kind: 'scalar',
        resolve: resolveYamlInteger,
        construct: constructYamlInteger,
        predicate: isInteger,
        represent: {
          binary: function (obj) {
            return obj >= 0
              ? '0b' + obj.toString(2)
              : '-0b' + obj.toString(2).slice(1)
          },
          octal: function (obj) {
            return obj >= 0
              ? '0' + obj.toString(8)
              : '-0' + obj.toString(8).slice(1)
          },
          decimal: function (obj) {
            return obj.toString(10)
          },
          /* eslint-disable max-len */
          hexadecimal: function (obj) {
            return obj >= 0
              ? '0x' + obj.toString(16).toUpperCase()
              : '-0x' + obj.toString(16).toUpperCase().slice(1)
          },
        },
        defaultStyle: 'decimal',
        styleAliases: {
          binary: [2, 'bin'],
          octal: [8, 'oct'],
          decimal: [10, 'dec'],
          hexadecimal: [16, 'hex'],
        },
      })

      /***/
    },

    /***/ 7008: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var esprima

      // Browserified version does not have esprima
      //
      // 1. For node.js just require module as deps
      // 2. For browser try to require mudule via external AMD system.
      //    If not found - try to fallback to window.esprima. If not
      //    found too - then fail to parse.
      //
      try {
        // workaround to exclude package from browserify list.
        var _require = require
        esprima = _require('esprima')
      } catch (_) {
        /* eslint-disable no-redeclare */
        /* global window */
        if (typeof window !== 'undefined') esprima = window.esprima
      }

      var Type = __nccwpck_require__(6496)

      function resolveJavascriptFunction(data) {
        if (data === null) return false

        try {
          var source = '(' + data + ')',
            ast = esprima.parse(source, { range: true })

          if (
            ast.type !== 'Program' ||
            ast.body.length !== 1 ||
            ast.body[0].type !== 'ExpressionStatement' ||
            (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
              ast.body[0].expression.type !== 'FunctionExpression')
          ) {
            return false
          }

          return true
        } catch (err) {
          return false
        }
      }

      function constructJavascriptFunction(data) {
        /*jslint evil:true*/

        var source = '(' + data + ')',
          ast = esprima.parse(source, { range: true }),
          params = [],
          body

        if (
          ast.type !== 'Program' ||
          ast.body.length !== 1 ||
          ast.body[0].type !== 'ExpressionStatement' ||
          (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
            ast.body[0].expression.type !== 'FunctionExpression')
        ) {
          throw new Error('Failed to resolve function')
        }

        ast.body[0].expression.params.forEach(function (param) {
          params.push(param.name)
        })

        body = ast.body[0].expression.body.range

        // Esprima's ranges include the first '{' and the last '}' characters on
        // function expressions. So cut them out.
        if (ast.body[0].expression.body.type === 'BlockStatement') {
          /*eslint-disable no-new-func*/
          return new Function(params, source.slice(body[0] + 1, body[1] - 1))
        }
        // ES6 arrow functions can omit the BlockStatement. In that case, just return
        // the body.
        /*eslint-disable no-new-func*/
        return new Function(params, 'return ' + source.slice(body[0], body[1]))
      }

      function representJavascriptFunction(object /*, style*/) {
        return object.toString()
      }

      function isFunction(object) {
        return Object.prototype.toString.call(object) === '[object Function]'
      }

      module.exports = new Type('tag:yaml.org,2002:js/function', {
        kind: 'scalar',
        resolve: resolveJavascriptFunction,
        construct: constructJavascriptFunction,
        predicate: isFunction,
        represent: representJavascriptFunction,
      })

      /***/
    },

    /***/ 4938: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(6496)

      function resolveJavascriptRegExp(data) {
        if (data === null) return false
        if (data.length === 0) return false

        var regexp = data,
          tail = /\/([gim]*)$/.exec(data),
          modifiers = ''

        // if regexp starts with '/' it can have modifiers and must be properly closed
        // `/foo/gim` - modifiers tail can be maximum 3 chars
        if (regexp[0] === '/') {
          if (tail) modifiers = tail[1]

          if (modifiers.length > 3) return false
          // if expression starts with /, is should be properly terminated
          if (regexp[regexp.length - modifiers.length - 1] !== '/') return false
        }

        return true
      }

      function constructJavascriptRegExp(data) {
        var regexp = data,
          tail = /\/([gim]*)$/.exec(data),
          modifiers = ''

        // `/foo/gim` - tail can be maximum 4 chars
        if (regexp[0] === '/') {
          if (tail) modifiers = tail[1]
          regexp = regexp.slice(1, regexp.length - modifiers.length - 1)
        }

        return new RegExp(regexp, modifiers)
      }

      function representJavascriptRegExp(object /*, style*/) {
        var result = '/' + object.source + '/'

        if (object.global) result += 'g'
        if (object.multiline) result += 'm'
        if (object.ignoreCase) result += 'i'

        return result
      }

      function isRegExp(object) {
        return Object.prototype.toString.call(object) === '[object RegExp]'
      }

      module.exports = new Type('tag:yaml.org,2002:js/regexp', {
        kind: 'scalar',
        resolve: resolveJavascriptRegExp,
        construct: constructJavascriptRegExp,
        predicate: isRegExp,
        represent: representJavascriptRegExp,
      })

      /***/
    },

    /***/ 2664: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(6496)

      function resolveJavascriptUndefined() {
        return true
      }

      function constructJavascriptUndefined() {
        /*eslint-disable no-undefined*/
        return undefined
      }

      function representJavascriptUndefined() {
        return ''
      }

      function isUndefined(object) {
        return typeof object === 'undefined'
      }

      module.exports = new Type('tag:yaml.org,2002:js/undefined', {
        kind: 'scalar',
        resolve: resolveJavascriptUndefined,
        construct: constructJavascriptUndefined,
        predicate: isUndefined,
        represent: representJavascriptUndefined,
      })

      /***/
    },

    /***/ 5226: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(6496)

      module.exports = new Type('tag:yaml.org,2002:map', {
        kind: 'mapping',
        construct: function (data) {
          return data !== null ? data : {}
        },
      })

      /***/
    },

    /***/ 9264: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(6496)

      function resolveYamlMerge(data) {
        return data === '<<' || data === null
      }

      module.exports = new Type('tag:yaml.org,2002:merge', {
        kind: 'scalar',
        resolve: resolveYamlMerge,
      })

      /***/
    },

    /***/ 737: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(6496)

      function resolveYamlNull(data) {
        if (data === null) return true

        var max = data.length

        return (
          (max === 1 && data === '~') ||
          (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'))
        )
      }

      function constructYamlNull() {
        return null
      }

      function isNull(object) {
        return object === null
      }

      module.exports = new Type('tag:yaml.org,2002:null', {
        kind: 'scalar',
        resolve: resolveYamlNull,
        construct: constructYamlNull,
        predicate: isNull,
        represent: {
          canonical: function () {
            return '~'
          },
          lowercase: function () {
            return 'null'
          },
          uppercase: function () {
            return 'NULL'
          },
          camelcase: function () {
            return 'Null'
          },
        },
        defaultStyle: 'lowercase',
      })

      /***/
    },

    /***/ 9360: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(6496)

      var _hasOwnProperty = Object.prototype.hasOwnProperty
      var _toString = Object.prototype.toString

      function resolveYamlOmap(data) {
        if (data === null) return true

        var objectKeys = [],
          index,
          length,
          pair,
          pairKey,
          pairHasKey,
          object = data

        for (index = 0, length = object.length; index < length; index += 1) {
          pair = object[index]
          pairHasKey = false

          if (_toString.call(pair) !== '[object Object]') return false

          for (pairKey in pair) {
            if (_hasOwnProperty.call(pair, pairKey)) {
              if (!pairHasKey) pairHasKey = true
              else return false
            }
          }

          if (!pairHasKey) return false

          if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey)
          else return false
        }

        return true
      }

      function constructYamlOmap(data) {
        return data !== null ? data : []
      }

      module.exports = new Type('tag:yaml.org,2002:omap', {
        kind: 'sequence',
        resolve: resolveYamlOmap,
        construct: constructYamlOmap,
      })

      /***/
    },

    /***/ 5422: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(6496)

      var _toString = Object.prototype.toString

      function resolveYamlPairs(data) {
        if (data === null) return true

        var index,
          length,
          pair,
          keys,
          result,
          object = data

        result = new Array(object.length)

        for (index = 0, length = object.length; index < length; index += 1) {
          pair = object[index]

          if (_toString.call(pair) !== '[object Object]') return false

          keys = Object.keys(pair)

          if (keys.length !== 1) return false

          result[index] = [keys[0], pair[keys[0]]]
        }

        return true
      }

      function constructYamlPairs(data) {
        if (data === null) return []

        var index,
          length,
          pair,
          keys,
          result,
          object = data

        result = new Array(object.length)

        for (index = 0, length = object.length; index < length; index += 1) {
          pair = object[index]

          keys = Object.keys(pair)

          result[index] = [keys[0], pair[keys[0]]]
        }

        return result
      }

      module.exports = new Type('tag:yaml.org,2002:pairs', {
        kind: 'sequence',
        resolve: resolveYamlPairs,
        construct: constructYamlPairs,
      })

      /***/
    },

    /***/ 1939: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(6496)

      module.exports = new Type('tag:yaml.org,2002:seq', {
        kind: 'sequence',
        construct: function (data) {
          return data !== null ? data : []
        },
      })

      /***/
    },

    /***/ 3121: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(6496)

      var _hasOwnProperty = Object.prototype.hasOwnProperty

      function resolveYamlSet(data) {
        if (data === null) return true

        var key,
          object = data

        for (key in object) {
          if (_hasOwnProperty.call(object, key)) {
            if (object[key] !== null) return false
          }
        }

        return true
      }

      function constructYamlSet(data) {
        return data !== null ? data : {}
      }

      module.exports = new Type('tag:yaml.org,2002:set', {
        kind: 'mapping',
        resolve: resolveYamlSet,
        construct: constructYamlSet,
      })

      /***/
    },

    /***/ 1658: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(6496)

      module.exports = new Type('tag:yaml.org,2002:str', {
        kind: 'scalar',
        construct: function (data) {
          return data !== null ? data : ''
        },
      })

      /***/
    },

    /***/ 9809: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var Type = __nccwpck_require__(6496)

      var YAML_DATE_REGEXP = new RegExp(
        '^([0-9][0-9][0-9][0-9])' + // [1] year
          '-([0-9][0-9])' + // [2] month
          '-([0-9][0-9])$'
      ) // [3] day

      var YAML_TIMESTAMP_REGEXP = new RegExp(
        '^([0-9][0-9][0-9][0-9])' + // [1] year
          '-([0-9][0-9]?)' + // [2] month
          '-([0-9][0-9]?)' + // [3] day
          '(?:[Tt]|[ \\t]+)' + // ...
          '([0-9][0-9]?)' + // [4] hour
          ':([0-9][0-9])' + // [5] minute
          ':([0-9][0-9])' + // [6] second
          '(?:\\.([0-9]*))?' + // [7] fraction
          '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
          '(?::([0-9][0-9]))?))?$'
      ) // [11] tz_minute

      function resolveYamlTimestamp(data) {
        if (data === null) return false
        if (YAML_DATE_REGEXP.exec(data) !== null) return true
        if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true
        return false
      }

      function constructYamlTimestamp(data) {
        var match,
          year,
          month,
          day,
          hour,
          minute,
          second,
          fraction = 0,
          delta = null,
          tz_hour,
          tz_minute,
          date

        match = YAML_DATE_REGEXP.exec(data)
        if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data)

        if (match === null) throw new Error('Date resolve error')

        // match: [1] year [2] month [3] day

        year = +match[1]
        month = +match[2] - 1 // JS month starts with 0
        day = +match[3]

        if (!match[4]) {
          // no hour
          return new Date(Date.UTC(year, month, day))
        }

        // match: [4] hour [5] minute [6] second [7] fraction

        hour = +match[4]
        minute = +match[5]
        second = +match[6]

        if (match[7]) {
          fraction = match[7].slice(0, 3)
          while (fraction.length < 3) {
            // milli-seconds
            fraction += '0'
          }
          fraction = +fraction
        }

        // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

        if (match[9]) {
          tz_hour = +match[10]
          tz_minute = +(match[11] || 0)
          delta = (tz_hour * 60 + tz_minute) * 60000 // delta in mili-seconds
          if (match[9] === '-') delta = -delta
        }

        date = new Date(
          Date.UTC(year, month, day, hour, minute, second, fraction)
        )

        if (delta) date.setTime(date.getTime() - delta)

        return date
      }

      function representYamlTimestamp(object /*, style*/) {
        return object.toISOString()
      }

      module.exports = new Type('tag:yaml.org,2002:timestamp', {
        kind: 'scalar',
        resolve: resolveYamlTimestamp,
        construct: constructYamlTimestamp,
        instanceOf: Date,
        represent: representYamlTimestamp,
      })

      /***/
    },

    /***/ 4307: /***/ module => {
      /**
       * Copyright (c) 2014-present, Facebook, Inc.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */

      var runtime = (function (exports) {
        'use strict'

        var Op = Object.prototype
        var hasOwn = Op.hasOwnProperty
        var undefined // More compressible than void 0.
        var $Symbol = typeof Symbol === 'function' ? Symbol : {}
        var iteratorSymbol = $Symbol.iterator || '@@iterator'
        var asyncIteratorSymbol = $Symbol.asyncIterator || '@@asyncIterator'
        var toStringTagSymbol = $Symbol.toStringTag || '@@toStringTag'

        function define(obj, key, value) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true,
          })
          return obj[key]
        }
        try {
          // IE 8 has a broken Object.defineProperty that only works on DOM objects.
          define({}, '')
        } catch (err) {
          define = function (obj, key, value) {
            return (obj[key] = value)
          }
        }

        function wrap(innerFn, outerFn, self, tryLocsList) {
          // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
          var protoGenerator =
            outerFn && outerFn.prototype instanceof Generator
              ? outerFn
              : Generator
          var generator = Object.create(protoGenerator.prototype)
          var context = new Context(tryLocsList || [])

          // The ._invoke method unifies the implementations of the .next,
          // .throw, and .return methods.
          generator._invoke = makeInvokeMethod(innerFn, self, context)

          return generator
        }
        exports.wrap = wrap

        // Try/catch helper to minimize deoptimizations. Returns a completion
        // record like context.tryEntries[i].completion. This interface could
        // have been (and was previously) designed to take a closure to be
        // invoked without arguments, but in all the cases we care about we
        // already have an existing method we want to call, so there's no need
        // to create a new function object. We can even get away with assuming
        // the method takes exactly one argument, since that happens to be true
        // in every case, so we don't have to touch the arguments object. The
        // only additional allocation required is the completion record, which
        // has a stable shape and so hopefully should be cheap to allocate.
        function tryCatch(fn, obj, arg) {
          try {
            return { type: 'normal', arg: fn.call(obj, arg) }
          } catch (err) {
            return { type: 'throw', arg: err }
          }
        }

        var GenStateSuspendedStart = 'suspendedStart'
        var GenStateSuspendedYield = 'suspendedYield'
        var GenStateExecuting = 'executing'
        var GenStateCompleted = 'completed'

        // Returning this object from the innerFn has the same effect as
        // breaking out of the dispatch switch statement.
        var ContinueSentinel = {}

        // Dummy constructor functions that we use as the .constructor and
        // .constructor.prototype properties for functions that return Generator
        // objects. For full spec compliance, you may wish to configure your
        // minifier not to mangle the names of these two functions.
        function Generator() {}
        function GeneratorFunction() {}
        function GeneratorFunctionPrototype() {}

        // This is a polyfill for %IteratorPrototype% for environments that
        // don't natively support it.
        var IteratorPrototype = {}
        define(IteratorPrototype, iteratorSymbol, function () {
          return this
        })

        var getProto = Object.getPrototypeOf
        var NativeIteratorPrototype = getProto && getProto(getProto(values([])))
        if (
          NativeIteratorPrototype &&
          NativeIteratorPrototype !== Op &&
          hasOwn.call(NativeIteratorPrototype, iteratorSymbol)
        ) {
          // This environment has a native %IteratorPrototype%; use it instead
          // of the polyfill.
          IteratorPrototype = NativeIteratorPrototype
        }

        var Gp =
          (GeneratorFunctionPrototype.prototype =
          Generator.prototype =
            Object.create(IteratorPrototype))
        GeneratorFunction.prototype = GeneratorFunctionPrototype
        define(Gp, 'constructor', GeneratorFunctionPrototype)
        define(GeneratorFunctionPrototype, 'constructor', GeneratorFunction)
        GeneratorFunction.displayName = define(
          GeneratorFunctionPrototype,
          toStringTagSymbol,
          'GeneratorFunction'
        )

        // Helper for defining the .next, .throw, and .return methods of the
        // Iterator interface in terms of a single ._invoke method.
        function defineIteratorMethods(prototype) {
          ;['next', 'throw', 'return'].forEach(function (method) {
            define(prototype, method, function (arg) {
              return this._invoke(method, arg)
            })
          })
        }

        exports.isGeneratorFunction = function (genFun) {
          var ctor = typeof genFun === 'function' && genFun.constructor
          return ctor
            ? ctor === GeneratorFunction ||
                // For the native GeneratorFunction constructor, the best we can
                // do is to check its .name property.
                (ctor.displayName || ctor.name) === 'GeneratorFunction'
            : false
        }

        exports.mark = function (genFun) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(genFun, GeneratorFunctionPrototype)
          } else {
            genFun.__proto__ = GeneratorFunctionPrototype
            define(genFun, toStringTagSymbol, 'GeneratorFunction')
          }
          genFun.prototype = Object.create(Gp)
          return genFun
        }

        // Within the body of any async function, `await x` is transformed to
        // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
        // `hasOwn.call(value, "__await")` to determine if the yielded value is
        // meant to be awaited.
        exports.awrap = function (arg) {
          return { __await: arg }
        }

        function AsyncIterator(generator, PromiseImpl) {
          function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg)
            if (record.type === 'throw') {
              reject(record.arg)
            } else {
              var result = record.arg
              var value = result.value
              if (
                value &&
                typeof value === 'object' &&
                hasOwn.call(value, '__await')
              ) {
                return PromiseImpl.resolve(value.__await).then(
                  function (value) {
                    invoke('next', value, resolve, reject)
                  },
                  function (err) {
                    invoke('throw', err, resolve, reject)
                  }
                )
              }

              return PromiseImpl.resolve(value).then(
                function (unwrapped) {
                  // When a yielded Promise is resolved, its final value becomes
                  // the .value of the Promise<{value,done}> result for the
                  // current iteration.
                  result.value = unwrapped
                  resolve(result)
                },
                function (error) {
                  // If a rejected Promise was yielded, throw the rejection back
                  // into the async generator function so it can be handled there.
                  return invoke('throw', error, resolve, reject)
                }
              )
            }
          }

          var previousPromise

          function enqueue(method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function (resolve, reject) {
                invoke(method, arg, resolve, reject)
              })
            }

            return (previousPromise =
              // If enqueue has been called before, then we want to wait until
              // all previous Promises have been resolved before calling invoke,
              // so that results are always delivered in the correct order. If
              // enqueue has not been called before, then it is important to
              // call invoke immediately, without waiting on a callback to fire,
              // so that the async generator function has the opportunity to do
              // any necessary setup in a predictable way. This predictability
              // is why the Promise constructor synchronously invokes its
              // executor callback, and why async functions synchronously
              // execute code before the first await. Since we implement simple
              // async functions in terms of async generators, it is especially
              // important to get this right, even though it requires care.
              previousPromise
                ? previousPromise.then(
                    callInvokeWithMethodAndArg,
                    // Avoid propagating failures to Promises returned by later
                    // invocations of the iterator.
                    callInvokeWithMethodAndArg
                  )
                : callInvokeWithMethodAndArg())
          }

          // Define the unified helper method that is used to implement .next,
          // .throw, and .return (see defineIteratorMethods).
          this._invoke = enqueue
        }

        defineIteratorMethods(AsyncIterator.prototype)
        define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
          return this
        })
        exports.AsyncIterator = AsyncIterator

        // Note that simple async functions are implemented on top of
        // AsyncIterator objects; they just return a Promise for the value of
        // the final result produced by the iterator.
        exports.async = function (
          innerFn,
          outerFn,
          self,
          tryLocsList,
          PromiseImpl
        ) {
          if (PromiseImpl === void 0) PromiseImpl = Promise

          var iter = new AsyncIterator(
            wrap(innerFn, outerFn, self, tryLocsList),
            PromiseImpl
          )

          return exports.isGeneratorFunction(outerFn)
            ? iter // If outerFn is a generator, return the full iterator.
            : iter.next().then(function (result) {
                return result.done ? result.value : iter.next()
              })
        }

        function makeInvokeMethod(innerFn, self, context) {
          var state = GenStateSuspendedStart

          return function invoke(method, arg) {
            if (state === GenStateExecuting) {
              throw new Error('Generator is already running')
            }

            if (state === GenStateCompleted) {
              if (method === 'throw') {
                throw arg
              }

              // Be forgiving, per 25.3.3.3.3 of the spec:
              // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
              return doneResult()
            }

            context.method = method
            context.arg = arg

            while (true) {
              var delegate = context.delegate
              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context)
                if (delegateResult) {
                  if (delegateResult === ContinueSentinel) continue
                  return delegateResult
                }
              }

              if (context.method === 'next') {
                // Setting context._sent for legacy support of Babel's
                // function.sent implementation.
                context.sent = context._sent = context.arg
              } else if (context.method === 'throw') {
                if (state === GenStateSuspendedStart) {
                  state = GenStateCompleted
                  throw context.arg
                }

                context.dispatchException(context.arg)
              } else if (context.method === 'return') {
                context.abrupt('return', context.arg)
              }

              state = GenStateExecuting

              var record = tryCatch(innerFn, self, context)
              if (record.type === 'normal') {
                // If an exception is thrown from innerFn, we leave state ===
                // GenStateExecuting and loop back for another invocation.
                state = context.done
                  ? GenStateCompleted
                  : GenStateSuspendedYield

                if (record.arg === ContinueSentinel) {
                  continue
                }

                return {
                  value: record.arg,
                  done: context.done,
                }
              } else if (record.type === 'throw') {
                state = GenStateCompleted
                // Dispatch the exception by looping back around to the
                // context.dispatchException(context.arg) call above.
                context.method = 'throw'
                context.arg = record.arg
              }
            }
          }
        }

        // Call delegate.iterator[context.method](context.arg) and handle the
        // result, either by returning a { value, done } result from the
        // delegate iterator, or by modifying context.method and context.arg,
        // setting context.delegate to null, and returning the ContinueSentinel.
        function maybeInvokeDelegate(delegate, context) {
          var method = delegate.iterator[context.method]
          if (method === undefined) {
            // A .throw or .return when the delegate iterator has no .throw
            // method always terminates the yield* loop.
            context.delegate = null

            if (context.method === 'throw') {
              // Note: ["return"] must be used for ES3 parsing compatibility.
              if (delegate.iterator['return']) {
                // If the delegate iterator has a return method, give it a
                // chance to clean up.
                context.method = 'return'
                context.arg = undefined
                maybeInvokeDelegate(delegate, context)

                if (context.method === 'throw') {
                  // If maybeInvokeDelegate(context) changed context.method from
                  // "return" to "throw", let that override the TypeError below.
                  return ContinueSentinel
                }
              }

              context.method = 'throw'
              context.arg = new TypeError(
                "The iterator does not provide a 'throw' method"
              )
            }

            return ContinueSentinel
          }

          var record = tryCatch(method, delegate.iterator, context.arg)

          if (record.type === 'throw') {
            context.method = 'throw'
            context.arg = record.arg
            context.delegate = null
            return ContinueSentinel
          }

          var info = record.arg

          if (!info) {
            context.method = 'throw'
            context.arg = new TypeError('iterator result is not an object')
            context.delegate = null
            return ContinueSentinel
          }

          if (info.done) {
            // Assign the result of the finished delegate to the temporary
            // variable specified by delegate.resultName (see delegateYield).
            context[delegate.resultName] = info.value

            // Resume execution at the desired location (see delegateYield).
            context.next = delegate.nextLoc

            // If context.method was "throw" but the delegate handled the
            // exception, let the outer generator proceed normally. If
            // context.method was "next", forget context.arg since it has been
            // "consumed" by the delegate iterator. If context.method was
            // "return", allow the original .return call to continue in the
            // outer generator.
            if (context.method !== 'return') {
              context.method = 'next'
              context.arg = undefined
            }
          } else {
            // Re-yield the result returned by the delegate method.
            return info
          }

          // The delegate iterator is finished, so forget it and continue with
          // the outer generator.
          context.delegate = null
          return ContinueSentinel
        }

        // Define Generator.prototype.{next,throw,return} in terms of the
        // unified ._invoke helper method.
        defineIteratorMethods(Gp)

        define(Gp, toStringTagSymbol, 'Generator')

        // A Generator should always return itself as the iterator object when the
        // @@iterator function is called on it. Some browsers' implementations of the
        // iterator prototype chain incorrectly implement this, causing the Generator
        // object to not be returned from this call. This ensures that doesn't happen.
        // See https://github.com/facebook/regenerator/issues/274 for more details.
        define(Gp, iteratorSymbol, function () {
          return this
        })

        define(Gp, 'toString', function () {
          return '[object Generator]'
        })

        function pushTryEntry(locs) {
          var entry = { tryLoc: locs[0] }

          if (1 in locs) {
            entry.catchLoc = locs[1]
          }

          if (2 in locs) {
            entry.finallyLoc = locs[2]
            entry.afterLoc = locs[3]
          }

          this.tryEntries.push(entry)
        }

        function resetTryEntry(entry) {
          var record = entry.completion || {}
          record.type = 'normal'
          delete record.arg
          entry.completion = record
        }

        function Context(tryLocsList) {
          // The root entry object (effectively a try statement without a catch
          // or a finally block) gives us a place to store values thrown from
          // locations where there is no enclosing try statement.
          this.tryEntries = [{ tryLoc: 'root' }]
          tryLocsList.forEach(pushTryEntry, this)
          this.reset(true)
        }

        exports.keys = function (object) {
          var keys = []
          for (var key in object) {
            keys.push(key)
          }
          keys.reverse()

          // Rather than returning an object with a next method, we keep
          // things simple and return the next function itself.
          return function next() {
            while (keys.length) {
              var key = keys.pop()
              if (key in object) {
                next.value = key
                next.done = false
                return next
              }
            }

            // To avoid creating an additional object, we just hang the .value
            // and .done properties off the next function object itself. This
            // also ensures that the minifier will not anonymize the function.
            next.done = true
            return next
          }
        }

        function values(iterable) {
          if (iterable) {
            var iteratorMethod = iterable[iteratorSymbol]
            if (iteratorMethod) {
              return iteratorMethod.call(iterable)
            }

            if (typeof iterable.next === 'function') {
              return iterable
            }

            if (!isNaN(iterable.length)) {
              var i = -1,
                next = function next() {
                  while (++i < iterable.length) {
                    if (hasOwn.call(iterable, i)) {
                      next.value = iterable[i]
                      next.done = false
                      return next
                    }
                  }

                  next.value = undefined
                  next.done = true

                  return next
                }

              return (next.next = next)
            }
          }

          // Return an iterator with no values.
          return { next: doneResult }
        }
        exports.values = values

        function doneResult() {
          return { value: undefined, done: true }
        }

        Context.prototype = {
          constructor: Context,

          reset: function (skipTempReset) {
            this.prev = 0
            this.next = 0
            // Resetting context._sent for legacy support of Babel's
            // function.sent implementation.
            this.sent = this._sent = undefined
            this.done = false
            this.delegate = null

            this.method = 'next'
            this.arg = undefined

            this.tryEntries.forEach(resetTryEntry)

            if (!skipTempReset) {
              for (var name in this) {
                // Not sure about the optimal order of these conditions:
                if (
                  name.charAt(0) === 't' &&
                  hasOwn.call(this, name) &&
                  !isNaN(+name.slice(1))
                ) {
                  this[name] = undefined
                }
              }
            }
          },

          stop: function () {
            this.done = true

            var rootEntry = this.tryEntries[0]
            var rootRecord = rootEntry.completion
            if (rootRecord.type === 'throw') {
              throw rootRecord.arg
            }

            return this.rval
          },

          dispatchException: function (exception) {
            if (this.done) {
              throw exception
            }

            var context = this
            function handle(loc, caught) {
              record.type = 'throw'
              record.arg = exception
              context.next = loc

              if (caught) {
                // If the dispatched exception was caught by a catch block,
                // then let that catch block handle the exception normally.
                context.method = 'next'
                context.arg = undefined
              }

              return !!caught
            }

            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i]
              var record = entry.completion

              if (entry.tryLoc === 'root') {
                // Exception thrown outside of any try block that could handle
                // it, so set the completion value of the entire function to
                // throw the exception.
                return handle('end')
              }

              if (entry.tryLoc <= this.prev) {
                var hasCatch = hasOwn.call(entry, 'catchLoc')
                var hasFinally = hasOwn.call(entry, 'finallyLoc')

                if (hasCatch && hasFinally) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true)
                  } else if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc)
                  }
                } else if (hasCatch) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true)
                  }
                } else if (hasFinally) {
                  if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc)
                  }
                } else {
                  throw new Error('try statement without catch or finally')
                }
              }
            }
          },

          abrupt: function (type, arg) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i]
              if (
                entry.tryLoc <= this.prev &&
                hasOwn.call(entry, 'finallyLoc') &&
                this.prev < entry.finallyLoc
              ) {
                var finallyEntry = entry
                break
              }
            }

            if (
              finallyEntry &&
              (type === 'break' || type === 'continue') &&
              finallyEntry.tryLoc <= arg &&
              arg <= finallyEntry.finallyLoc
            ) {
              // Ignore the finally entry if control is not jumping to a
              // location outside the try/catch block.
              finallyEntry = null
            }

            var record = finallyEntry ? finallyEntry.completion : {}
            record.type = type
            record.arg = arg

            if (finallyEntry) {
              this.method = 'next'
              this.next = finallyEntry.finallyLoc
              return ContinueSentinel
            }

            return this.complete(record)
          },

          complete: function (record, afterLoc) {
            if (record.type === 'throw') {
              throw record.arg
            }

            if (record.type === 'break' || record.type === 'continue') {
              this.next = record.arg
            } else if (record.type === 'return') {
              this.rval = this.arg = record.arg
              this.method = 'return'
              this.next = 'end'
            } else if (record.type === 'normal' && afterLoc) {
              this.next = afterLoc
            }

            return ContinueSentinel
          },

          finish: function (finallyLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i]
              if (entry.finallyLoc === finallyLoc) {
                this.complete(entry.completion, entry.afterLoc)
                resetTryEntry(entry)
                return ContinueSentinel
              }
            }
          },

          catch: function (tryLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i]
              if (entry.tryLoc === tryLoc) {
                var record = entry.completion
                if (record.type === 'throw') {
                  var thrown = record.arg
                  resetTryEntry(entry)
                }
                return thrown
              }
            }

            // The context.catch method must only be called with a location
            // argument that corresponds to a known catch block.
            throw new Error('illegal catch attempt')
          },

          delegateYield: function (iterable, resultName, nextLoc) {
            this.delegate = {
              iterator: values(iterable),
              resultName: resultName,
              nextLoc: nextLoc,
            }

            if (this.method === 'next') {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              this.arg = undefined
            }

            return ContinueSentinel
          },
        }

        // Regardless of whether this script is executing as a CommonJS module
        // or not, return the runtime object so that we can declare the variable
        // regeneratorRuntime in the outer scope, which allows this module to be
        // injected easily by `bin/regenerator --include-runtime script.js`.
        return exports
      })(
        // If this script is executing as a CommonJS module, use module.exports
        // as the regeneratorRuntime namespace. Otherwise create a new empty
        // object. Either way, the resulting object will be used to initialize
        // the regeneratorRuntime variable at the top of this file.
        true ? module.exports : 0
      )

      try {
        regeneratorRuntime = runtime
      } catch (accidentalStrictMode) {
        // This module should not be running in strict mode, so the above
        // assignment should always work unless something is misconfigured. Just
        // in case runtime.js accidentally runs in strict mode, in modern engines
        // we can explicitly access globalThis. In older engines we can escape
        // strict mode using a global Function call. This could conceivably fail
        // if a Content Security Policy forbids using Function, but in that case
        // the proper solution is to fix the accidental strict mode problem. If
        // you've misconfigured your bundler to force strict mode and applied a
        // CSP to forbid Function, and you're not willing to fix either of those
        // problems, please detail your unique predicament in a GitHub issue.
        if (typeof globalThis === 'object') {
          globalThis.regeneratorRuntime = runtime
        } else {
          Function('r', 'regeneratorRuntime = r')(runtime)
        }
      }

      /***/
    },

    /***/ 2113: /***/ module => {
      'use strict'

      function reusify(Constructor) {
        var head = new Constructor()
        var tail = head

        function get() {
          var current = head

          if (current.next) {
            head = current.next
          } else {
            head = new Constructor()
            tail = head
          }

          current.next = null

          return current
        }

        function release(obj) {
          tail.next = obj
          tail = obj
        }

        return {
          get: get,
          release: release,
        }
      }

      module.exports = reusify

      /***/
    },

    /***/ 5288: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      /*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
      module.exports = runParallel

      const queueMicrotask = __nccwpck_require__(9795)

      function runParallel(tasks, cb) {
        let results, pending, keys
        let isSync = true

        if (Array.isArray(tasks)) {
          results = []
          pending = tasks.length
        } else {
          keys = Object.keys(tasks)
          results = {}
          pending = keys.length
        }

        function done(err) {
          function end() {
            if (cb) cb(err, results)
            cb = null
          }
          if (isSync) queueMicrotask(end)
          else end()
        }

        function each(i, err, result) {
          results[i] = result
          if (--pending === 0 || err) {
            done(err)
          }
        }

        if (!pending) {
          // empty
          done(null)
        } else if (keys) {
          // object
          keys.forEach(function (key) {
            tasks[key](function (err, result) {
              each(key, err, result)
            })
          })
        } else {
          // array
          tasks.forEach(function (task, i) {
            task(function (err, result) {
              each(i, err, result)
            })
          })
        }

        isSync = false
      }

      /***/
    },

    /***/ 4931: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      // Note: since nyc uses this module to output coverage, any lines
      // that are in the direct sync flow of nyc's outputCoverage are
      // ignored, since we can never get coverage for them.
      // grab a reference to node's real process object right away
      var process = global.process

      const processOk = function (process) {
        return (
          process &&
          typeof process === 'object' &&
          typeof process.removeListener === 'function' &&
          typeof process.emit === 'function' &&
          typeof process.reallyExit === 'function' &&
          typeof process.listeners === 'function' &&
          typeof process.kill === 'function' &&
          typeof process.pid === 'number' &&
          typeof process.on === 'function'
        )
      }

      // some kind of non-node environment, just no-op
      /* istanbul ignore if */
      if (!processOk(process)) {
        module.exports = function () {
          return function () {}
        }
      } else {
        var assert = __nccwpck_require__(9491)
        var signals = __nccwpck_require__(3710)
        var isWin = /^win/i.test(process.platform)

        var EE = __nccwpck_require__(2361)
        /* istanbul ignore if */
        if (typeof EE !== 'function') {
          EE = EE.EventEmitter
        }

        var emitter
        if (process.__signal_exit_emitter__) {
          emitter = process.__signal_exit_emitter__
        } else {
          emitter = process.__signal_exit_emitter__ = new EE()
          emitter.count = 0
          emitter.emitted = {}
        }

        // Because this emitter is a global, we have to check to see if a
        // previous version of this library failed to enable infinite listeners.
        // I know what you're about to say.  But literally everything about
        // signal-exit is a compromise with evil.  Get used to it.
        if (!emitter.infinite) {
          emitter.setMaxListeners(Infinity)
          emitter.infinite = true
        }

        module.exports = function (cb, opts) {
          /* istanbul ignore if */
          if (!processOk(global.process)) {
            return function () {}
          }
          assert.equal(
            typeof cb,
            'function',
            'a callback must be provided for exit handler'
          )

          if (loaded === false) {
            load()
          }

          var ev = 'exit'
          if (opts && opts.alwaysLast) {
            ev = 'afterexit'
          }

          var remove = function () {
            emitter.removeListener(ev, cb)
            if (
              emitter.listeners('exit').length === 0 &&
              emitter.listeners('afterexit').length === 0
            ) {
              unload()
            }
          }
          emitter.on(ev, cb)

          return remove
        }

        var unload = function unload() {
          if (!loaded || !processOk(global.process)) {
            return
          }
          loaded = false

          signals.forEach(function (sig) {
            try {
              process.removeListener(sig, sigListeners[sig])
            } catch (er) {}
          })
          process.emit = originalProcessEmit
          process.reallyExit = originalProcessReallyExit
          emitter.count -= 1
        }
        module.exports.unload = unload

        var emit = function emit(event, code, signal) {
          /* istanbul ignore if */
          if (emitter.emitted[event]) {
            return
          }
          emitter.emitted[event] = true
          emitter.emit(event, code, signal)
        }

        // { <signal>: <listener fn>, ... }
        var sigListeners = {}
        signals.forEach(function (sig) {
          sigListeners[sig] = function listener() {
            /* istanbul ignore if */
            if (!processOk(global.process)) {
              return
            }
            // If there are no other listeners, an exit is coming!
            // Simplest way: remove us and then re-send the signal.
            // We know that this will kill the process, so we can
            // safely emit now.
            var listeners = process.listeners(sig)
            if (listeners.length === emitter.count) {
              unload()
              emit('exit', null, sig)
              /* istanbul ignore next */
              emit('afterexit', null, sig)
              /* istanbul ignore next */
              if (isWin && sig === 'SIGHUP') {
                // "SIGHUP" throws an `ENOSYS` error on Windows,
                // so use a supported signal instead
                sig = 'SIGINT'
              }
              /* istanbul ignore next */
              process.kill(process.pid, sig)
            }
          }
        })

        module.exports.signals = function () {
          return signals
        }

        var loaded = false

        var load = function load() {
          if (loaded || !processOk(global.process)) {
            return
          }
          loaded = true

          // This is the number of onSignalExit's that are in play.
          // It's important so that we can count the correct number of
          // listeners on signals, and don't wait for the other one to
          // handle it instead of us.
          emitter.count += 1

          signals = signals.filter(function (sig) {
            try {
              process.on(sig, sigListeners[sig])
              return true
            } catch (er) {
              return false
            }
          })

          process.emit = processEmit
          process.reallyExit = processReallyExit
        }
        module.exports.load = load

        var originalProcessReallyExit = process.reallyExit
        var processReallyExit = function processReallyExit(code) {
          /* istanbul ignore if */
          if (!processOk(global.process)) {
            return
          }
          process.exitCode = code || /* istanbul ignore next */ 0
          emit('exit', process.exitCode, null)
          /* istanbul ignore next */
          emit('afterexit', process.exitCode, null)
          /* istanbul ignore next */
          originalProcessReallyExit.call(process, process.exitCode)
        }

        var originalProcessEmit = process.emit
        var processEmit = function processEmit(ev, arg) {
          if (ev === 'exit' && processOk(global.process)) {
            /* istanbul ignore else */
            if (arg !== undefined) {
              process.exitCode = arg
            }
            var ret = originalProcessEmit.apply(this, arguments)
            /* istanbul ignore next */
            emit('exit', process.exitCode, null)
            /* istanbul ignore next */
            emit('afterexit', process.exitCode, null)
            /* istanbul ignore next */
            return ret
          } else {
            return originalProcessEmit.apply(this, arguments)
          }
        }
      }

      /***/
    },

    /***/ 3710: /***/ module => {
      // This is not the set of all possible signals.
      //
      // It IS, however, the set of all signals that trigger
      // an exit on either Linux or BSD systems.  Linux is a
      // superset of the signal names supported on BSD, and
      // the unknown signals just fail to register, so we can
      // catch that easily enough.
      //
      // Don't bother with SIGKILL.  It's uncatchable, which
      // means that we can't fire any callbacks anyway.
      //
      // If a user does happen to register a handler on a non-
      // fatal signal like SIGWINCH or something, and then
      // exit, it'll end up firing `process.emit('exit')`, so
      // the handler will be fired anyway.
      //
      // SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
      // artificially, inherently leave the process in a
      // state from which it is not safe to try and enter JS
      // listeners.
      module.exports = ['SIGABRT', 'SIGALRM', 'SIGHUP', 'SIGINT', 'SIGTERM']

      if (process.platform !== 'win32') {
        module.exports.push(
          'SIGVTALRM',
          'SIGXCPU',
          'SIGXFSZ',
          'SIGUSR2',
          'SIGTRAP',
          'SIGSYS',
          'SIGQUIT',
          'SIGIOT'
          // should detect profiler and enable/disable accordingly.
          // see #21
          // 'SIGPROF'
        )
      }

      if (process.platform === 'linux') {
        module.exports.push(
          'SIGIO',
          'SIGPOLL',
          'SIGPWR',
          'SIGSTKFLT',
          'SIGUNUSED'
        )
      }

      /***/
    },

    /***/ 4111: /***/ module => {
      'use strict'

      module.exports = path => {
        const isExtendedLengthPath = /^\\\\\?\\/.test(path)
        const hasNonAscii = /[^\u0000-\u0080]+/.test(path) // eslint-disable-line no-control-regex

        if (isExtendedLengthPath || hasNonAscii) {
          return path
        }

        return path.replace(/\\/g, '/')
      }

      /***/
    },

    /***/ 4374: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'
      // @flow

      const crossSpawn = __nccwpck_require__(6923)
      const onExit = __nccwpck_require__(4931)
      const EventEmitter = __nccwpck_require__(2361)
      const ChildProcessPromise = __nccwpck_require__(606)

      const activeProcesses = new Set()

      onExit(() => {
        for (let child of activeProcesses) {
          child.kill('SIGTERM')
        }
      })

      function spawn(
        cmd /*: string */,
        args /*:: ?: Array<string> */,
        opts /*:: ?: child_process$spawnOpts */
      ) /*: ChildProcessPromise */ {
        return new ChildProcessPromise((resolve, reject, events) => {
          let child = crossSpawn(cmd, args, opts)
          let stdout = Buffer.from('')
          let stderr = Buffer.from('')

          activeProcesses.add(child)

          if (child.stdout) {
            child.stdout.on('data', data => {
              stdout = Buffer.concat([stdout, data])
              events.emit('stdout', data)
            })
          }

          if (child.stderr) {
            child.stderr.on('data', data => {
              stderr = Buffer.concat([stderr, data])
              events.emit('stderr', data)
            })
          }

          child.on('error', err => {
            activeProcesses.delete(child)
            reject(err)
          })

          child.on('close', code => {
            activeProcesses.delete(child)
            resolve({ code, stdout, stderr })
          })
        })
      }

      module.exports = spawn
      module.exports.ChildProcessPromise = ChildProcessPromise

      /***/
    },

    /***/ 6923: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var cp = __nccwpck_require__(2081)
      var parse = __nccwpck_require__(1165)
      var enoent = __nccwpck_require__(295)

      var cpSpawnSync = cp.spawnSync

      function spawn(command, args, options) {
        var parsed
        var spawned

        // Parse the arguments
        parsed = parse(command, args, options)

        // Spawn the child process
        spawned = cp.spawn(parsed.command, parsed.args, parsed.options)

        // Hook into child process "exit" event to emit an error if the command
        // does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
        enoent.hookChildProcess(spawned, parsed)

        return spawned
      }

      function spawnSync(command, args, options) {
        var parsed
        var result

        if (!cpSpawnSync) {
          try {
            cpSpawnSync = __nccwpck_require__(5500) // eslint-disable-line global-require
          } catch (ex) {
            throw new Error(
              'In order to use spawnSync on node 0.10 or older, you must ' +
                'install spawn-sync:\n\n' +
                '  npm install spawn-sync --save'
            )
          }
        }

        // Parse the arguments
        parsed = parse(command, args, options)

        // Spawn the child process
        result = cpSpawnSync(parsed.command, parsed.args, parsed.options)

        // Analyze if the command does not exists, see: https://github.com/IndigoUnited/node-cross-spawn/issues/16
        result.error =
          result.error || enoent.verifyENOENTSync(result.status, parsed)

        return result
      }

      module.exports = spawn
      module.exports.spawn = spawn
      module.exports.sync = spawnSync

      module.exports._parse = parse
      module.exports._enoent = enoent

      /***/
    },

    /***/ 295: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var isWin = process.platform === 'win32'
      var resolveCommand = __nccwpck_require__(5505)

      var isNode10 = process.version.indexOf('v0.10.') === 0

      function notFoundError(command, syscall) {
        var err

        err = new Error(syscall + ' ' + command + ' ENOENT')
        err.code = err.errno = 'ENOENT'
        err.syscall = syscall + ' ' + command

        return err
      }

      function hookChildProcess(cp, parsed) {
        var originalEmit

        if (!isWin) {
          return
        }

        originalEmit = cp.emit
        cp.emit = function (name, arg1) {
          var err

          // If emitting "exit" event and exit code is 1, we need to check if
          // the command exists and emit an "error" instead
          // See: https://github.com/IndigoUnited/node-cross-spawn/issues/16
          if (name === 'exit') {
            err = verifyENOENT(arg1, parsed, 'spawn')

            if (err) {
              return originalEmit.call(cp, 'error', err)
            }
          }

          return originalEmit.apply(cp, arguments)
        }
      }

      function verifyENOENT(status, parsed) {
        if (isWin && status === 1 && !parsed.file) {
          return notFoundError(parsed.original, 'spawn')
        }

        return null
      }

      function verifyENOENTSync(status, parsed) {
        if (isWin && status === 1 && !parsed.file) {
          return notFoundError(parsed.original, 'spawnSync')
        }

        // If we are in node 10, then we are using spawn-sync; if it exited
        // with -1 it probably means that the command does not exist
        if (isNode10 && status === -1) {
          parsed.file = isWin ? parsed.file : resolveCommand(parsed.original)

          if (!parsed.file) {
            return notFoundError(parsed.original, 'spawnSync')
          }
        }

        return null
      }

      module.exports.hookChildProcess = hookChildProcess
      module.exports.verifyENOENT = verifyENOENT
      module.exports.verifyENOENTSync = verifyENOENTSync
      module.exports.notFoundError = notFoundError

      /***/
    },

    /***/ 1165: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var resolveCommand = __nccwpck_require__(5505)
      var hasEmptyArgumentBug = __nccwpck_require__(6090)
      var escapeArgument = __nccwpck_require__(2024)
      var escapeCommand = __nccwpck_require__(3598)
      var readShebang = __nccwpck_require__(3415)

      var isWin = process.platform === 'win32'
      var skipShellRegExp = /\.(?:com|exe)$/i

      // Supported in Node >= 6 and >= 4.8
      var supportsShellOption =
        parseInt(process.version.substr(1).split('.')[0], 10) >= 6 ||
        (parseInt(process.version.substr(1).split('.')[0], 10) === 4 &&
          parseInt(process.version.substr(1).split('.')[1], 10) >= 8)

      function parseNonShell(parsed) {
        var shebang
        var needsShell
        var applyQuotes

        if (!isWin) {
          return parsed
        }

        // Detect & add support for shebangs
        parsed.file = resolveCommand(parsed.command)
        parsed.file = parsed.file || resolveCommand(parsed.command, true)
        shebang = parsed.file && readShebang(parsed.file)

        if (shebang) {
          parsed.args.unshift(parsed.file)
          parsed.command = shebang
          needsShell =
            hasEmptyArgumentBug ||
            !skipShellRegExp.test(
              resolveCommand(shebang) || resolveCommand(shebang, true)
            )
        } else {
          needsShell = hasEmptyArgumentBug || !skipShellRegExp.test(parsed.file)
        }

        // If a shell is required, use cmd.exe and take care of escaping everything correctly
        if (needsShell) {
          // Escape command & arguments
          applyQuotes = parsed.command !== 'echo' // Do not quote arguments for the special "echo" command
          parsed.command = escapeCommand(parsed.command)
          parsed.args = parsed.args.map(function (arg) {
            return escapeArgument(arg, applyQuotes)
          })

          // Make use of cmd.exe
          parsed.args = [
            '/d',
            '/s',
            '/c',
            '"' +
              parsed.command +
              (parsed.args.length ? ' ' + parsed.args.join(' ') : '') +
              '"',
          ]
          parsed.command = process.env.comspec || 'cmd.exe'
          parsed.options.windowsVerbatimArguments = true // Tell node's spawn that the arguments are already escaped
        }

        return parsed
      }

      function parseShell(parsed) {
        var shellCommand

        // If node supports the shell option, there's no need to mimic its behavior
        if (supportsShellOption) {
          return parsed
        }

        // Mimic node shell option, see: https://github.com/nodejs/node/blob/b9f6a2dc059a1062776133f3d4fd848c4da7d150/lib/child_process.js#L335
        shellCommand = [parsed.command].concat(parsed.args).join(' ')

        if (isWin) {
          parsed.command =
            typeof parsed.options.shell === 'string'
              ? parsed.options.shell
              : process.env.comspec || 'cmd.exe'
          parsed.args = ['/d', '/s', '/c', '"' + shellCommand + '"']
          parsed.options.windowsVerbatimArguments = true // Tell node's spawn that the arguments are already escaped
        } else {
          if (typeof parsed.options.shell === 'string') {
            parsed.command = parsed.options.shell
          } else if (process.platform === 'android') {
            parsed.command = '/system/bin/sh'
          } else {
            parsed.command = '/bin/sh'
          }

          parsed.args = ['-c', shellCommand]
        }

        return parsed
      }

      // ------------------------------------------------

      function parse(command, args, options) {
        var parsed

        // Normalize arguments, similar to nodejs
        if (args && !Array.isArray(args)) {
          options = args
          args = null
        }

        args = args ? args.slice(0) : [] // Clone array to avoid changing the original
        options = options || {}

        // Build our parsed object
        parsed = {
          command: command,
          args: args,
          options: options,
          file: undefined,
          original: command,
        }

        // Delegate further parsing to shell or non-shell
        return options.shell ? parseShell(parsed) : parseNonShell(parsed)
      }

      module.exports = parse

      /***/
    },

    /***/ 2024: /***/ module => {
      'use strict'

      function escapeArgument(arg, quote) {
        // Convert to string
        arg = '' + arg

        // If we are not going to quote the argument,
        // escape shell metacharacters, including double and single quotes:
        if (!quote) {
          arg = arg.replace(/([()%!^<>&|;,"'\s])/g, '^$1')
        } else {
          // Sequence of backslashes followed by a double quote:
          // double up all the backslashes and escape the double quote
          arg = arg.replace(/(\\*)"/g, '$1$1\\"')

          // Sequence of backslashes followed by the end of the string
          // (which will become a double quote later):
          // double up all the backslashes
          arg = arg.replace(/(\\*)$/, '$1$1')

          // All other backslashes occur literally

          // Quote the whole thing:
          arg = '"' + arg + '"'
        }

        return arg
      }

      module.exports = escapeArgument

      /***/
    },

    /***/ 3598: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var escapeArgument = __nccwpck_require__(2024)

      function escapeCommand(command) {
        // Do not escape if this command is not dangerous..
        // We do this so that commands like "echo" or "ifconfig" work
        // Quoting them, will make them unaccessible
        return /^[a-z0-9_-]+$/i.test(command)
          ? command
          : escapeArgument(command, true)
      }

      module.exports = escapeCommand

      /***/
    },

    /***/ 6090: /***/ module => {
      'use strict'

      // See: https://github.com/IndigoUnited/node-cross-spawn/pull/34#issuecomment-221623455
      function hasEmptyArgumentBug() {
        var nodeVer

        if (process.platform !== 'win32') {
          return false
        }

        nodeVer = process.version
          .substr(1)
          .split('.')
          .map(function (num) {
            return parseInt(num, 10)
          })

        return nodeVer[0] === 0 && nodeVer[1] < 12
      }

      module.exports = hasEmptyArgumentBug()

      /***/
    },

    /***/ 3415: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var fs = __nccwpck_require__(7147)
      var LRU = __nccwpck_require__(8252)
      var shebangCommand = __nccwpck_require__(6526)

      var shebangCache = new LRU({ max: 50, maxAge: 30 * 1000 }) // Cache just for 30sec

      function readShebang(command) {
        var buffer
        var fd
        var shebang

        // Check if it is in the cache first
        if (shebangCache.has(command)) {
          return shebangCache.get(command)
        }

        // Read the first 150 bytes from the file
        buffer = new Buffer(150)

        try {
          fd = fs.openSync(command, 'r')
          fs.readSync(fd, buffer, 0, 150, 0)
          fs.closeSync(fd)
        } catch (e) {
          /* empty */
        }

        // Attempt to extract shebang (null is returned if not a shebang)
        shebang = shebangCommand(buffer.toString())

        // Store the shebang in the cache
        shebangCache.set(command, shebang)

        return shebang
      }

      module.exports = readShebang

      /***/
    },

    /***/ 5505: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var path = __nccwpck_require__(1017)
      var which = __nccwpck_require__(4207)
      var LRU = __nccwpck_require__(8252)

      var commandCache = new LRU({ max: 50, maxAge: 30 * 1000 }) // Cache just for 30sec

      function resolveCommand(command, noExtension) {
        var resolved

        noExtension = !!noExtension
        resolved = commandCache.get(command + '!' + noExtension)

        // Check if its resolved in the cache
        if (commandCache.has(command)) {
          return commandCache.get(command)
        }

        try {
          resolved = !noExtension
            ? which.sync(command)
            : which.sync(command, {
                pathExt: path.delimiter + (process.env.PATHEXT || ''),
              })
        } catch (e) {
          /* empty */
        }

        commandCache.set(command + '!' + noExtension, resolved)

        return resolved
      }

      module.exports = resolveCommand

      /***/
    },

    /***/ 8252: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      module.exports = LRUCache

      // This will be a proper iterable 'Map' in engines that support it,
      // or a fakey-fake PseudoMap in older versions.
      var Map = __nccwpck_require__(3541)
      var util = __nccwpck_require__(3837)

      // A linked list to keep track of recently-used-ness
      var Yallist = __nccwpck_require__(1238)

      // use symbols if possible, otherwise just _props
      var hasSymbol =
        typeof Symbol === 'function' &&
        process.env._nodeLRUCacheForceNoSymbol !== '1'
      var makeSymbol
      if (hasSymbol) {
        makeSymbol = function (key) {
          return Symbol(key)
        }
      } else {
        makeSymbol = function (key) {
          return '_' + key
        }
      }

      var MAX = makeSymbol('max')
      var LENGTH = makeSymbol('length')
      var LENGTH_CALCULATOR = makeSymbol('lengthCalculator')
      var ALLOW_STALE = makeSymbol('allowStale')
      var MAX_AGE = makeSymbol('maxAge')
      var DISPOSE = makeSymbol('dispose')
      var NO_DISPOSE_ON_SET = makeSymbol('noDisposeOnSet')
      var LRU_LIST = makeSymbol('lruList')
      var CACHE = makeSymbol('cache')

      function naiveLength() {
        return 1
      }

      // lruList is a yallist where the head is the youngest
      // item, and the tail is the oldest.  the list contains the Hit
      // objects as the entries.
      // Each Hit object has a reference to its Yallist.Node.  This
      // never changes.
      //
      // cache is a Map (or PseudoMap) that matches the keys to
      // the Yallist.Node object.
      function LRUCache(options) {
        if (!(this instanceof LRUCache)) {
          return new LRUCache(options)
        }

        if (typeof options === 'number') {
          options = { max: options }
        }

        if (!options) {
          options = {}
        }

        var max = (this[MAX] = options.max)
        // Kind of weird to have a default max of Infinity, but oh well.
        if (!max || !(typeof max === 'number') || max <= 0) {
          this[MAX] = Infinity
        }

        var lc = options.length || naiveLength
        if (typeof lc !== 'function') {
          lc = naiveLength
        }
        this[LENGTH_CALCULATOR] = lc

        this[ALLOW_STALE] = options.stale || false
        this[MAX_AGE] = options.maxAge || 0
        this[DISPOSE] = options.dispose
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
        this.reset()
      }

      // resize the cache when the max changes.
      Object.defineProperty(LRUCache.prototype, 'max', {
        set: function (mL) {
          if (!mL || !(typeof mL === 'number') || mL <= 0) {
            mL = Infinity
          }
          this[MAX] = mL
          trim(this)
        },
        get: function () {
          return this[MAX]
        },
        enumerable: true,
      })

      Object.defineProperty(LRUCache.prototype, 'allowStale', {
        set: function (allowStale) {
          this[ALLOW_STALE] = !!allowStale
        },
        get: function () {
          return this[ALLOW_STALE]
        },
        enumerable: true,
      })

      Object.defineProperty(LRUCache.prototype, 'maxAge', {
        set: function (mA) {
          if (!mA || !(typeof mA === 'number') || mA < 0) {
            mA = 0
          }
          this[MAX_AGE] = mA
          trim(this)
        },
        get: function () {
          return this[MAX_AGE]
        },
        enumerable: true,
      })

      // resize the cache when the lengthCalculator changes.
      Object.defineProperty(LRUCache.prototype, 'lengthCalculator', {
        set: function (lC) {
          if (typeof lC !== 'function') {
            lC = naiveLength
          }
          if (lC !== this[LENGTH_CALCULATOR]) {
            this[LENGTH_CALCULATOR] = lC
            this[LENGTH] = 0
            this[LRU_LIST].forEach(function (hit) {
              hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
              this[LENGTH] += hit.length
            }, this)
          }
          trim(this)
        },
        get: function () {
          return this[LENGTH_CALCULATOR]
        },
        enumerable: true,
      })

      Object.defineProperty(LRUCache.prototype, 'length', {
        get: function () {
          return this[LENGTH]
        },
        enumerable: true,
      })

      Object.defineProperty(LRUCache.prototype, 'itemCount', {
        get: function () {
          return this[LRU_LIST].length
        },
        enumerable: true,
      })

      LRUCache.prototype.rforEach = function (fn, thisp) {
        thisp = thisp || this
        for (var walker = this[LRU_LIST].tail; walker !== null; ) {
          var prev = walker.prev
          forEachStep(this, fn, walker, thisp)
          walker = prev
        }
      }

      function forEachStep(self, fn, node, thisp) {
        var hit = node.value
        if (isStale(self, hit)) {
          del(self, node)
          if (!self[ALLOW_STALE]) {
            hit = undefined
          }
        }
        if (hit) {
          fn.call(thisp, hit.value, hit.key, self)
        }
      }

      LRUCache.prototype.forEach = function (fn, thisp) {
        thisp = thisp || this
        for (var walker = this[LRU_LIST].head; walker !== null; ) {
          var next = walker.next
          forEachStep(this, fn, walker, thisp)
          walker = next
        }
      }

      LRUCache.prototype.keys = function () {
        return this[LRU_LIST].toArray().map(function (k) {
          return k.key
        }, this)
      }

      LRUCache.prototype.values = function () {
        return this[LRU_LIST].toArray().map(function (k) {
          return k.value
        }, this)
      }

      LRUCache.prototype.reset = function () {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach(function (hit) {
            this[DISPOSE](hit.key, hit.value)
          }, this)
        }

        this[CACHE] = new Map() // hash of items by key
        this[LRU_LIST] = new Yallist() // list of items in order of use recency
        this[LENGTH] = 0 // length of items in the list
      }

      LRUCache.prototype.dump = function () {
        return this[LRU_LIST].map(function (hit) {
          if (!isStale(this, hit)) {
            return {
              k: hit.key,
              v: hit.value,
              e: hit.now + (hit.maxAge || 0),
            }
          }
        }, this)
          .toArray()
          .filter(function (h) {
            return h
          })
      }

      LRUCache.prototype.dumpLru = function () {
        return this[LRU_LIST]
      }

      /* istanbul ignore next */
      LRUCache.prototype.inspect = function (n, opts) {
        var str = 'LRUCache {'
        var extras = false

        var as = this[ALLOW_STALE]
        if (as) {
          str += '\n  allowStale: true'
          extras = true
        }

        var max = this[MAX]
        if (max && max !== Infinity) {
          if (extras) {
            str += ','
          }
          str += '\n  max: ' + util.inspect(max, opts)
          extras = true
        }

        var maxAge = this[MAX_AGE]
        if (maxAge) {
          if (extras) {
            str += ','
          }
          str += '\n  maxAge: ' + util.inspect(maxAge, opts)
          extras = true
        }

        var lc = this[LENGTH_CALCULATOR]
        if (lc && lc !== naiveLength) {
          if (extras) {
            str += ','
          }
          str += '\n  length: ' + util.inspect(this[LENGTH], opts)
          extras = true
        }

        var didFirst = false
        this[LRU_LIST].forEach(function (item) {
          if (didFirst) {
            str += ',\n  '
          } else {
            if (extras) {
              str += ',\n'
            }
            didFirst = true
            str += '\n  '
          }
          var key = util.inspect(item.key).split('\n').join('\n  ')
          var val = { value: item.value }
          if (item.maxAge !== maxAge) {
            val.maxAge = item.maxAge
          }
          if (lc !== naiveLength) {
            val.length = item.length
          }
          if (isStale(this, item)) {
            val.stale = true
          }

          val = util.inspect(val, opts).split('\n').join('\n  ')
          str += key + ' => ' + val
        })

        if (didFirst || extras) {
          str += '\n'
        }
        str += '}'

        return str
      }

      LRUCache.prototype.set = function (key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE]

        var now = maxAge ? Date.now() : 0
        var len = this[LENGTH_CALCULATOR](value, key)

        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key))
            return false
          }

          var node = this[CACHE].get(key)
          var item = node.value

          // dispose of the old one before overwriting
          // split out into 2 ifs for better coverage tracking
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET]) {
              this[DISPOSE](key, item.value)
            }
          }

          item.now = now
          item.maxAge = maxAge
          item.value = value
          this[LENGTH] += len - item.length
          item.length = len
          this.get(key)
          trim(this)
          return true
        }

        var hit = new Entry(key, value, len, now, maxAge)

        // oversized objects fall out of cache automatically.
        if (hit.length > this[MAX]) {
          if (this[DISPOSE]) {
            this[DISPOSE](key, value)
          }
          return false
        }

        this[LENGTH] += hit.length
        this[LRU_LIST].unshift(hit)
        this[CACHE].set(key, this[LRU_LIST].head)
        trim(this)
        return true
      }

      LRUCache.prototype.has = function (key) {
        if (!this[CACHE].has(key)) return false
        var hit = this[CACHE].get(key).value
        if (isStale(this, hit)) {
          return false
        }
        return true
      }

      LRUCache.prototype.get = function (key) {
        return get(this, key, true)
      }

      LRUCache.prototype.peek = function (key) {
        return get(this, key, false)
      }

      LRUCache.prototype.pop = function () {
        var node = this[LRU_LIST].tail
        if (!node) return null
        del(this, node)
        return node.value
      }

      LRUCache.prototype.del = function (key) {
        del(this, this[CACHE].get(key))
      }

      LRUCache.prototype.load = function (arr) {
        // reset the cache
        this.reset()

        var now = Date.now()
        // A previous serialized cache has the most recent items first
        for (var l = arr.length - 1; l >= 0; l--) {
          var hit = arr[l]
          var expiresAt = hit.e || 0
          if (expiresAt === 0) {
            // the item was created without expiration in a non aged cache
            this.set(hit.k, hit.v)
          } else {
            var maxAge = expiresAt - now
            // dont add already expired items
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge)
            }
          }
        }
      }

      LRUCache.prototype.prune = function () {
        var self = this
        this[CACHE].forEach(function (value, key) {
          get(self, key, false)
        })
      }

      function get(self, key, doUse) {
        var node = self[CACHE].get(key)
        if (node) {
          var hit = node.value
          if (isStale(self, hit)) {
            del(self, node)
            if (!self[ALLOW_STALE]) hit = undefined
          } else {
            if (doUse) {
              self[LRU_LIST].unshiftNode(node)
            }
          }
          if (hit) hit = hit.value
        }
        return hit
      }

      function isStale(self, hit) {
        if (!hit || (!hit.maxAge && !self[MAX_AGE])) {
          return false
        }
        var stale = false
        var diff = Date.now() - hit.now
        if (hit.maxAge) {
          stale = diff > hit.maxAge
        } else {
          stale = self[MAX_AGE] && diff > self[MAX_AGE]
        }
        return stale
      }

      function trim(self) {
        if (self[LENGTH] > self[MAX]) {
          for (
            var walker = self[LRU_LIST].tail;
            self[LENGTH] > self[MAX] && walker !== null;

          ) {
            // We know that we're about to delete this one, and also
            // what the next least recently used key will be, so just
            // go ahead and set it now.
            var prev = walker.prev
            del(self, walker)
            walker = prev
          }
        }
      }

      function del(self, node) {
        if (node) {
          var hit = node.value
          if (self[DISPOSE]) {
            self[DISPOSE](hit.key, hit.value)
          }
          self[LENGTH] -= hit.length
          self[CACHE].delete(hit.key)
          self[LRU_LIST].removeNode(node)
        }
      }

      // classy, since V8 prefers predictable objects.
      function Entry(key, value, length, now, maxAge) {
        this.key = key
        this.value = value
        this.length = length
        this.now = now
        this.maxAge = maxAge || 0
      }

      /***/
    },

    /***/ 6526: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var shebangRegex = __nccwpck_require__(947)

      module.exports = function (str) {
        var match = str.match(shebangRegex)

        if (!match) {
          return null
        }

        var arr = match[0].replace(/#! ?/, '').split(' ')
        var bin = arr[0].split('/').pop()
        var arg = arr[1]

        return bin === 'env' ? arg : bin + (arg ? ' ' + arg : '')
      }

      /***/
    },

    /***/ 947: /***/ module => {
      'use strict'

      module.exports = /^#!.*/

      /***/
    },

    /***/ 1238: /***/ module => {
      module.exports = Yallist

      Yallist.Node = Node
      Yallist.create = Yallist

      function Yallist(list) {
        var self = this
        if (!(self instanceof Yallist)) {
          self = new Yallist()
        }

        self.tail = null
        self.head = null
        self.length = 0

        if (list && typeof list.forEach === 'function') {
          list.forEach(function (item) {
            self.push(item)
          })
        } else if (arguments.length > 0) {
          for (var i = 0, l = arguments.length; i < l; i++) {
            self.push(arguments[i])
          }
        }

        return self
      }

      Yallist.prototype.removeNode = function (node) {
        if (node.list !== this) {
          throw new Error('removing node which does not belong to this list')
        }

        var next = node.next
        var prev = node.prev

        if (next) {
          next.prev = prev
        }

        if (prev) {
          prev.next = next
        }

        if (node === this.head) {
          this.head = next
        }
        if (node === this.tail) {
          this.tail = prev
        }

        node.list.length--
        node.next = null
        node.prev = null
        node.list = null
      }

      Yallist.prototype.unshiftNode = function (node) {
        if (node === this.head) {
          return
        }

        if (node.list) {
          node.list.removeNode(node)
        }

        var head = this.head
        node.list = this
        node.next = head
        if (head) {
          head.prev = node
        }

        this.head = node
        if (!this.tail) {
          this.tail = node
        }
        this.length++
      }

      Yallist.prototype.pushNode = function (node) {
        if (node === this.tail) {
          return
        }

        if (node.list) {
          node.list.removeNode(node)
        }

        var tail = this.tail
        node.list = this
        node.prev = tail
        if (tail) {
          tail.next = node
        }

        this.tail = node
        if (!this.head) {
          this.head = node
        }
        this.length++
      }

      Yallist.prototype.push = function () {
        for (var i = 0, l = arguments.length; i < l; i++) {
          push(this, arguments[i])
        }
        return this.length
      }

      Yallist.prototype.unshift = function () {
        for (var i = 0, l = arguments.length; i < l; i++) {
          unshift(this, arguments[i])
        }
        return this.length
      }

      Yallist.prototype.pop = function () {
        if (!this.tail) {
          return undefined
        }

        var res = this.tail.value
        this.tail = this.tail.prev
        if (this.tail) {
          this.tail.next = null
        } else {
          this.head = null
        }
        this.length--
        return res
      }

      Yallist.prototype.shift = function () {
        if (!this.head) {
          return undefined
        }

        var res = this.head.value
        this.head = this.head.next
        if (this.head) {
          this.head.prev = null
        } else {
          this.tail = null
        }
        this.length--
        return res
      }

      Yallist.prototype.forEach = function (fn, thisp) {
        thisp = thisp || this
        for (var walker = this.head, i = 0; walker !== null; i++) {
          fn.call(thisp, walker.value, i, this)
          walker = walker.next
        }
      }

      Yallist.prototype.forEachReverse = function (fn, thisp) {
        thisp = thisp || this
        for (
          var walker = this.tail, i = this.length - 1;
          walker !== null;
          i--
        ) {
          fn.call(thisp, walker.value, i, this)
          walker = walker.prev
        }
      }

      Yallist.prototype.get = function (n) {
        for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
          // abort out of the list early if we hit a cycle
          walker = walker.next
        }
        if (i === n && walker !== null) {
          return walker.value
        }
      }

      Yallist.prototype.getReverse = function (n) {
        for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
          // abort out of the list early if we hit a cycle
          walker = walker.prev
        }
        if (i === n && walker !== null) {
          return walker.value
        }
      }

      Yallist.prototype.map = function (fn, thisp) {
        thisp = thisp || this
        var res = new Yallist()
        for (var walker = this.head; walker !== null; ) {
          res.push(fn.call(thisp, walker.value, this))
          walker = walker.next
        }
        return res
      }

      Yallist.prototype.mapReverse = function (fn, thisp) {
        thisp = thisp || this
        var res = new Yallist()
        for (var walker = this.tail; walker !== null; ) {
          res.push(fn.call(thisp, walker.value, this))
          walker = walker.prev
        }
        return res
      }

      Yallist.prototype.reduce = function (fn, initial) {
        var acc
        var walker = this.head
        if (arguments.length > 1) {
          acc = initial
        } else if (this.head) {
          walker = this.head.next
          acc = this.head.value
        } else {
          throw new TypeError('Reduce of empty list with no initial value')
        }

        for (var i = 0; walker !== null; i++) {
          acc = fn(acc, walker.value, i)
          walker = walker.next
        }

        return acc
      }

      Yallist.prototype.reduceReverse = function (fn, initial) {
        var acc
        var walker = this.tail
        if (arguments.length > 1) {
          acc = initial
        } else if (this.tail) {
          walker = this.tail.prev
          acc = this.tail.value
        } else {
          throw new TypeError('Reduce of empty list with no initial value')
        }

        for (var i = this.length - 1; walker !== null; i--) {
          acc = fn(acc, walker.value, i)
          walker = walker.prev
        }

        return acc
      }

      Yallist.prototype.toArray = function () {
        var arr = new Array(this.length)
        for (var i = 0, walker = this.head; walker !== null; i++) {
          arr[i] = walker.value
          walker = walker.next
        }
        return arr
      }

      Yallist.prototype.toArrayReverse = function () {
        var arr = new Array(this.length)
        for (var i = 0, walker = this.tail; walker !== null; i++) {
          arr[i] = walker.value
          walker = walker.prev
        }
        return arr
      }

      Yallist.prototype.slice = function (from, to) {
        to = to || this.length
        if (to < 0) {
          to += this.length
        }
        from = from || 0
        if (from < 0) {
          from += this.length
        }
        var ret = new Yallist()
        if (to < from || to < 0) {
          return ret
        }
        if (from < 0) {
          from = 0
        }
        if (to > this.length) {
          to = this.length
        }
        for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
          walker = walker.next
        }
        for (; walker !== null && i < to; i++, walker = walker.next) {
          ret.push(walker.value)
        }
        return ret
      }

      Yallist.prototype.sliceReverse = function (from, to) {
        to = to || this.length
        if (to < 0) {
          to += this.length
        }
        from = from || 0
        if (from < 0) {
          from += this.length
        }
        var ret = new Yallist()
        if (to < from || to < 0) {
          return ret
        }
        if (from < 0) {
          from = 0
        }
        if (to > this.length) {
          to = this.length
        }
        for (
          var i = this.length, walker = this.tail;
          walker !== null && i > to;
          i--
        ) {
          walker = walker.prev
        }
        for (; walker !== null && i > from; i--, walker = walker.prev) {
          ret.push(walker.value)
        }
        return ret
      }

      Yallist.prototype.reverse = function () {
        var head = this.head
        var tail = this.tail
        for (var walker = head; walker !== null; walker = walker.prev) {
          var p = walker.prev
          walker.prev = walker.next
          walker.next = p
        }
        this.head = tail
        this.tail = head
        return this
      }

      function push(self, item) {
        self.tail = new Node(item, self.tail, null, self)
        if (!self.head) {
          self.head = self.tail
        }
        self.length++
      }

      function unshift(self, item) {
        self.head = new Node(item, null, self.head, self)
        if (!self.tail) {
          self.tail = self.head
        }
        self.length++
      }

      function Node(value, prev, next, list) {
        if (!(this instanceof Node)) {
          return new Node(value, prev, next, list)
        }

        this.list = list
        this.value = value

        if (prev) {
          prev.next = this
          this.prev = prev
        } else {
          this.prev = null
        }

        if (next) {
          next.prev = this
          this.next = next
        } else {
          this.next = null
        }
      }

      /***/
    },

    /***/ 606: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'

      const EventEmitter = __nccwpck_require__(2361)

      class ChildProcessPromise extends Promise {
        constructor(executer) {
          let resolve
          let reject

          super((res, rej) => {
            resolve = res
            reject = rej
          })

          executer(resolve, reject, this)
        }
      }

      Object.assign(ChildProcessPromise.prototype, EventEmitter.prototype)

      module.exports = ChildProcessPromise

      /***/
    },

    /***/ 8551: /***/ module => {
      'use strict'

      module.exports = x => {
        if (typeof x !== 'string') {
          throw new TypeError('Expected a string, got ' + typeof x)
        }

        // Catches EFBBBF (UTF-8 BOM) because the buffer-to-string
        // conversion translates it to FEFF (UTF-16 BOM)
        if (x.charCodeAt(0) === 0xfeff) {
          return x.slice(1)
        }

        return x
      }

      /***/
    },

    /***/ 1861: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      'use strict'
      /*!
       * to-regex-range <https://github.com/micromatch/to-regex-range>
       *
       * Copyright (c) 2015-present, Jon Schlinkert.
       * Released under the MIT License.
       */

      const isNumber = __nccwpck_require__(5680)

      const toRegexRange = (min, max, options) => {
        if (isNumber(min) === false) {
          throw new TypeError(
            'toRegexRange: expected the first argument to be a number'
          )
        }

        if (max === void 0 || min === max) {
          return String(min)
        }

        if (isNumber(max) === false) {
          throw new TypeError(
            'toRegexRange: expected the second argument to be a number.'
          )
        }

        let opts = { relaxZeros: true, ...options }
        if (typeof opts.strictZeros === 'boolean') {
          opts.relaxZeros = opts.strictZeros === false
        }

        let relax = String(opts.relaxZeros)
        let shorthand = String(opts.shorthand)
        let capture = String(opts.capture)
        let wrap = String(opts.wrap)
        let cacheKey =
          min + ':' + max + '=' + relax + shorthand + capture + wrap

        if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
          return toRegexRange.cache[cacheKey].result
        }

        let a = Math.min(min, max)
        let b = Math.max(min, max)

        if (Math.abs(a - b) === 1) {
          let result = min + '|' + max
          if (opts.capture) {
            return `(${result})`
          }
          if (opts.wrap === false) {
            return result
          }
          return `(?:${result})`
        }

        let isPadded = hasPadding(min) || hasPadding(max)
        let state = { min, max, a, b }
        let positives = []
        let negatives = []

        if (isPadded) {
          state.isPadded = isPadded
          state.maxLen = String(state.max).length
        }

        if (a < 0) {
          let newMin = b < 0 ? Math.abs(b) : 1
          negatives = splitToPatterns(newMin, Math.abs(a), state, opts)
          a = state.a = 0
        }

        if (b >= 0) {
          positives = splitToPatterns(a, b, state, opts)
        }

        state.negatives = negatives
        state.positives = positives
        state.result = collatePatterns(negatives, positives, opts)

        if (opts.capture === true) {
          state.result = `(${state.result})`
        } else if (
          opts.wrap !== false &&
          positives.length + negatives.length > 1
        ) {
          state.result = `(?:${state.result})`
        }

        toRegexRange.cache[cacheKey] = state
        return state.result
      }

      function collatePatterns(neg, pos, options) {
        let onlyNegative = filterPatterns(neg, pos, '-', false, options) || []
        let onlyPositive = filterPatterns(pos, neg, '', false, options) || []
        let intersected = filterPatterns(neg, pos, '-?', true, options) || []
        let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive)
        return subpatterns.join('|')
      }

      function splitToRanges(min, max) {
        let nines = 1
        let zeros = 1

        let stop = countNines(min, nines)
        let stops = new Set([max])

        while (min <= stop && stop <= max) {
          stops.add(stop)
          nines += 1
          stop = countNines(min, nines)
        }

        stop = countZeros(max + 1, zeros) - 1

        while (min < stop && stop <= max) {
          stops.add(stop)
          zeros += 1
          stop = countZeros(max + 1, zeros) - 1
        }

        stops = [...stops]
        stops.sort(compare)
        return stops
      }

      /**
       * Convert a range to a regex pattern
       * @param {Number} `start`
       * @param {Number} `stop`
       * @return {String}
       */

      function rangeToPattern(start, stop, options) {
        if (start === stop) {
          return { pattern: start, count: [], digits: 0 }
        }

        let zipped = zip(start, stop)
        let digits = zipped.length
        let pattern = ''
        let count = 0

        for (let i = 0; i < digits; i++) {
          let [startDigit, stopDigit] = zipped[i]

          if (startDigit === stopDigit) {
            pattern += startDigit
          } else if (startDigit !== '0' || stopDigit !== '9') {
            pattern += toCharacterClass(startDigit, stopDigit, options)
          } else {
            count++
          }
        }

        if (count) {
          pattern += options.shorthand === true ? '\\d' : '[0-9]'
        }

        return { pattern, count: [count], digits }
      }

      function splitToPatterns(min, max, tok, options) {
        let ranges = splitToRanges(min, max)
        let tokens = []
        let start = min
        let prev

        for (let i = 0; i < ranges.length; i++) {
          let max = ranges[i]
          let obj = rangeToPattern(String(start), String(max), options)
          let zeros = ''

          if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
            if (prev.count.length > 1) {
              prev.count.pop()
            }

            prev.count.push(obj.count[0])
            prev.string = prev.pattern + toQuantifier(prev.count)
            start = max + 1
            continue
          }

          if (tok.isPadded) {
            zeros = padZeros(max, tok, options)
          }

          obj.string = zeros + obj.pattern + toQuantifier(obj.count)
          tokens.push(obj)
          start = max + 1
          prev = obj
        }

        return tokens
      }

      function filterPatterns(arr, comparison, prefix, intersection, options) {
        let result = []

        for (let ele of arr) {
          let { string } = ele

          // only push if _both_ are negative...
          if (!intersection && !contains(comparison, 'string', string)) {
            result.push(prefix + string)
          }

          // or _both_ are positive
          if (intersection && contains(comparison, 'string', string)) {
            result.push(prefix + string)
          }
        }
        return result
      }

      /**
       * Zip strings
       */

      function zip(a, b) {
        let arr = []
        for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]])
        return arr
      }

      function compare(a, b) {
        return a > b ? 1 : b > a ? -1 : 0
      }

      function contains(arr, key, val) {
        return arr.some(ele => ele[key] === val)
      }

      function countNines(min, len) {
        return Number(String(min).slice(0, -len) + '9'.repeat(len))
      }

      function countZeros(integer, zeros) {
        return integer - (integer % Math.pow(10, zeros))
      }

      function toQuantifier(digits) {
        let [start = 0, stop = ''] = digits
        if (stop || start > 1) {
          return `{${start + (stop ? ',' + stop : '')}}`
        }
        return ''
      }

      function toCharacterClass(a, b, options) {
        return `[${a}${b - a === 1 ? '' : '-'}${b}]`
      }

      function hasPadding(str) {
        return /^-?(0+)\d/.test(str)
      }

      function padZeros(value, tok, options) {
        if (!tok.isPadded) {
          return value
        }

        let diff = Math.abs(tok.maxLen - String(value).length)
        let relax = options.relaxZeros !== false

        switch (diff) {
          case 0:
            return ''
          case 1:
            return relax ? '0?' : '0'
          case 2:
            return relax ? '0{0,2}' : '00'
          default: {
            return relax ? `0{0,${diff}}` : `0{${diff}}`
          }
        }
      }

      /**
       * Cache
       */

      toRegexRange.cache = {}
      toRegexRange.clearCache = () => (toRegexRange.cache = {})

      /**
       * Expose `toRegexRange`
       */

      module.exports = toRegexRange

      /***/
    },

    /***/ 4294: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      module.exports = __nccwpck_require__(4219)

      /***/
    },

    /***/ 4219: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      var net = __nccwpck_require__(1808)
      var tls = __nccwpck_require__(4404)
      var http = __nccwpck_require__(3685)
      var https = __nccwpck_require__(5687)
      var events = __nccwpck_require__(2361)
      var assert = __nccwpck_require__(9491)
      var util = __nccwpck_require__(3837)

      exports.httpOverHttp = httpOverHttp
      exports.httpsOverHttp = httpsOverHttp
      exports.httpOverHttps = httpOverHttps
      exports.httpsOverHttps = httpsOverHttps

      function httpOverHttp(options) {
        var agent = new TunnelingAgent(options)
        agent.request = http.request
        return agent
      }

      function httpsOverHttp(options) {
        var agent = new TunnelingAgent(options)
        agent.request = http.request
        agent.createSocket = createSecureSocket
        agent.defaultPort = 443
        return agent
      }

      function httpOverHttps(options) {
        var agent = new TunnelingAgent(options)
        agent.request = https.request
        return agent
      }

      function httpsOverHttps(options) {
        var agent = new TunnelingAgent(options)
        agent.request = https.request
        agent.createSocket = createSecureSocket
        agent.defaultPort = 443
        return agent
      }

      function TunnelingAgent(options) {
        var self = this
        self.options = options || {}
        self.proxyOptions = self.options.proxy || {}
        self.maxSockets =
          self.options.maxSockets || http.Agent.defaultMaxSockets
        self.requests = []
        self.sockets = []

        self.on('free', function onFree(socket, host, port, localAddress) {
          var options = toOptions(host, port, localAddress)
          for (var i = 0, len = self.requests.length; i < len; ++i) {
            var pending = self.requests[i]
            if (
              pending.host === options.host &&
              pending.port === options.port
            ) {
              // Detect the request to connect same origin server,
              // reuse the connection.
              self.requests.splice(i, 1)
              pending.request.onSocket(socket)
              return
            }
          }
          socket.destroy()
          self.removeSocket(socket)
        })
      }
      util.inherits(TunnelingAgent, events.EventEmitter)

      TunnelingAgent.prototype.addRequest = function addRequest(
        req,
        host,
        port,
        localAddress
      ) {
        var self = this
        var options = mergeOptions(
          { request: req },
          self.options,
          toOptions(host, port, localAddress)
        )

        if (self.sockets.length >= this.maxSockets) {
          // We are over limit so we'll add it to the queue.
          self.requests.push(options)
          return
        }

        // If we are under maxSockets create a new one.
        self.createSocket(options, function (socket) {
          socket.on('free', onFree)
          socket.on('close', onCloseOrRemove)
          socket.on('agentRemove', onCloseOrRemove)
          req.onSocket(socket)

          function onFree() {
            self.emit('free', socket, options)
          }

          function onCloseOrRemove(err) {
            self.removeSocket(socket)
            socket.removeListener('free', onFree)
            socket.removeListener('close', onCloseOrRemove)
            socket.removeListener('agentRemove', onCloseOrRemove)
          }
        })
      }

      TunnelingAgent.prototype.createSocket = function createSocket(
        options,
        cb
      ) {
        var self = this
        var placeholder = {}
        self.sockets.push(placeholder)

        var connectOptions = mergeOptions({}, self.proxyOptions, {
          method: 'CONNECT',
          path: options.host + ':' + options.port,
          agent: false,
          headers: {
            host: options.host + ':' + options.port,
          },
        })
        if (options.localAddress) {
          connectOptions.localAddress = options.localAddress
        }
        if (connectOptions.proxyAuth) {
          connectOptions.headers = connectOptions.headers || {}
          connectOptions.headers['Proxy-Authorization'] =
            'Basic ' + new Buffer(connectOptions.proxyAuth).toString('base64')
        }

        debug('making CONNECT request')
        var connectReq = self.request(connectOptions)
        connectReq.useChunkedEncodingByDefault = false // for v0.6
        connectReq.once('response', onResponse) // for v0.6
        connectReq.once('upgrade', onUpgrade) // for v0.6
        connectReq.once('connect', onConnect) // for v0.7 or later
        connectReq.once('error', onError)
        connectReq.end()

        function onResponse(res) {
          // Very hacky. This is necessary to avoid http-parser leaks.
          res.upgrade = true
        }

        function onUpgrade(res, socket, head) {
          // Hacky.
          process.nextTick(function () {
            onConnect(res, socket, head)
          })
        }

        function onConnect(res, socket, head) {
          connectReq.removeAllListeners()
          socket.removeAllListeners()

          if (res.statusCode !== 200) {
            debug(
              'tunneling socket could not be established, statusCode=%d',
              res.statusCode
            )
            socket.destroy()
            var error = new Error(
              'tunneling socket could not be established, ' +
                'statusCode=' +
                res.statusCode
            )
            error.code = 'ECONNRESET'
            options.request.emit('error', error)
            self.removeSocket(placeholder)
            return
          }
          if (head.length > 0) {
            debug('got illegal response body from proxy')
            socket.destroy()
            var error = new Error('got illegal response body from proxy')
            error.code = 'ECONNRESET'
            options.request.emit('error', error)
            self.removeSocket(placeholder)
            return
          }
          debug('tunneling connection has established')
          self.sockets[self.sockets.indexOf(placeholder)] = socket
          return cb(socket)
        }

        function onError(cause) {
          connectReq.removeAllListeners()

          debug(
            'tunneling socket could not be established, cause=%s\n',
            cause.message,
            cause.stack
          )
          var error = new Error(
            'tunneling socket could not be established, ' +
              'cause=' +
              cause.message
          )
          error.code = 'ECONNRESET'
          options.request.emit('error', error)
          self.removeSocket(placeholder)
        }
      }

      TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
        var pos = this.sockets.indexOf(socket)
        if (pos === -1) {
          return
        }
        this.sockets.splice(pos, 1)

        var pending = this.requests.shift()
        if (pending) {
          // If we have pending requests and a socket gets closed a new one
          // needs to be created to take over in the pool for the one that closed.
          this.createSocket(pending, function (socket) {
            pending.request.onSocket(socket)
          })
        }
      }

      function createSecureSocket(options, cb) {
        var self = this
        TunnelingAgent.prototype.createSocket.call(
          self,
          options,
          function (socket) {
            var hostHeader = options.request.getHeader('host')
            var tlsOptions = mergeOptions({}, self.options, {
              socket: socket,
              servername: hostHeader
                ? hostHeader.replace(/:.*$/, '')
                : options.host,
            })

            // 0 is dummy port for v0.6
            var secureSocket = tls.connect(0, tlsOptions)
            self.sockets[self.sockets.indexOf(socket)] = secureSocket
            cb(secureSocket)
          }
        )
      }

      function toOptions(host, port, localAddress) {
        if (typeof host === 'string') {
          // since v0.10
          return {
            host: host,
            port: port,
            localAddress: localAddress,
          }
        }
        return host // for v0.11 or later
      }

      function mergeOptions(target) {
        for (var i = 1, len = arguments.length; i < len; ++i) {
          var overrides = arguments[i]
          if (typeof overrides === 'object') {
            var keys = Object.keys(overrides)
            for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
              var k = keys[j]
              if (overrides[k] !== undefined) {
                target[k] = overrides[k]
              }
            }
          }
        }
        return target
      }

      var debug
      if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
        debug = function () {
          var args = Array.prototype.slice.call(arguments)
          if (typeof args[0] === 'string') {
            args[0] = 'TUNNEL: ' + args[0]
          } else {
            args.unshift('TUNNEL:')
          }
          console.error.apply(console, args)
        }
      } else {
        debug = function () {}
      }
      exports.debug = debug // for test

      /***/
    },

    /***/ 9046: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      exports.E = function (fn) {
        return Object.defineProperty(
          function () {
            if (typeof arguments[arguments.length - 1] === 'function')
              fn.apply(this, arguments)
            else {
              return new Promise((resolve, reject) => {
                arguments[arguments.length] = (err, res) => {
                  if (err) return reject(err)
                  resolve(res)
                }
                arguments.length++
                fn.apply(this, arguments)
              })
            }
          },
          'name',
          { value: fn.name }
        )
      }

      exports.p = function (fn) {
        return Object.defineProperty(
          function () {
            const cb = arguments[arguments.length - 1]
            if (typeof cb !== 'function') return fn.apply(this, arguments)
            else fn.apply(this, arguments).then(r => cb(null, r), cb)
          },
          'name',
          { value: fn.name }
        )
      }

      /***/
    },

    /***/ 5840: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: true,
      })
      Object.defineProperty(exports, 'v1', {
        enumerable: true,
        get: function () {
          return _v.default
        },
      })
      Object.defineProperty(exports, 'v3', {
        enumerable: true,
        get: function () {
          return _v2.default
        },
      })
      Object.defineProperty(exports, 'v4', {
        enumerable: true,
        get: function () {
          return _v3.default
        },
      })
      Object.defineProperty(exports, 'v5', {
        enumerable: true,
        get: function () {
          return _v4.default
        },
      })
      Object.defineProperty(exports, 'NIL', {
        enumerable: true,
        get: function () {
          return _nil.default
        },
      })
      Object.defineProperty(exports, 'version', {
        enumerable: true,
        get: function () {
          return _version.default
        },
      })
      Object.defineProperty(exports, 'validate', {
        enumerable: true,
        get: function () {
          return _validate.default
        },
      })
      Object.defineProperty(exports, 'stringify', {
        enumerable: true,
        get: function () {
          return _stringify.default
        },
      })
      Object.defineProperty(exports, 'parse', {
        enumerable: true,
        get: function () {
          return _parse.default
        },
      })

      var _v = _interopRequireDefault(__nccwpck_require__(8628))

      var _v2 = _interopRequireDefault(__nccwpck_require__(6409))

      var _v3 = _interopRequireDefault(__nccwpck_require__(5122))

      var _v4 = _interopRequireDefault(__nccwpck_require__(9120))

      var _nil = _interopRequireDefault(__nccwpck_require__(5332))

      var _version = _interopRequireDefault(__nccwpck_require__(1595))

      var _validate = _interopRequireDefault(__nccwpck_require__(6900))

      var _stringify = _interopRequireDefault(__nccwpck_require__(8950))

      var _parse = _interopRequireDefault(__nccwpck_require__(2746))

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj }
      }

      /***/
    },

    /***/ 4569: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: true,
      })
      exports['default'] = void 0

      var _crypto = _interopRequireDefault(__nccwpck_require__(6113))

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj }
      }

      function md5(bytes) {
        if (Array.isArray(bytes)) {
          bytes = Buffer.from(bytes)
        } else if (typeof bytes === 'string') {
          bytes = Buffer.from(bytes, 'utf8')
        }

        return _crypto.default.createHash('md5').update(bytes).digest()
      }

      var _default = md5
      exports['default'] = _default

      /***/
    },

    /***/ 5332: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: true,
      })
      exports['default'] = void 0
      var _default = '00000000-0000-0000-0000-000000000000'
      exports['default'] = _default

      /***/
    },

    /***/ 2746: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: true,
      })
      exports['default'] = void 0

      var _validate = _interopRequireDefault(__nccwpck_require__(6900))

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj }
      }

      function parse(uuid) {
        if (!(0, _validate.default)(uuid)) {
          throw TypeError('Invalid UUID')
        }

        let v
        const arr = new Uint8Array(16) // Parse ########-....-....-....-............

        arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24
        arr[1] = (v >>> 16) & 0xff
        arr[2] = (v >>> 8) & 0xff
        arr[3] = v & 0xff // Parse ........-####-....-....-............

        arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8
        arr[5] = v & 0xff // Parse ........-....-####-....-............

        arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8
        arr[7] = v & 0xff // Parse ........-....-....-####-............

        arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8
        arr[9] = v & 0xff // Parse ........-....-....-....-############
        // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

        arr[10] =
          ((v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000) & 0xff
        arr[11] = (v / 0x100000000) & 0xff
        arr[12] = (v >>> 24) & 0xff
        arr[13] = (v >>> 16) & 0xff
        arr[14] = (v >>> 8) & 0xff
        arr[15] = v & 0xff
        return arr
      }

      var _default = parse
      exports['default'] = _default

      /***/
    },

    /***/ 814: /***/ (__unused_webpack_module, exports) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: true,
      })
      exports['default'] = void 0
      var _default =
        /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i
      exports['default'] = _default

      /***/
    },

    /***/ 807: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: true,
      })
      exports['default'] = rng

      var _crypto = _interopRequireDefault(__nccwpck_require__(6113))

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj }
      }

      const rnds8Pool = new Uint8Array(256) // # of random values to pre-allocate

      let poolPtr = rnds8Pool.length

      function rng() {
        if (poolPtr > rnds8Pool.length - 16) {
          _crypto.default.randomFillSync(rnds8Pool)

          poolPtr = 0
        }

        return rnds8Pool.slice(poolPtr, (poolPtr += 16))
      }

      /***/
    },

    /***/ 5274: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: true,
      })
      exports['default'] = void 0

      var _crypto = _interopRequireDefault(__nccwpck_require__(6113))

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj }
      }

      function sha1(bytes) {
        if (Array.isArray(bytes)) {
          bytes = Buffer.from(bytes)
        } else if (typeof bytes === 'string') {
          bytes = Buffer.from(bytes, 'utf8')
        }

        return _crypto.default.createHash('sha1').update(bytes).digest()
      }

      var _default = sha1
      exports['default'] = _default

      /***/
    },

    /***/ 8950: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: true,
      })
      exports['default'] = void 0

      var _validate = _interopRequireDefault(__nccwpck_require__(6900))

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj }
      }

      /**
       * Convert array of 16 byte values to UUID string format of the form:
       * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
       */
      const byteToHex = []

      for (let i = 0; i < 256; ++i) {
        byteToHex.push((i + 0x100).toString(16).substr(1))
      }

      function stringify(arr, offset = 0) {
        // Note: Be careful editing this code!  It's been tuned for performance
        // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
        const uuid = (
          byteToHex[arr[offset + 0]] +
          byteToHex[arr[offset + 1]] +
          byteToHex[arr[offset + 2]] +
          byteToHex[arr[offset + 3]] +
          '-' +
          byteToHex[arr[offset + 4]] +
          byteToHex[arr[offset + 5]] +
          '-' +
          byteToHex[arr[offset + 6]] +
          byteToHex[arr[offset + 7]] +
          '-' +
          byteToHex[arr[offset + 8]] +
          byteToHex[arr[offset + 9]] +
          '-' +
          byteToHex[arr[offset + 10]] +
          byteToHex[arr[offset + 11]] +
          byteToHex[arr[offset + 12]] +
          byteToHex[arr[offset + 13]] +
          byteToHex[arr[offset + 14]] +
          byteToHex[arr[offset + 15]]
        ).toLowerCase() // Consistency check for valid UUID.  If this throws, it's likely due to one
        // of the following:
        // - One or more input array values don't map to a hex octet (leading to
        // "undefined" in the uuid)
        // - Invalid input values for the RFC `version` or `variant` fields

        if (!(0, _validate.default)(uuid)) {
          throw TypeError('Stringified UUID is invalid')
        }

        return uuid
      }

      var _default = stringify
      exports['default'] = _default

      /***/
    },

    /***/ 8628: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: true,
      })
      exports['default'] = void 0

      var _rng = _interopRequireDefault(__nccwpck_require__(807))

      var _stringify = _interopRequireDefault(__nccwpck_require__(8950))

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj }
      }

      // **`v1()` - Generate time-based UUID**
      //
      // Inspired by https://github.com/LiosK/UUID.js
      // and http://docs.python.org/library/uuid.html
      let _nodeId

      let _clockseq // Previous uuid creation time

      let _lastMSecs = 0
      let _lastNSecs = 0 // See https://github.com/uuidjs/uuid for API details

      function v1(options, buf, offset) {
        let i = (buf && offset) || 0
        const b = buf || new Array(16)
        options = options || {}
        let node = options.node || _nodeId
        let clockseq =
          options.clockseq !== undefined ? options.clockseq : _clockseq // node and clockseq need to be initialized to random values if they're not
        // specified.  We do this lazily to minimize issues related to insufficient
        // system entropy.  See #189

        if (node == null || clockseq == null) {
          const seedBytes = options.random || (options.rng || _rng.default)()

          if (node == null) {
            // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
            node = _nodeId = [
              seedBytes[0] | 0x01,
              seedBytes[1],
              seedBytes[2],
              seedBytes[3],
              seedBytes[4],
              seedBytes[5],
            ]
          }

          if (clockseq == null) {
            // Per 4.2.2, randomize (14 bit) clockseq
            clockseq = _clockseq = ((seedBytes[6] << 8) | seedBytes[7]) & 0x3fff
          }
        } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
        // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
        // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
        // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.

        let msecs = options.msecs !== undefined ? options.msecs : Date.now() // Per 4.2.1.2, use count of uuid's generated during the current clock
        // cycle to simulate higher resolution clock

        let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1 // Time since last uuid creation (in msecs)

        const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000 // Per 4.2.1.2, Bump clockseq on clock regression

        if (dt < 0 && options.clockseq === undefined) {
          clockseq = (clockseq + 1) & 0x3fff
        } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
        // time interval

        if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
          nsecs = 0
        } // Per 4.2.1.2 Throw error if too many uuids are requested

        if (nsecs >= 10000) {
          throw new Error("uuid.v1(): Can't create more than 10M uuids/sec")
        }

        _lastMSecs = msecs
        _lastNSecs = nsecs
        _clockseq = clockseq // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

        msecs += 12219292800000 // `time_low`

        const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000
        b[i++] = (tl >>> 24) & 0xff
        b[i++] = (tl >>> 16) & 0xff
        b[i++] = (tl >>> 8) & 0xff
        b[i++] = tl & 0xff // `time_mid`

        const tmh = ((msecs / 0x100000000) * 10000) & 0xfffffff
        b[i++] = (tmh >>> 8) & 0xff
        b[i++] = tmh & 0xff // `time_high_and_version`

        b[i++] = ((tmh >>> 24) & 0xf) | 0x10 // include version

        b[i++] = (tmh >>> 16) & 0xff // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

        b[i++] = (clockseq >>> 8) | 0x80 // `clock_seq_low`

        b[i++] = clockseq & 0xff // `node`

        for (let n = 0; n < 6; ++n) {
          b[i + n] = node[n]
        }

        return buf || (0, _stringify.default)(b)
      }

      var _default = v1
      exports['default'] = _default

      /***/
    },

    /***/ 6409: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: true,
      })
      exports['default'] = void 0

      var _v = _interopRequireDefault(__nccwpck_require__(5998))

      var _md = _interopRequireDefault(__nccwpck_require__(4569))

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj }
      }

      const v3 = (0, _v.default)('v3', 0x30, _md.default)
      var _default = v3
      exports['default'] = _default

      /***/
    },

    /***/ 5998: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: true,
      })
      exports['default'] = _default
      exports.URL = exports.DNS = void 0

      var _stringify = _interopRequireDefault(__nccwpck_require__(8950))

      var _parse = _interopRequireDefault(__nccwpck_require__(2746))

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj }
      }

      function stringToBytes(str) {
        str = unescape(encodeURIComponent(str)) // UTF8 escape

        const bytes = []

        for (let i = 0; i < str.length; ++i) {
          bytes.push(str.charCodeAt(i))
        }

        return bytes
      }

      const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8'
      exports.DNS = DNS
      const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8'
      exports.URL = URL

      function _default(name, version, hashfunc) {
        function generateUUID(value, namespace, buf, offset) {
          if (typeof value === 'string') {
            value = stringToBytes(value)
          }

          if (typeof namespace === 'string') {
            namespace = (0, _parse.default)(namespace)
          }

          if (namespace.length !== 16) {
            throw TypeError(
              'Namespace must be array-like (16 iterable integer values, 0-255)'
            )
          } // Compute hash of namespace and value, Per 4.3
          // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
          // hashfunc([...namespace, ... value])`

          let bytes = new Uint8Array(16 + value.length)
          bytes.set(namespace)
          bytes.set(value, namespace.length)
          bytes = hashfunc(bytes)
          bytes[6] = (bytes[6] & 0x0f) | version
          bytes[8] = (bytes[8] & 0x3f) | 0x80

          if (buf) {
            offset = offset || 0

            for (let i = 0; i < 16; ++i) {
              buf[offset + i] = bytes[i]
            }

            return buf
          }

          return (0, _stringify.default)(bytes)
        } // Function#name is not settable on some platforms (#270)

        try {
          generateUUID.name = name // eslint-disable-next-line no-empty
        } catch (err) {} // For CommonJS default export support

        generateUUID.DNS = DNS
        generateUUID.URL = URL
        return generateUUID
      }

      /***/
    },

    /***/ 5122: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: true,
      })
      exports['default'] = void 0

      var _rng = _interopRequireDefault(__nccwpck_require__(807))

      var _stringify = _interopRequireDefault(__nccwpck_require__(8950))

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj }
      }

      function v4(options, buf, offset) {
        options = options || {}

        const rnds = options.random || (options.rng || _rng.default)() // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

        rnds[6] = (rnds[6] & 0x0f) | 0x40
        rnds[8] = (rnds[8] & 0x3f) | 0x80 // Copy bytes to buffer, if provided

        if (buf) {
          offset = offset || 0

          for (let i = 0; i < 16; ++i) {
            buf[offset + i] = rnds[i]
          }

          return buf
        }

        return (0, _stringify.default)(rnds)
      }

      var _default = v4
      exports['default'] = _default

      /***/
    },

    /***/ 9120: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: true,
      })
      exports['default'] = void 0

      var _v = _interopRequireDefault(__nccwpck_require__(5998))

      var _sha = _interopRequireDefault(__nccwpck_require__(5274))

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj }
      }

      const v5 = (0, _v.default)('v5', 0x50, _sha.default)
      var _default = v5
      exports['default'] = _default

      /***/
    },

    /***/ 6900: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: true,
      })
      exports['default'] = void 0

      var _regex = _interopRequireDefault(__nccwpck_require__(814))

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj }
      }

      function validate(uuid) {
        return typeof uuid === 'string' && _regex.default.test(uuid)
      }

      var _default = validate
      exports['default'] = _default

      /***/
    },

    /***/ 1595: /***/ (
      __unused_webpack_module,
      exports,
      __nccwpck_require__
    ) => {
      'use strict'

      Object.defineProperty(exports, '__esModule', {
        value: true,
      })
      exports['default'] = void 0

      var _validate = _interopRequireDefault(__nccwpck_require__(6900))

      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj }
      }

      function version(uuid) {
        if (!(0, _validate.default)(uuid)) {
          throw TypeError('Invalid UUID')
        }

        return parseInt(uuid.substr(14, 1), 16)
      }

      var _default = version
      exports['default'] = _default

      /***/
    },

    /***/ 4207: /***/ (
      module,
      __unused_webpack_exports,
      __nccwpck_require__
    ) => {
      module.exports = which
      which.sync = whichSync

      var isWindows =
        process.platform === 'win32' ||
        process.env.OSTYPE === 'cygwin' ||
        process.env.OSTYPE === 'msys'

      var path = __nccwpck_require__(1017)
      var COLON = isWindows ? ';' : ':'
      var isexe = __nccwpck_require__(7126)

      function getNotFoundError(cmd) {
        var er = new Error('not found: ' + cmd)
        er.code = 'ENOENT'

        return er
      }

      function getPathInfo(cmd, opt) {
        var colon = opt.colon || COLON
        var pathEnv = opt.path || process.env.PATH || ''
        var pathExt = ['']

        pathEnv = pathEnv.split(colon)

        var pathExtExe = ''
        if (isWindows) {
          pathEnv.unshift(process.cwd())
          pathExtExe =
            opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM'
          pathExt = pathExtExe.split(colon)

          // Always test the cmd itself first.  isexe will check to make sure
          // it's found in the pathExt set.
          if (cmd.indexOf('.') !== -1 && pathExt[0] !== '') pathExt.unshift('')
        }

        // If it has a slash, then we don't bother searching the pathenv.
        // just check the file itself, and that's it.
        if (cmd.match(/\//) || (isWindows && cmd.match(/\\/))) pathEnv = ['']

        return {
          env: pathEnv,
          ext: pathExt,
          extExe: pathExtExe,
        }
      }

      function which(cmd, opt, cb) {
        if (typeof opt === 'function') {
          cb = opt
          opt = {}
        }

        var info = getPathInfo(cmd, opt)
        var pathEnv = info.env
        var pathExt = info.ext
        var pathExtExe = info.extExe
        var found = []

        ;(function F(i, l) {
          if (i === l) {
            if (opt.all && found.length) return cb(null, found)
            else return cb(getNotFoundError(cmd))
          }

          var pathPart = pathEnv[i]
          if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
            pathPart = pathPart.slice(1, -1)

          var p = path.join(pathPart, cmd)
          if (!pathPart && /^\.[\\\/]/.test(cmd)) {
            p = cmd.slice(0, 2) + p
          }
          ;(function E(ii, ll) {
            if (ii === ll) return F(i + 1, l)
            var ext = pathExt[ii]
            isexe(p + ext, { pathExt: pathExtExe }, function (er, is) {
              if (!er && is) {
                if (opt.all) found.push(p + ext)
                else return cb(null, p + ext)
              }
              return E(ii + 1, ll)
            })
          })(0, pathExt.length)
        })(0, pathEnv.length)
      }

      function whichSync(cmd, opt) {
        opt = opt || {}

        var info = getPathInfo(cmd, opt)
        var pathEnv = info.env
        var pathExt = info.ext
        var pathExtExe = info.extExe
        var found = []

        for (var i = 0, l = pathEnv.length; i < l; i++) {
          var pathPart = pathEnv[i]
          if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
            pathPart = pathPart.slice(1, -1)

          var p = path.join(pathPart, cmd)
          if (!pathPart && /^\.[\\\/]/.test(cmd)) {
            p = cmd.slice(0, 2) + p
          }
          for (var j = 0, ll = pathExt.length; j < ll; j++) {
            var cur = p + pathExt[j]
            var is
            try {
              is = isexe.sync(cur, { pathExt: pathExtExe })
              if (is) {
                if (opt.all) found.push(cur)
                else return cur
              }
            } catch (ex) {}
          }
        }

        if (opt.all && found.length) return found

        if (opt.nothrow) return null

        throw getNotFoundError(cmd)
      }

      /***/
    },

    /***/ 5500: /***/ module => {
      module.exports = eval('require')('spawn-sync')

      /***/
    },

    /***/ 9491: /***/ module => {
      'use strict'
      module.exports = require('assert')

      /***/
    },

    /***/ 2081: /***/ module => {
      'use strict'
      module.exports = require('child_process')

      /***/
    },

    /***/ 2057: /***/ module => {
      'use strict'
      module.exports = require('constants')

      /***/
    },

    /***/ 6113: /***/ module => {
      'use strict'
      module.exports = require('crypto')

      /***/
    },

    /***/ 2361: /***/ module => {
      'use strict'
      module.exports = require('events')

      /***/
    },

    /***/ 7147: /***/ module => {
      'use strict'
      module.exports = require('fs')

      /***/
    },

    /***/ 3685: /***/ module => {
      'use strict'
      module.exports = require('http')

      /***/
    },

    /***/ 5687: /***/ module => {
      'use strict'
      module.exports = require('https')

      /***/
    },

    /***/ 1808: /***/ module => {
      'use strict'
      module.exports = require('net')

      /***/
    },

    /***/ 2037: /***/ module => {
      'use strict'
      module.exports = require('os')

      /***/
    },

    /***/ 1017: /***/ module => {
      'use strict'
      module.exports = require('path')

      /***/
    },

    /***/ 2781: /***/ module => {
      'use strict'
      module.exports = require('stream')

      /***/
    },

    /***/ 4404: /***/ module => {
      'use strict'
      module.exports = require('tls')

      /***/
    },

    /***/ 3837: /***/ module => {
      'use strict'
      module.exports = require('util')

      /***/
    },

    /******/
  }
  /************************************************************************/
  /******/ // The module cache
  /******/ var __webpack_module_cache__ = {}
  /******/
  /******/ // The require function
  /******/ function __nccwpck_require__(moduleId) {
    /******/ // Check if module is in cache
    /******/ var cachedModule = __webpack_module_cache__[moduleId]
    /******/ if (cachedModule !== undefined) {
      /******/ return cachedModule.exports
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/ var module = (__webpack_module_cache__[moduleId] = {
      /******/ id: moduleId,
      /******/ loaded: false,
      /******/ exports: {},
      /******/
    })
    /******/
    /******/ // Execute the module function
    /******/ var threw = true
    /******/ try {
      /******/ __webpack_modules__[moduleId].call(
        module.exports,
        module,
        module.exports,
        __nccwpck_require__
      )
      /******/ threw = false
      /******/
    } finally {
      /******/ if (threw) delete __webpack_module_cache__[moduleId]
      /******/
    }
    /******/
    /******/ // Flag the module as loaded
    /******/ module.loaded = true
    /******/
    /******/ // Return the exports of the module
    /******/ return module.exports
    /******/
  }
  /******/
  /************************************************************************/
  /******/ /* webpack/runtime/node module decorator */
  /******/ ;(() => {
    /******/ __nccwpck_require__.nmd = module => {
      /******/ module.paths = []
      /******/ if (!module.children) module.children = []
      /******/ return module
      /******/
    }
    /******/
  })()
  /******/
  /******/ /* webpack/runtime/compat */
  /******/
  /******/ if (typeof __nccwpck_require__ !== 'undefined')
    __nccwpck_require__.ab = __dirname + '/'
  /******/
  /************************************************************************/
  var __webpack_exports__ = {}
  // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
  ;(() => {
    const core = __nccwpck_require__(2186)
    const { getChangedPackagesSinceRef } = __nccwpck_require__(9942)
    const { default: getReleasePlan } = __nccwpck_require__(9568)

    const getChangesetInfo = async () => {
      const ref = core.getInput('base-ref')
      const cwd = process.cwd()

      try {
        const changedPackages = await getChangedPackagesSinceRef({ cwd, ref })
        const releasePlan = await getReleasePlan(cwd, ref)
        const changedPackagesNames = changedPackages.map(
          ({ packageJson: { name } }) => name
        )
        const releasePackagesNames = releasePlan.releases.map(
          ({ name }) => name
        )
        const missingPackages = changedPackagesNames.filter(
          pkg => !releasePackagesNames.includes(pkg)
        )

        core.setOutput('changed-packages', changedPackagesNames)
        core.setOutput('release-packages', releasePackagesNames)
        core.setOutput('missing-packages', missingPackages)
      } catch (err) {
        core.error(err.message)
      }
    }

    getChangesetInfo()
  })()

  module.exports = __webpack_exports__
  /******/
})()
